<a href="/makemicromusic">back to list</a><h1>Dimension 31</h1><h3>genewardsmith &#x3C;genewardsmith@...&#x3E;</h3><span>1/14/2011 1:14:10 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>If you round off Michael&apos;s EC scale in 31 equal, you get 323143232314. If you mutate it to a (13 cent tolerance) lesfip scale and round off, you get the same 31et scale. For ec2, the 31 version goes 531432323122, and again the lesfip version gives the same 31et version. They are all pretty close. This makes me think that for dimension scales, Michael might have an easier time of it if he simply created scales that were 12 note subsets of 31edo.</p></div><h3>genewardsmith &#x3C;genewardsmith@...&#x3E;</h3><span>1/14/2011 1:41:39 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:MakeMicroMusic@yahoogroups.com">MakeMicroMusic@yahoogroups.com</a>, &quot;genewardsmith&quot; &lt;genewardsmith@...&gt; wrote:<br/>&gt;This makes me think that for dimension scales, Michael might have an easier time of it if he simply created scales that were 12 note subsets of 31edo.</p><p>If we equate the various modes, there are 31 choose 11 = 84,672,315 12 note 31edo scales. Since Michael is already programming and running programs, he might code up a search for the 12-note 31et scales with the greatest number of dyads from his list. Taking those with the maximum number, we could further look at which are proper, etc. For extra credit, the odd limits for 7, 9 and 11, same thing. It would make an interesting article for tuning or tuning-math.</p></div><h3>Michael &#x3C;djtrancendance@...&#x3E;</h3><span>1/14/2011 1:44:24 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene,<br/>  Firstly, thank you for taking the time to run all these little tests on my<br/>scales...</p><p>Gene&gt;&quot;If you mutate it (Dimension EC1) to a (13 cent tolerance) lesfip scale and<br/>round off, you get the same 31et scale.&quot;</p><p>      I am not surprised...I already knew the 22/15 and many of the 11-limit<br/>dyads in Dimension, for example, were in 31TET.  The real bugger is that 13 cent<br/>error (which dyad(s) approach that).   That is because for some of those<br/>sensitive 11-limit ratios I&apos;ve found...anything over 8 cents or so completely<br/>kills them (unlike tones like those near 5/4 which seem to have a much higher<br/>tolerance).</p><p>&gt;&quot;For EC2, the 31 version goes 531432323122, and again the lesfip version gives<br/>&gt;the same 31et version.&quot;</p><p>    Bizarre, the least squares optimization actually gives virtually the same<br/>value as the original scale (or, within how many cents)...especially considering<br/>my &quot;minimize error of worst possible dyad&quot; method of fine-tuning the scale is<br/>often at odds with &quot;least squares&quot;...  Any way you can post the lesfip version?<br/>Note to self...I wish there was an easy way to, say, turn that 5 into a 4 or<br/>decrease the number of different step sizes...</p><p>&gt;&quot;They are all pretty close. This makes me think that for dimension  scales,<br/>&gt;Michael might have an easier time of it if he simply created  scales that were<br/>&gt;12 note subsets of 31edo.&quot;</p><p>    The question to me becomes how much does this alignment knock of dyadic<br/>accuracy for the more sensitive dyads...I already knew a whole lot of the dyads,<br/>in JI form, had 31TET equivalents.  Or furthermore, will composing in 31TET<br/>feel/sound significantly different?  I am going to have to take a shot at<br/>composing both &quot;pure&quot; and &quot;31TET&quot; versions.   That and perhaps monkey around<br/>with moving certain notes by 1 step or so to see if I can &quot;get away&quot; with less<br/>different step sizes without killing the sense of balance.</p><p>&gt;&quot;Michael might have an easier time of it if he simply created scales that were<br/>&gt;12 note subsets of 31edo.&quot;</p><p>    Indeed, I might...seems like, slight dyadic optimizations aside...everything<br/>does fit in 31TET.  And, of course, working in 31TET would make development a<br/>lot quicker or, at &quot;worst&quot;...I&apos;d be able to find something under 31TET and<br/>simply fine-tune the ratios slightly.</p><p>[Non-text portions of this message have been removed]</p></div><h3>Michael &#x3C;djtrancendance@...&#x3E;</h3><span>1/14/2011 2:13:50 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene&gt;&quot;Since Michael is already programming and running programs, he might code<br/>up a search for the 12-note 31et scales with the greatest number of  dyads from<br/>his list.&quot;</p><p>Good idea!<br/>    If I have it right...(all) I should have to do is</p><p>A) Throw 12 loops to make the scale with each loop selecting one tone from the<br/>31TET list...IE (pseudocode)<br/>For tone = 1 to 31 - (12)  &apos;you can&apos;t be further that starting at the step of<br/>31TET where there are only 12 notes after and including that step...and still<br/>have a 12tone scale.<br/>{<br/>  for tone2 = tone to 31 - (11)<br/>  {<br/>     ....................................etc.<br/>  }<br/>}<br/>...not quite sure how to do this part most efficiently as I should ideally as I<br/>have to make sure none of the 12 notes is the same and, for best performance,<br/>should obviously avoid testing the same scale twice.</p><p>B) In the center of the loops...check all possible intervals from each tone to<br/>each other tone within 2 octave range and see how many of the combinations fit<br/>the list of dyads.  Add both the number of dyads contained and the scale steps<br/>in 31TET to a scale record.</p><p>C) Print the entire scale record...ordered by highest number of matching dyads<br/>first.</p><p>&gt;&quot;For extra credit, the odd limits for 7, 9 and 11, same thing.&quot;</p><p>      Meaning, for example simply put a list of all seven limit dyads....and see<br/>how many of them matched to a scale?</p><p>Perhaps another obvious step....make a version of this that works for any TET<br/>tunings (IE add an outer loop that lets the user select from a list of TET<br/>tunings, assigns notes, and loops through them all).   Or let them choose the<br/>desired number of notes in the scale (not quite sure how I would optimize the<br/>tone = loop for this)...</p><p>[Non-text portions of this message have been removed]</p></div><h3>genewardsmith &#x3C;genewardsmith@...&#x3E;</h3><span>1/14/2011 2:19:23 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:MakeMicroMusic@yahoogroups.com">MakeMicroMusic@yahoogroups.com</a>, Michael &lt;djtrancendance@...&gt; wrote:</p><p>&gt;     Bizarre, the least squares optimization actually gives virtually the same<br/>&gt; value as the original scale (or, within how many cents)...especially considering<br/>&gt; my &quot;minimize error of worst possible dyad&quot; method of fine-tuning the scale is<br/>&gt; often at odds with &quot;least squares&quot;...  Any way you can post the lesfip version?</p><p>! EClesfip.scl<br/>Lesfip scale from EC, 13 cents, 11-limit union {15/11, 22/15}<br/>! approximately 323143232314 in 31et<br/>12<br/>!<br/>114.87793<br/>191.77017<br/>311.62929<br/>346.93942<br/>501.24361<br/>617.92004<br/>697.71766<br/>815.58126<br/>888.24613<br/>1004.76728<br/>1045.29423<br/>1200.00000</p><p>! EC2lesfip.scl<br/>Lesfip scale from EC2, 13 cents, 11-limit union {15/11, 22/15}<br/>! approximately 531432323122 in 31et<br/>12<br/>!<br/>191.82959<br/>309.08106<br/>347.77355<br/>502.90469<br/>619.61886<br/>695.58039<br/>812.06094<br/>889.40374<br/>1006.00510<br/>1045.42407<br/>1122.07703<br/>1200.00000</p></div><h3>genewardsmith &#x3C;genewardsmith@...&#x3E;</h3><span>1/14/2011 2:25:50 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:MakeMicroMusic@yahoogroups.com">MakeMicroMusic@yahoogroups.com</a>, Michael &lt;djtrancendance@...&gt; wrote:<br/>&gt;<br/>&gt; Gene&gt;&quot;Since Michael is already programming and running programs, he might code<br/>&gt; up a search for the 12-note 31et scales with the greatest number of  dyads from<br/>&gt; his list.&quot;<br/>&gt;<br/>&gt; Good idea!<br/>&gt;     If I have it right...(all) I should have to do is</p><p>I think you are making it harder than you need to. I would include 31 (or 0, if you prefer) and then choose 11 from the remaining 30 notes. Which means the right number of scales is actually 30 choose 11 = 54,627,300 to examine.</p><p>&gt; &gt;&quot;For extra credit, the odd limits for 7, 9 and 11, same thing.&quot;<br/>&gt;<br/>&gt;       Meaning, for example simply put a list of all seven limit dyads....and see<br/>&gt; how many of them matched to a scale?</p><p>No, meaning go through all the same 55 million possibilities, but this time counting only 7-limit dyads.</p></div><h3>Michael &#x3C;djtrancendance@...&#x3E;</h3><span>1/15/2011 8:49:01 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene&gt;&quot;If we equate the various modes, there are 31 choose 11 = 84,672,315 12<br/>note 31edo scales.&quot;</p><p>    By equate modes...do you mean simply set the root at the first note of the<br/>scale....or is more complex logic involved?</p><p>     I&apos;m strong guessing it&apos;s more complex logic.  Just by assuming the first<br/>note in the scale is the same and others can move to wherever they want...I got<br/>some odd 6 billion or so for a scale count!   And that&apos;s obviously not what the<br/>&quot;NcR&quot; calculation gives (which is exactly what you gave)....</p><p>--------------------------------------------------<br/>   I have no clue off the top of my head how to efficiently check for duplicate<br/>modes.<br/>.   My best guess is<br/>A) Take every interval gap for each new scale and store it in a list IE the<br/>tuning indexes 1 4 5 7 would have a 2, 0, 1 list for interval gaps.  Then make<br/>new list items for each of the possible modes (IE 2,1,0 could also be 1,0,2 or<br/>0,2,1).</p><p>B1)  For every new 12-tone scale...check it&apos;s interval gap list against ALL<br/>other scale modes stored so far.</p><p>B2) Only add the scale to the stored scale list if there is NO match in B1</p><p>   The real problem is every new 12-note combination would include an extra<br/>loop, thus making it take many (I&apos;m thinking 100+ IE 12*12+) times as long to<br/>run.</p><p>Any ideas how to get around this?</p><p>[Non-text portions of this message have been removed]</p></div><h3>genewardsmith &#x3C;genewardsmith@...&#x3E;</h3><span>1/15/2011 10:41:45 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:MakeMicroMusic@yahoogroups.com">MakeMicroMusic@yahoogroups.com</a>, Michael &lt;djtrancendance@...&gt; wrote:<br/>&gt;<br/>&gt; Gene&gt;&quot;If we equate the various modes, there are 31 choose 11 = 84,672,315 12<br/>&gt; note 31edo scales.&quot;<br/>&gt;<br/>&gt;     By equate modes...do you mean simply set the root at the first note of the<br/>&gt; scale....or is more complex logic involved?</p><p>I shouldn&apos;t have said equate modes, since I didn&apos;t get around to discussing that. By equating them, I mean counting every mode as the same scale. A quick way to choose a mode out of all the possibilities is hashing: consider the scale to be a number base two, and then choose the smallest (or largest, if you prefer) among the circular permutations. For instance, the 12edo scale [2 4 5 7 9 11 12] would get the number 2^2+2^4+2^5+2^7+2^9+2^11+2^12 = 6836. A circular permutation with a smaller number is [1 3 5 6 8 10 12] with number 5482, so you&apos;d pick that as your canonical version of the scale. (I used a Scala-type format, with the number of the edo as the last number, so my hash function gives only even numbers; you may prefer to start at 0 instead.)</p></div><h3>Michael &#x3C;djtrancendance@...&#x3E;</h3><span>1/16/2011 2:05:22 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; Gene&gt;&quot;If we equate the various modes, there are 31 choose 11 = 84,672,315 12<br/>&gt; note 31edo scales.&quot;<br/>.......................<br/>Gene&gt;&quot;For instance, the 12edo scale [2 4 5 7 9 11 12] would get the number<br/>&gt;2^2+2^4+2^5+2^7+2^9+2^11+2^12 = 6836. A circular permutation with a smaller<br/>number is [1 3 5 6 8 10 &gt;12] with number 5482, so you&apos;d pick that as your<br/>canonical version of the scale.&quot;</p><p>Makes sense and seems clever enough but..........</p><p>Two fairly major issues (if I understand it correctly):</p><p>A) You still have to store 84,672,315 of such numbers (as I understand it) to<br/>make the compare list of hashes...and my computer doesn&apos;t have 168 = 84*2 (size<br/>of integer in byes) gigs of memory or (168 = 84*2) gigs of hard drive space<br/>free.  And that&apos;s assuming the size of the hash stored is that<br/>small...realistically I will likely need an 8 byte (long) integer for storage<br/>considering it&apos;s for 31 and not 12 notes!<br/>........this seems an inevitable for any hashing/compare-list methods as there<br/>are 84,672,315 unique combinations</p><p>B) How do you compare 6836 to 5482 (IE equality for different modes)?  They are<br/>not equal, so this seems to assume you have to have a clever way to find the<br/>lowest mode for each new scale you come up with...preferably a quick<br/>one...before running the compare.<br/>---------------</p><p>     The good news....is I have working code in Visual <a href="http://Basic.net">Basic.net</a> that does that<br/>task of finding the number of x-limit dyads in any size scale (and not just<br/>TET)...and considers dyad occurring from all roots of the scale and going across<br/>the octave.  It also tells you from what note to what note of the scale the<br/>dyads are formed from.<br/>Amazingly...those parts of the problem seemed fairly easy.</p><p>    Here is the SOURCE CODE in <a href="http://VB.NET">VB.NET</a> (note you must create list boxes named<br/>limitlist, tuninglist, listofdyads, and lisbox....and buttons named button1 &lt;to<br/>calculate number of dyads&gt; and button2 &lt;to add dyads of x-limit to your desired<br/>dyad list&gt;)...</p><p>Public Class Form1<br/>    Dim total As Long<br/>    Dim tuning As New ArrayList<br/>    Dim scale1 As New ArrayList<br/>    Dim dyadlist As New ArrayList<br/>    Dim dyadsintuning As New ArrayList<br/>    Dim centerror As Single</p><p>    Private Function getalldyadsforxlimit(ByVal limit As Integer) As ArrayList<br/>        Dim one As Integer<br/>        Dim two As Integer<br/>        Dim tempone As Single<br/>        Dim temptwo As Single<br/>        Dim dyad As Single<br/>        Dim tempdyadlist As New ArrayList<br/>        For one = 1 To limit<br/>            For two = one To (limit * 2) - 1<br/>                If ((two = limit) Xor (one = limit)) And ((two * 1.0) / (one *<br/>1.0) &lt;= 2.0) Then<br/>                    &apos;dyad can not be limit/limit IE 1<br/>                    &apos;one number in the numerator or denominator of the dyad must<br/>be the limit specified<br/>                    &apos;no dyad can be greater than the octave<br/>                    If two Mod 2 = 0 Or two = limit Then<br/>                        &apos;if there is an ODD number in the dyad over the limit<br/>                        &apos;IE the dyad is over the specified odd limit<br/>                        &apos;do not add the dyad to the list<br/>                        tempone = one<br/>                        temptwo = two<br/>                        dyad = temptwo / tempone<br/>                        tempdyadlist.Add(dyad)<br/>                    End If<br/>                End If<br/>            Next<br/>        Next<br/>        Return tempdyadlist<br/>    End Function</p><p>    Private Function generateTETtuning(ByVal numberoftones As Integer) As<br/>ArrayList<br/>        Dim index As Integer<br/>        Dim tempscale As New ArrayList<br/>        Dim root As Single = 2 ^ (1 / numberoftones)<br/>        Dim temp As Single = 1.0<br/>        For index = 1 To numberoftones<br/>            tempscale.Add(temp)<br/>            temp *= root<br/>        Next<br/>        Return tempscale<br/>    End Function</p><p>    Private Function pad(ByVal value As Integer) As String &apos;lets us sort the<br/>numbers correctly for display<br/>        If value &lt; 10 Then<br/>            Return &quot;00&quot; + value.ToString<br/>        Else<br/>            If value &lt; 100 Then<br/>                Return &quot;0&quot; + value.ToString<br/>            End If<br/>        End If<br/>    End Function</p><p>    Private Function comparedyads(ByVal scale1 As ArrayList, ByVal dyadlist As<br/>ArrayList) As ArrayList<br/>        Dim result As New ArrayList &apos;starts off as CLEAR/IE VALUELESS and then<br/>gets copied to result box<br/>        Dim dyadcount As Integer = 0<br/>        Dim resultstring As String<br/>        Dim first As Integer<br/>        Dim second As Integer<br/>        Dim dyad As Single<br/>        Dim index As Integer<br/>        Dim dyadresult As Single<br/>        Dim onnextoctave As Boolean<br/>        For first = 0 To scale1.Count - 1<br/>            For second = first To (scale1.Count * 2) - 1<br/>                &apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;<br/>                onnextoctave = False<br/>                dyad = 3<br/>                If second &gt; scale1.Count - 1 Then &apos;when index is past end of<br/>first octave...multiply by 2 to imitate</p><p>                    &apos;going onto second octave<br/>                    index = second - (scale1.Count)<br/>                    dyad = (scale1(index) * 2.0) / scale1(first)<br/>                    onnextoctave = True<br/>                Else<br/>                    dyad = scale1(second) / scale1(first)<br/>                End If<br/>                &apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;<br/>                If dyad &lt;= 2.0 Then &apos;if not<br/>                    For index = 0 To dyadlist.Count - 1<br/>                        dyadresult = Math.Abs(dyadlist(index) - dyad)<br/>                        If (dyadresult &lt; centerror) Then<br/>                            resultstring = Math.Round(dyad, 4).ToString + &quot; from<br/>scale position &quot; + pad(first) + &quot; to &quot;<br/>                            If onnextoctave Then<br/>                                result.Add(resultstring + (pad(second -<br/>scale1.Count)).ToString + &quot; on the next octave&quot;)<br/>                            Else<br/>                                result.Add(resultstring + pad(second))<br/>                            End If<br/>                            dyadcount += 1<br/>                        End If<br/>                    Next<br/>                    &apos;we can&apos;t do the below (easy) method as no dyad is going to<br/>be the exact same value as a perfect dyad<br/>                    &apos;(unless in a JI scale)<br/>                    &apos;If dyadlist.BinarySearch(dyad) Then &apos;is dyad in desired<br/>list<br/>                    &apos; result.Add(dyad)<br/>                    &apos;End If<br/>                End If<br/>            Next<br/>        Next<br/>        result.Add(&quot;  Total number of dyads in this scale from desired list is &quot;<br/>+ dyadcount.ToString())<br/>        Return result<br/>    End Function</p><p>    Private Sub Form1_Load(ByVal sender As System.Object, ByVal e As<br/>System.EventArgs) Handles MyBase.Load<br/>        Dim number As Integer<br/>        For number = 3 To 15<br/>            If number Mod 2 &lt;&gt; 0 Then<br/>                LimitList.Items.Add(number)<br/>            End If<br/>        Next</p><p>        LimitList.SelectedIndex = 2 &apos;select 7 limit when starting the program</p><p>        For number = 2 To 200<br/>            tuninglist.Items.Add(number)<br/>        Next number<br/>        tuninglist.SelectedIndex = 29 &apos;select 31TET when starting the program<br/>    End Sub</p><p>    Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As<br/>System.EventArgs) Handles <a href="http://Button1.Click">Button1.Click</a><br/>        Dim index<br/>        &apos;copy all dyads in selected dyad list on screen to calculation array<br/>        ListBox1.Items.Clear()<br/>        dyadlist.Clear()<br/>        For index = 0 To listofdyads.Items.Count - 1<br/>            dyadlist.Add(listofdyads.Items.Item(index))<br/>        Next index<br/>        &apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;<br/>        centerror = 0.0075 &apos;how far off a dyad can be and still be counted as<br/>being in the scale<br/>        tuning = generateTETtuning(Integer.Parse(tuninglist.SelectedItem))<br/>&apos;tuning is pre-sorted</p><p>        dyadsintuning = comparedyads(tuning, dyadlist) &apos;get how many dyads are<br/>in the tuning (or scale)<br/>        dyadsintuning.Sort()<br/>        ListBox1.DataSource = dyadsintuning &apos;list tuning in listbox for user<br/>    End Sub</p><p>    Private Sub Button2_Click(ByVal sender As System.Object, ByVal e As<br/>System.EventArgs) Handles <a href="http://Button2.Click">Button2.Click</a><br/>        Dim index As Integer<br/>        dyadlist = getalldyadsforxlimit(Integer.Parse(LimitList.SelectedItem))<br/>        dyadlist.Sort()<br/>        For index = 0 To dyadlist.Count - 1<br/>            listofdyads.Items.Add(dyadlist(index))<br/>        Next index<br/>    End Sub</p><p>    Private Sub listofdyads_KeyDown(ByVal sender As Object, ByVal e As<br/>System.Windows.Forms.KeyEventArgs) Handles listofdyads.KeyDown<br/>        If e.KeyCode = Keys.Delete Then<br/>            While listofdyads.SelectedItems.Count &gt; 0<br/>                listofdyads.Items.Remove(listofdyads.SelectedItem)<br/>            End While<br/>        End If<br/>    End Sub</p><p>    Private Sub indexloop(ByVal minnumber As Integer, ByVal maxnumber As<br/>Integer, ByVal tone As Integer)<br/>        Dim index As Integer<br/>        tone = tone - 1<br/>        If tone = 1 Then<br/>        Else<br/>            For index = minnumber To maxnumber<br/>                indexloop(index, maxnumber - tone, tone)<br/>            Next<br/>        End If<br/>        total += 1</p><p>    End Sub</p><p>    Function Combination(ByVal n As Long, ByVal r As Long) As Long<br/>        If (n = r Or r = 0) Then Return 1<br/>        Return n / (r * Combination(n - 1, r - 1))<br/>    End Function</p><p>End Class</p><p>[Non-text portions of this message have been removed]</p></div><h3>Michael &#x3C;djtrancendance@...&#x3E;</h3><span>1/16/2011 2:52:16 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene,</p><p>    One thing just hit me....nCr might NOT give the right number of<br/>combinations...since nCr does not seem to consider......</p><p>      The same scale in a different rotation as unique IE nCr gives the result<br/>of 6 trying to find sets of dyads in 4TET gives 6 and looking at it visually</p><p>1 2           (#1)<br/>1   3         (#2)<br/>1     4       (#3)<br/>   2  4       (#4)<br/>    3 4       (#5)<br/>  2 3         (#6)</p><p>....note that 5,6, and 1 are the same (just rotated)....and #2 and #4 are the<br/>same (just rotated).  So there appear to be 3, and not 6, unique &quot;modes&quot; in this<br/>example.</p><p>   The question then becomes...what mathematical formula would give the correct<br/>number of combinations...and would such a number be small enough not to<br/>overshoot my computers memory while storing the scale hash tables?</p><p>[Non-text portions of this message have been removed]</p></div><h3>genewardsmith &#x3C;genewardsmith@...&#x3E;</h3><span>1/16/2011 5:02:26 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:MakeMicroMusic@yahoogroups.com">MakeMicroMusic@yahoogroups.com</a>, Michael &lt;djtrancendance@...&gt; wrote:</p><p>&gt; A) You still have to store 84,672,315 of such numbers (as I understand it) to<br/>&gt; make the compare list of hashes...</p><p>Not at all. All you need to store are the hashes with the largest count of dyads; the list can be pruned as you go along and run into larger maxima, but that will stabilize.</p><p>&gt; B) How do you compare 6836 to 5482 (IE equality for different modes)?  They are<br/>&gt; not equal, so this seems to assume you have to have a clever way to find the<br/>&gt; lowest mode for each new scale you come up with...preferably a quick<br/>&gt; one...before running the compare.</p><p>There are only twelve circular permutations of a twelve note scale; find them all and pick the smallest hash value. I wouldn&apos;t call that clever, but it will work and should be quick.</p></div><h3>Michael &#x3C;djtrancendance@...&#x3E;</h3><span>1/16/2011 8:11:48 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene&gt;&quot;Not at all. All you need to store are the hashes with the largest count of<br/>dyads; the list can be pruned as you go along and run into larger maxima, but<br/>that will stabilize.&quot;</p><p>    Ah, so you only compare against the one to few scales/hashes you&apos;ve found<br/>with the largest number of dyads so far...rather than keep all lists and order<br/>them largest to smallest (IE what I was trying to do)?<br/>   In that case....I definitely won&apos;t run out of memory..... :-)</p><p>&gt;&quot;There are only twelve circular permutations of a twelve note scale; find them<br/>&gt;all and pick the smallest hash value. I wouldn&apos;t call that clever, but it will<br/>&gt;work and should be quick.&quot;</p><p>   Only twelve and not 31 in 31TET...how&apos;s that possible (there are 31 possible<br/>roots for the 12-tone scale, right)?</p><p>------------------------------------------------------------------</p><p>   Anyhow...I understand the overall method as follows...</p><p>--------do the following 12 (or 31?!) times---------------<br/>A) Increment the index of every other number in the scale<br/>B) Take a number from the end of the scale and move it to the beginning if it is<br/>over 12 (do a check)<br/>C) Get the hash<br/>D) See if the hash matches any of the hashes from the existing &quot;best scale so<br/>far&quot; hash (binary list search), if so, GIVE UP...otherwise keep adding hashes to<br/>a temporary hash list for all the scale&apos;s possible MODES<br/>---------------------------------------------------<br/>.....if you haven&apos;t given up, continue and.......<br/>F) Get the number of dyads in this &quot;new lowest&quot; scale (check all possible dyads)<br/>G) If your new dyad number is the lowest...store the scale, ALL possible hash<br/>modes, and number of dyads in a &quot;best scale so far&quot; record, overwriting the last<br/>one<br/>..........repeat entire process and your best scale and number of dyads should<br/>be in the &quot;best scale so far&quot; record.............</p><p>    A major question is what to do first....so far as singling out scales that<br/>either have more dyads than the best scale or the same hash as the best scale.<br/>I figure singling new scales out by hashes (IE calculating that by necessity for<br/>every scale) is faster than having to calculate all dyads for every<br/>scale....opinion(s)?</p><p>[Non-text portions of this message have been removed]</p></div><h3>genewardsmith &#x3C;genewardsmith@...&#x3E;</h3><span>1/16/2011 12:12:57 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:MakeMicroMusic@yahoogroups.com">MakeMicroMusic@yahoogroups.com</a>, Michael &lt;djtrancendance@...&gt; wrote:</p><p>&gt; &gt;&quot;There are only twelve circular permutations of a twelve note scale; find them<br/>&gt; &gt;all and pick the smallest hash value. I wouldn&apos;t call that clever, but it will<br/>&gt; &gt;work and should be quick.&quot;<br/>&gt;<br/>&gt;    Only twelve and not 31 in 31TET...how&apos;s that possible</p><p>Because you want to start the scale on a note of the scale, and there are 12 of those in an octave.</p><p>&gt;     A major question is what to do first....</p><p>First figure out how to make it work with 12 notes and not 31. Then, check all the various cyclic permutations, and see if this one has the lowest hash number. If it does, do the dyad count. If it equals or exceeds the maximum, store.</p></div>