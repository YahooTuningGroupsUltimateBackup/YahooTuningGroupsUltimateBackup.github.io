<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math Re: finding n-limit ratios</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>Re: finding n-limit ratios</h1><h3><a id=615 href="#615">ðŸ”—</a>Robert Walker &#x3C;robertwalker@ntlworld.com&#x3E;</h3><span>7/31/2001 7:10:28 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi there,</p><p>I&apos;ve been working recently on section of FTS that finds close<br/>approximations to n-limit ratios</p><p>You can find it in current beta preview, but it is very slow<br/>for large quotients. It does it just by testing all quotients,<br/>and working out what the denominator would be for that quotient,<br/>then if denom / denum is within the desired tolerance,<br/>checks if they are both n-limit. If denom is n-limit, and denum isn&apos;t,<br/>does an increment / decrement of denum until it finds one that is okay,<br/>or until it goes outside the desired tolerance.</p><p>However, even that fairly crude technique is useful for this<br/>work, where small values of denom. and denum. are interesting to find.<br/>It&apos;s not too bad for max quotient of 1000.</p><p>I&apos;m interested to extend the range.</p><p>I&apos;ve been trying a very simple technique:</p><p>suppose r = ratio, and suppose you want it 5 limit,<br/>then write</p><p>r~= 2^a*3^b*5^c</p><p>as<br/>log r ~= a log 2 + b log 3 + c log 5</p><p>Now set a max quotient to find and tolerance in cents<br/>in advance.</p><p>From that, one can calculate a max possible power for each<br/>of the exponents. E.g. b &lt; log(N)/log 3 where N is the max quotient.</p><p>Now just loop over all the possible values for b and c.<br/>Leave a free, since as a power of 2, it will be the largest.</p><p>For each value of b, c, you can then work out a value for a<br/>as<br/>a = (log r - b log 3 - c log 5)/ log 2</p><p>and since you want an integer, use the floor and ceil of a<br/>i.e. nearest integers above and below.</p><p>This is very fast for 5 limit ratios.</p><p>E.g. for max quotient of 1000000, you have<br/>integer part of log(1000000)/log(5)= 10<br/>and of log(1000000)/log(3)= 12</p><p>So, taking negative numbers into account you have<br/>24*16 = 384 loops to do for each ratio. That&apos;s tiny,<br/>even if you are testing maybe 20 numbers or more,<br/>and doing a fair bit of processing in each loop.</p><p>Even up to max quotient of 1000000000000 works fine.</p><p>Doubling the number of digits will only double the<br/>range for each of the powers, and since there are<br/>two involved, that quadruples the time.</p><p>Add in fourth factor though<br/>2 3 5 7<br/>and you begin to get into seriously large numbers.<br/>Each time you double the number of digits you<br/>multiply the time needed by 8. That&apos;s a siginificant<br/>difference.</p><p>Add a couple more factors and it is getting on for as<br/>slow as the method of checking all the quotients in<br/>succession, for small quotients (of course<br/>it will always be faster for large quotients<br/>if you are willing to wait for the answer).</p><p>I can refine this a little by just doing things<br/>more efficiently.</p><p>However, I wondered if there is any way to go more<br/>directly to the solution rather than search all<br/>the points of the lattice. I&apos;ve been puzzling it<br/>over but haven&apos;t come up with anything yet.</p><p>I&apos;ve heard of the LLL and PLSQ algorithms.<br/>However, seems to me if you look for an integer<br/>relation between (r, log 2, log 3, log 5, log 7)<br/>then you are as likely to find a relation with 0<br/>coeff. for r as one involving r and the remaining<br/>ones. Also if you find a relation involving r,<br/>then the coeff. for r could be greater than 1,<br/>and that would be no good either. Am I missing<br/>something?</p><p>I&apos;ve had a look for free source code<br/>for PLSQ but only found gpld code which I can&apos;t<br/>use in FTS. However, if it is likely to solve this<br/>I&apos;ll be interested to look more thoroughly, or<br/>if nec, try and see if I can code it myself,<br/>which should be poss, if I can find a good<br/>clear description somewhere of how it works.</p><p>Any thoughts? Or hints of an idea even that might<br/>lead to something?</p><p>Robert</p></div><h3><a id=616 href="#616">ðŸ”—</a>Robert Walker &#x3C;robertwalker@ntlworld.com&#x3E;</h3><span>7/31/2001 7:21:15 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi there,</p><p>&gt; However, seems to me if you look for an integer<br/>&gt; relation between (r, log 2, log 3, log 5, log 7)<br/>that of course should be</p><p>&gt; relation between (log r, log 2, log 3, log 5, log 7)</p><p>so if coeff of log r &gt; 1 you end up with a nice expression<br/>of, say, r^3 as an n-limit ratio.</p><p>Robert</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            