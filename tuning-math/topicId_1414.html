<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math LLL definitions</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>LLL definitions</h1><h3><a id=1414 href="#1414">ðŸ”—</a>genewardsmith@juno.com</h3><span>11/17/2001 9:05:43 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>We begin with a real n-dimensional vector space R^n with an inner<br/>product, which we denote by &lt;u, v&gt;. In orthonormal coordinates this<br/>will be the ordinary dot product; if we want another inner product<br/>for LLL reduction one way to do it is to transform coordinates and<br/>then transform them back.</p><p>The goal of lattice basis reduction is to obtain a lattice basis<br/>equivalent to a given basis that consists of short vectors or, stated<br/>another way, into a basis consisting of vectors that are pairwise<br/>nearly orthogonal.</p><p>Starting from an ordered lattice basis [b_1, b_2, ..., b_m] we can<br/>obtain another basis [g_1, g_2, ..., g_m] by the Gram-Schmidt<br/>orthogonalization process. This will span the same linear subspace,<br/>but *not*, normally, the same lattice. We also obtain Gram-Schmidt<br/>coefficients:</p><p>c[i,j] = &lt;b_i, g_j&gt;/&lt;g_j, g_j&gt;</p><p>We do this by the standard Gram-Schmidt recursion from linear algebra:</p><p>g_1 = b_1<br/>g_i = b_i - sum_{j = 1 to i - 1} c[i,j] g_j</p><p>Definition:<br/>An ordered basis [b_1, b_2, ..., b_m] in R^n is called *size-reduced*<br/>if |c[i,j]| &lt;= 1/2 for 1 &lt;= j &lt; i &lt;= m.</p><p>Definition:<br/>An ordered basis [b_1, b_2, ..., b_m] in R^n is called<br/>*LLL-reduced with constant d*, where d satisfies 1/4 &lt; d &lt; 1, if it<br/>is size-reduced and if</p><p>d |g_{k-1}|^2 &lt;= |g_k + c[k, k-1] g_{k-1}|^2 for k = 2, 3, ..., m.</p><p>The constant d is not documented in the sketchy Maple help file, but<br/>chances are good it is 3/4, since this is what Lenstra, Lenstra and<br/>Lovasz used originally and it is a sort of default standard. The<br/>larger d is the better your chance of an optimal reduction, but for<br/>such small problems as we are looking at I suspect we are getting<br/>that anyway.</p></div><h3><a id=1416 href="#1416">ðŸ”—</a>Paul Erlich &#x3C;paul@stretch-music.com&#x3E;</h3><span>11/17/2001 9:25:42 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., genewardsmith@j... wrote:</p><p>&gt; We begin with a real n-dimensional vector space R^n with an inner<br/>&gt; product, which we denote by &lt;u, v&gt;. In orthonormal coordinates this<br/>&gt; will be the ordinary dot product; if we want another inner product<br/>&gt; for LLL reduction one way to do it is to transform coordinates and<br/>&gt; then transform them back.</p><p>Is there a continuous, reversible transformation between Euclidean<br/>and taxicab?<br/>&gt;<br/>&gt; Starting from an ordered lattice basis [b_1, b_2, ..., b_m] we can<br/>&gt; obtain another basis [g_1, g_2, ..., g_m] by the Gram-Schmidt<br/>&gt; orthogonalization process. This will span the same linear subspace,<br/>&gt; but *not*, normally, the same lattice.</p><p>What do you mean by the &quot;lattice&quot; spanned by a particular basis, as<br/>opposed to the linear subspace spanned by a particular basis? Do you<br/>mean something that musically speaking, is or corresponds to the<br/>particular JI Fokker periodicity block (just a guess)?</p><p>&gt; We also obtain Gram-Schmidt<br/>&gt; coefficients:<br/>&gt;<br/>&gt; c[i,j] = &lt;b_i, g_j&gt;/&lt;g_j, g_j&gt;</p><p>OK . . .</p><p>&gt; We do this by the standard Gram-Schmidt recursion from linear<br/>algebra:</p><p>&gt; g_1 = b_1<br/>&gt; g_i = b_i - sum_{j = 1 to i - 1} c[i,j] g_j</p><p>This I&apos;m familiar with.</p><p>&gt; Definition:<br/>&gt; An ordered basis [b_1, b_2, ..., b_m] in R^n is called *size-<br/>reduced*<br/>&gt; if |c[i,j]| &lt;= 1/2 for 1 &lt;= j &lt; i &lt;= m.</p><p>I&apos;m confused as to why you use b here rather than g. I thought b was<br/>the given basis, and g the derived one.</p><p>Given a basis (but allowing changes that leave the linear subspace<br/>unchanged), does this size-reduced basis always exist? Is it always<br/>unique?</p><p>&gt; Definition:<br/>&gt; An ordered basis [b_1, b_2, ..., b_m] in R^n is called<br/>&gt; *LLL-reduced with constant d*, where d satisfies 1/4 &lt; d &lt; 1, if it<br/>&gt; is size-reduced and if<br/>&gt;<br/>&gt; d |g_{k-1}|^2 &lt;= |g_k + c[k, k-1] g_{k-1}|^2 for k = 2, 3, ..., m.</p><p>Hmm . . . how is this motivated?</p><p>&gt; The constant d is not documented in the sketchy Maple help file,<br/>but<br/>&gt; chances are good it is 3/4, since this is what Lenstra, Lenstra and<br/>&gt; Lovasz used originally and it is a sort of default standard. The<br/>&gt; larger d is the better your chance of an optimal reduction, but for<br/>&gt; such small problems as we are looking at I suspect we are getting<br/>&gt; that anyway.</p><p>Hmm . . . do certain values of d guarantee existence, and/or do<br/>certain other values guarantee uniqueness?</p></div><h3><a id=1418 href="#1418">ðŸ”—</a>genewardsmith@juno.com</h3><span>11/17/2001 9:47:27 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., &quot;Paul Erlich&quot; &lt;paul@s...&gt; wrote:</p><p>&gt; Is there a continuous, reversible transformation between Euclidean<br/>&gt; and taxicab?</p><p>In the finite-dimensional case, they define the same topology; hence<br/>the identity map is continuous.</p><p>&gt; What do you mean by the &quot;lattice&quot; spanned by a particular basis, as<br/>&gt; opposed to the linear subspace spanned by a particular basis?</p><p>The lattice consists of the Z-linear combinations of basis vectors;<br/>if they are [1, 2, 1] and [0, 1 0] then the lattice is [a, 2a + b, a]<br/>for any pair of integers a and b. The subspace consists of the<br/>R-linear combinations, so in this case a and b are any real numbers.</p><p>&gt; &gt; Definition:<br/>&gt; &gt; An ordered basis [b_1, b_2, ..., b_m] in R^n is called *size-<br/>&gt; reduced*<br/>&gt; &gt; if |c[i,j]| &lt;= 1/2 for 1 &lt;= j &lt; i &lt;= m.</p><p>&gt; I&apos;m confused as to why you use b here rather than g. I thought b<br/>was<br/>&gt; the given basis, and g the derived one.</p><p>So it is, but it&apos;s b which is or isn&apos;t size reduced. We create g and<br/>c in order to find if b is size-reduced.</p><p>&gt; Given a basis (but allowing changes that leave the linear subspace<br/>&gt; unchanged), does this size-reduced basis always exist? Is it always<br/>&gt; unique?</p><p>It exists, since we can show the LLL algorithm works, and that gives<br/>size-reduction plus more. It is not in general unique.</p><p>&gt;<br/>&gt; &gt; Definition:<br/>&gt; &gt; An ordered basis [b_1, b_2, ..., b_m] in R^n is called<br/>&gt; &gt; *LLL-reduced with constant d*, where d satisfies 1/4 &lt; d &lt; 1, if<br/>it<br/>&gt; &gt; is size-reduced and if<br/>&gt; &gt;<br/>&gt; &gt; d |g_{k-1}|^2 &lt;= |g_k + c[k, k-1] g_{k-1}|^2 for k = 2, 3, ..., m.</p><p>&gt; Hmm . . . how is this motivated?</p><p>I warned you this was ugly. Using this definition, we can prove<br/>theorems showing that the basis vectors of an LLL-reduced basis can&apos;t<br/>be too large, relatively speaking. We can also get a polynomial time<br/>algorithm which gives us such a reduced basis.</p><p>&gt; Hmm . . . do certain values of d guarantee existence, and/or do<br/>&gt; certain other values guarantee uniqueness?</p><p>We don&apos;t have uniqueness, though in practice for such small problems<br/>as we are looking at we very likely do get it. Existence we do have,<br/>since LLL will work for this range of d.</p></div><h3><a id=1420 href="#1420">ðŸ”—</a>Paul Erlich &#x3C;paul@stretch-music.com&#x3E;</h3><span>11/17/2001 10:06:04 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., genewardsmith@j... wrote:<br/>&gt; --- In tuning-math@y..., &quot;Paul Erlich&quot; &lt;paul@s...&gt; wrote:<br/>&gt;<br/>&gt; &gt; Is there a continuous, reversible transformation between<br/>Euclidean<br/>&gt; &gt; and taxicab?<br/>&gt;<br/>&gt; In the finite-dimensional case, they define the same topology;<br/>hence<br/>&gt; the identity map is continuous.</p><p>So that&apos;s promising for being able to use the Tenney metric<br/>eventually, yes?<br/>&gt;<br/>&gt; &gt; What do you mean by the &quot;lattice&quot; spanned by a particular basis,<br/>as<br/>&gt; &gt; opposed to the linear subspace spanned by a particular basis?<br/>&gt;<br/>&gt; The lattice consists of the Z-linear combinations of basis vectors;<br/>&gt; if they are [1, 2, 1] and [0, 1 0] then the lattice is [a, 2a + b,<br/>a]<br/>&gt; for any pair of integers a and b. The subspace consists of the<br/>&gt; R-linear combinations, so in this case a and b are any real numbers.</p><p>OK . . . somehow I has skipped over the whole orthogonalization step<br/>in my mind when I asked this question. Sorry! Now I&apos;m confused</p><p>&gt; &gt; &gt; Definition:<br/>&gt; &gt; &gt; An ordered basis [b_1, b_2, ..., b_m] in R^n is called *size-<br/>&gt; &gt; reduced*<br/>&gt; &gt; &gt; if |c[i,j]| &lt;= 1/2 for 1 &lt;= j &lt; i &lt;= m.<br/>&gt;<br/>&gt; &gt; I&apos;m confused as to why you use b here rather than g. I thought b<br/>&gt; was<br/>&gt; &gt; the given basis, and g the derived one.<br/>&gt;<br/>&gt; So it is, but it&apos;s b which is or isn&apos;t size reduced. We create g<br/>and<br/>&gt; c in order to find if b is size-reduced.</p><p>OK -- so you should have said &quot;for all g&quot; in the definition . . .<br/>yes? Or is g uniquely defined? It would seem to depend on how you<br/>order the elements of b, since the first vector is made to be the<br/>same.<br/>&gt;<br/>&gt; &gt; Given a basis (but allowing changes that leave the linear<br/>subspace<br/>&gt; &gt; unchanged), does this size-reduced basis always exist? Is it<br/>always<br/>&gt; &gt; unique?<br/>&gt;<br/>&gt; It exists, since we can show the LLL algorithm works, and that<br/>gives<br/>&gt; size-reduction plus more. It is not in general unique.</p><p>Well that kind of slams the door on the &quot;classification&quot; I was hoping<br/>to acheive, though I suppose a classification by optimal generators<br/>would be good enough (and would eliminate the need to use LLL, but I<br/>feel we should still have some lower bound on<br/>allowable &quot;orthogonality&quot;).</p><p>&gt; &gt; Hmm . . . do certain values of d guarantee existence, and/or do<br/>&gt; &gt; certain other values guarantee uniqueness?<br/>&gt;<br/>&gt; We don&apos;t have uniqueness, though in practice for such small<br/>problems<br/>&gt; as we are looking at we very likely do get it.</p><p>Can we determine for certain whether we do or don&apos;t in any particular<br/>case?</p><p>&gt; Existence we do have,<br/>&gt; since LLL will work for this range of d.</p><p>I was thinking that two different choices of b might turn out to be<br/>equal contenders for the LLL throne for a particular equivalence<br/>class of b&apos;s. Possible or impossible?</p></div><h3><a id=1422 href="#1422">ðŸ”—</a>genewardsmith@juno.com</h3><span>11/17/2001 10:21:27 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., &quot;Paul Erlich&quot; &lt;paul@s...&gt; wrote:<br/>&gt; --- In tuning-math@y..., genewardsmith@j... wrote:</p><p>&gt; &gt; In the finite-dimensional case, they define the same topology;<br/>&gt; hence<br/>&gt; &gt; the identity map is continuous.</p><p>&gt; So that&apos;s promising for being able to use the Tenney metric<br/>&gt; eventually, yes?</p><p>So far as I can see we can&apos;t use it unless we dig up an L1 version of<br/>LLL, but it does give grounds for hope the answers would often be the<br/>same.<br/>&gt; OK -- so you should have said &quot;for all g&quot; in the definition . . .<br/>&gt; yes? Or is g uniquely defined? It would seem to depend on how you<br/>&gt; order the elements of b, since the first vector is made to be the<br/>&gt; same.</p><p>It does depend on the fact that b is ordered, which is why we started<br/>with an ordered basis. It is uniquely defined given the ordering.</p><p>&gt; Can we determine for certain whether we do or don&apos;t in any<br/>particular<br/>&gt; case?</p><p>I think in such small cases that might be possible; in general this<br/>turns into a non-polynomial time mess.</p><p>&gt; &gt; Existence we do have,<br/>&gt; &gt; since LLL will work for this range of d.</p><p>&gt; I was thinking that two different choices of b might turn out to be<br/>&gt; equal contenders for the LLL throne for a particular equivalence<br/>&gt; class of b&apos;s. Possible or impossible?</p><p>In theory possible, in practice I think we may be OK. We are not<br/>working in the 101 limit, after all.</p></div><h3><a id=1424 href="#1424">ðŸ”—</a>Paul Erlich &#x3C;paul@stretch-music.com&#x3E;</h3><span>11/17/2001 10:30:08 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., genewardsmith@j... wrote:<br/>&gt; --- In tuning-math@y..., &quot;Paul Erlich&quot; &lt;paul@s...&gt; wrote:<br/>&gt; &gt; --- In tuning-math@y..., genewardsmith@j... wrote:<br/>&gt;<br/>&gt; &gt; &gt; In the finite-dimensional case, they define the same topology;<br/>&gt; &gt; hence<br/>&gt; &gt; &gt; the identity map is continuous.<br/>&gt;<br/>&gt; &gt; So that&apos;s promising for being able to use the Tenney metric<br/>&gt; &gt; eventually, yes?<br/>&gt;<br/>&gt; So far as I can see we can&apos;t use it unless we dig up an L1 version<br/>of<br/>&gt; LLL, but it does give grounds for hope the answers would often be<br/>the<br/>&gt; same.</p><p>But you said,</p><p>&quot;if we want another inner product<br/>for LLL reduction one way to do it is to transform coordinates and<br/>then transform them back.&quot;</p><p>Is there an inner product that is appropriate to the taxicab metric?<br/>Am I confused about something?</p><p>&gt; &gt; OK -- so you should have said &quot;for all g&quot; in the definition . . .<br/>&gt; &gt; yes? Or is g uniquely defined? It would seem to depend on how you<br/>&gt; &gt; order the elements of b, since the first vector is made to be the<br/>&gt; &gt; same.<br/>&gt;<br/>&gt; It does depend on the fact that b is ordered, which is why we<br/>started<br/>&gt; with an ordered basis.</p><p>Hmm . . . shouldn&apos;t we then try all permutations of a given basis? Or<br/>do the elements have to be in descending order of length? I don&apos;t<br/>think this is assumed for Gram-Schmidt generally, is it?</p><p>&gt; &gt; Can we determine for certain whether we do or don&apos;t in any<br/>&gt; particular<br/>&gt; &gt; case?<br/>&gt;<br/>&gt; I think in such small cases that might be possible; in general this<br/>&gt; turns into a non-polynomial time mess.</p><p>Well, it would be cool to be sure of uniqueness.</p><p>&gt; &gt; &gt; Existence we do have,<br/>&gt; &gt; &gt; since LLL will work for this range of d.<br/>&gt;<br/>&gt; &gt; I was thinking that two different choices of b might turn out to<br/>be<br/>&gt; &gt; equal contenders for the LLL throne for a particular equivalence<br/>&gt; &gt; class of b&apos;s. Possible or impossible?<br/>&gt;<br/>&gt; In theory possible, in practice I think we may be OK. We are not<br/>&gt; working in the 101 limit, after all.</p><p>Well, having equal contenders us something that, to my intuition,<br/>could happen just as easily in few dimensions as in many . . . no?</p></div><h3><a id=1454 href="#1454">ðŸ”—</a>graham@microtonal.co.uk</h3><span>11/20/2001 4:45:00 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>In-Reply-To: &lt;<a href="mailto:9t7fj7+odag@eGroups.com">9t7fj7+odag@eGroups.com</a>&gt;<br/>Gene wrote:</p><p>&gt; Starting from an ordered lattice basis [b_1, b_2, ..., b_m] we can<br/>&gt; obtain another basis [g_1, g_2, ..., g_m] by the Gram-Schmidt<br/>&gt; orthogonalization process. This will span the same linear subspace,<br/>&gt; but *not*, normally, the same lattice. We also obtain Gram-Schmidt<br/>&gt; coefficients:</p><p>What&apos;s an ordered basis?</p><p>&gt; c[i,j] = &lt;b_i, g_j&gt;/&lt;g_j, g_j&gt;</p><p>I&apos;ve implemented this in Python code:</p><p>import operator</p><p>def dotprod(x,y):<br/>    return reduce(operator.add,<br/>        map(operator.mul, x, y))</p><p>def makec(b,g):<br/>    c = []<br/>    for i in range(len(g)):<br/>        row = []<br/>        for j in range(len(g)):<br/>            row.append(float(dotprod(b[i],g[j]))<br/>                / dotprod(g[j], g[j]))<br/>        c.append(row)<br/>    return c</p><p>Please say if I&apos;m going wrong anywhere.  One thing that worries me is that<br/>I&apos;m getting floating point results where you stay with integers.</p><p>&gt; We do this by the standard Gram-Schmidt recursion from linear algebra:<br/>&gt;<br/>&gt; g_1 = b_1<br/>&gt; g_i = b_i - sum_{j = 1 to i - 1} c[i,j] g_j</p><p>Again, I&apos;ve implemented that</p><p>def LLL(b, g):<br/>    c = makec(b,g)<br/>    newg = []<br/>    for i in range(len(g)):<br/>        row = []<br/>        for k in range(len(g)):<br/>            thing = b[i][k]<br/>            for j in range(i):<br/>                thing -= c[i][j] * j[j][k]<br/>            row.append(thing)<br/>        newg.append(row)<br/>    return newg</p><p>I&apos;m assuming that repeatedly applying this will give the right result, but<br/>it clearly doesn&apos;t.  For one thing, the first ratio can never change.<br/>Also, you haven&apos;t said what seed value to use for g.  I&apos;m using the<br/>initial value of b.</p><p>If you can supply an alternative algorithm in some kind of procedural<br/>code, that would be cood too.  I&apos;ve found LiDIA, and it comes with the<br/>source code but an imperfect license.  I&apos;ll have a look at it sometimt.</p><p>                 Graham</p></div><h3><a id=1455 href="#1455">ðŸ”—</a>genewardsmith@juno.com</h3><span>11/20/2001 11:56:30 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:</p><p>&gt; What&apos;s an ordered basis?</p><p>It&apos;s a basis you take in a certain order--first element, second<br/>element, etc.</p><p>&gt; &gt; c[i,j] = &lt;b_i, g_j&gt;/&lt;g_j, g_j&gt;</p><p>&gt; I&apos;ve implemented this in Python code:</p><p>&gt; Please say if I&apos;m going wrong anywhere.</p><p>It looks right to me, but I don&apos;t know Python.</p><p>  One thing that worries me is that<br/>&gt; I&apos;m getting floating point results where you stay with integers.</p><p>If you start with integers, you get rational numbers, and hence you<br/>will get floating points in your implementation of Gram-Schmidt. The<br/>integers I am staying with are simply the integers in a reduced basis<br/>that starts out with integers.</p><p>&gt; Again, I&apos;ve implemented that</p><p>&gt; I&apos;m assuming that repeatedly applying this will give the right<br/>result, but<br/>&gt; it clearly doesn&apos;t.</p><p>What I gave was a definition of LLL reduced, not the LLL algorithm<br/>itself; that has two different kinds of steps in it.</p><p>Here is some code I took off the web, which comes with a reference.<br/>Starting with the pseudocode in a reference book on algorithms, or<br/>trying to adapt some code in another implementation, seems like the<br/>way to go to me.</p><p># This follows the algorithm given in Maurice Mignotte&apos;s<br/># &quot;Mathematics for Computer Algebra&quot;</p><p>LLL := proc()<br/>    local dim, basis, new_basis, local_iprod, local_norm, local_c, i,<br/>            j, u, B, k, h, l;</p><p>    basis := args[1];</p><p>    dim := nops(basis);</p><p>    local_iprod := linalg[innerprod];<br/>    local_norm  := proc(v::vector)<br/>            RETURN(linalg[norm](v,2));<br/>        end:<br/>    local_c := 0.75;</p><p>    for i from 2 to nargs do<br/>        if op(1,args[i]) = iprod then<br/>            local_iprod := op(2,args[i]);<br/>            local_norm := proc(v::vector)<br/>                    RETURN(sqrt(local_iprod(v,v)));<br/>                end;<br/>        elif op(1,args[i]) = norm then<br/>            local_norm := op(2,args[i]);<br/>        elif op(1,args[i]) = c then<br/>            local_c := op(2,args[i]);<br/>        fi;<br/>    od;</p><p>For one thing, the first ratio can never change.<br/>&gt; Also, you haven&apos;t said what seed value to use for g.  I&apos;m using the<br/>&gt; initial value of b.</p><p>g doesn&apos;t need a seed value, it&apos;s just the Gram-Schmidt<br/>orthogonalization of b.</p></div><h3><a id=1456 href="#1456">ðŸ”—</a>Graham Breed &#x3C;graham@microtonal.co.uk&#x3E;</h3><span>11/18/2001 2:09:39 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Paul wrote:</p><p>&gt; Well that kind of slams the door on the &quot;classification&quot; I was hoping<br/>&gt; to acheive, though I suppose a classification by optimal generators<br/>&gt; would be good enough (and would eliminate the need to use LLL, but I<br/>&gt; feel we should still have some lower bound on<br/>&gt; allowable &quot;orthogonality&quot;).</p><p>The mapping by period and generator is unique for any linear temperament,<br/>which should be relevant here.  Some caveats:</p><p>There are always two choices of generator within the period.  I used to<br/>always take the smaller, but sometimes it became the larger after<br/>optimization.  So you can make the arbitrary choice that the first nonzero<br/>term be negative.</p><p>For similar reasons, there may be more than one period mapping.  I think we<br/>can do without it, and take the raw generator mapping, including a common<br/>factor showing the number of periods to the octave.</p><p>If you&apos;re going to do that, you have to get rid of torsion.  I expect any<br/>decent LLL algorithm will do this.</p><p>Going from unison vectors to linear temperaments is a done deal.  I have a<br/>fresh installation of Mandrake 8.1 here, which comes with Numeric Python as<br/>standard!  So, all I need to do is make a local copy of my website and I can<br/>look into these things.</p><p>It also comes with Octave.  Is that supposed to do LLL?</p><p>                            Graham</p></div><h3><a id=1460 href="#1460">ðŸ”—</a>genewardsmith@juno.com</h3><span>11/20/2001 12:52:41 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., Graham Breed &lt;graham@m...&gt; wrote:</p><p>&gt; &gt; Well that kind of slams the door on the &quot;classification&quot; I was<br/>hoping<br/>&gt; &gt; to acheive, though I suppose a classification by optimal<br/>generators<br/>&gt; &gt; would be good enough (and would eliminate the need to use LLL,<br/>but I<br/>&gt; &gt; feel we should still have some lower bound on<br/>&gt; &gt; allowable &quot;orthogonality&quot;).</p><p>&gt; The mapping by period and generator is unique for any linear<br/>temperament,<br/>&gt; which should be relevant here.  Some caveats:</p><p>Minkowski reduction should do what Paul wants; the caveats would<br/>concern symmetries which shouldn&apos;t happen.</p><p>&gt; There are always two choices of generator within the period.  I<br/>used to<br/>&gt; always take the smaller, but sometimes it became the larger after<br/>&gt; optimization.  So you can make the arbitrary choice that the first<br/>nonzero<br/>&gt; term be negative.</p><p>The lattice reduction approach doesn&apos;t always give us<br/>generator/period; it is optimizing steps to get to good intevals, and<br/>that isn&apos;t always generator/period.</p></div><h3><a id=1473 href="#1473">ðŸ”—</a>graham@microtonal.co.uk</h3><span>11/21/2001 2:21:00 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>In-Reply-To: &lt;<a href="mailto:9tefqp+vq4h@eGroups.com">9tefqp+vq4h@eGroups.com</a>&gt;<br/>Gene wrote:</p><p>&gt; The lattice reduction approach doesn&apos;t always give us<br/>&gt; generator/period; it is optimizing steps to get to good intevals, and<br/>&gt; that isn&apos;t always generator/period.</p><p>If Paul&apos;s conjecture is correct (and last time I mentioned it, you said<br/>you&apos;d proved it) you should always be able to get the generator and period<br/>for a complete, linearly independent set of chromatic and commatic unison<br/>vectors.  I also have a program, the source code of which you can inspect,<br/>that does the job.  I did run into problems using an arbitrary chromatic<br/>unison vector last weekend, and will look at that next weekend.  It should<br/>be possible to get a mapping by generator and period, but the number of<br/>steps to either won&apos;t be defined.</p><p>See &lt;<a href="http://x31eq.com/vectors.html">http://x31eq.com/vectors.html</a>&gt;.</p><p>None of this requires the lattice to be reduced.  That&apos;s for going in the<br/>other direction (mapping to unison vectors) and getting the simplest<br/>results.  As I&apos;m having trouble getting this working, perhaps you could<br/>reduce this octave-specific basis for me.  Then I can see if it&apos;s what I<br/>want.</p><p>[46, -29, 0, 0, 0, 0]<br/>[-14, 0, -29, 29, 0, 0]<br/>[33, 0, 29, 0, -29, 0]<br/>[7, 0, 0, 0, 29, -29]</p><p>                     Graham</p></div><h3><a id=1474 href="#1474">ðŸ”—</a>genewardsmith@juno.com</h3><span>11/21/2001 3:06:36 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:</p><p>&gt; If Paul&apos;s conjecture is correct (and last time I mentioned it, you<br/>said<br/>&gt; you&apos;d proved it) you should always be able to get the generator and<br/>period<br/>&gt; for a complete, linearly independent set of chromatic and commatic<br/>unison<br/>&gt; vectors.</p><p>I certainly didn&apos;t mean to suggest I&apos;d proven your statement; I had<br/>to put conditions on to get a proof.</p><p>As I&apos;m having trouble getting this working, perhaps you could<br/>&gt; reduce this octave-specific basis for me.  Then I can see if it&apos;s<br/>what I<br/>&gt; want.<br/>&gt;<br/>&gt; [46, -29, 0, 0, 0, 0]<br/>&gt; [-14, 0, -29, 29, 0, 0]<br/>&gt; [33, 0, 29, 0, -29, 0]<br/>&gt; [7, 0, 0, 0, 29, -29]</p><p>Since I don&apos;t know what inner product you want, I made no adjustment,<br/>and got the following:</p><p>[-14, 0, -29, 29, 0, 0]<br/>[19, 0, 0, 29, -29, 0]<br/>[7, 0, 0, 0, 29, -29]<br/>[13, -29, -29, 0, 29, 0]</p></div><h3><a id=1476 href="#1476">ðŸ”—</a>graham@microtonal.co.uk</h3><span>11/21/2001 3:34:00 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>In-Reply-To: &lt;<a href="mailto:9tg1rs+ddom@eGroups.com">9tg1rs+ddom@eGroups.com</a>&gt;<br/>Me:<br/>&gt; As I&apos;m having trouble getting this working, perhaps you could<br/>&gt; &gt; reduce this octave-specific basis for me.  Then I can see if it&apos;s<br/>&gt; what I<br/>&gt; &gt; want.<br/>&gt; &gt;<br/>&gt; &gt; [46, -29, 0, 0, 0, 0]<br/>&gt; &gt; [-14, 0, -29, 29, 0, 0]<br/>&gt; &gt; [33, 0, 29, 0, -29, 0]<br/>&gt; &gt; [7, 0, 0, 0, 29, -29]</p><p>Gene:<br/>&gt; Since I don&apos;t know what inner product you want, I made no adjustment,<br/>&gt; and got the following:<br/>&gt;<br/>&gt; [-14, 0, -29, 29, 0, 0]<br/>&gt; [19, 0, 0, 29, -29, 0]<br/>&gt; [7, 0, 0, 0, 29, -29]<br/>&gt; [13, -29, -29, 0, 29, 0]</p><p>Oh dear.  I wanted something like this:</p><p>(2, -1, 2, -1, 0)<br/>(0, -3, 1, 1, 1)<br/>(-3, 1, -1, -1, 1)<br/>(-3, 0, 0, 1, -1)</p><p>So it looks like this off the shelf LLL algorithm isn&apos;t what I want at<br/>all.  Do you know of any way of doing that kind of reduction?  Or, more<br/>specifically, of getting a simple set of unison vectors for the consistent<br/>29+58 temperament?</p><p>mapping by period and generator:<br/>[(29, 0), (46, 0), (67, 1), (81, 1), (100, 1), (107, 1)]</p><p>mapping by steps:<br/>[(29, 0), (46, 0), (66, 1), (80, 1), (99, 1), (106, 1)]</p><p>             Graham</p></div><h3><a id=1481 href="#1481">ðŸ”—</a>genewardsmith@juno.com</h3><span>11/21/2001 3:11:00 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:<br/>&gt; Oh dear.  I wanted something like this:<br/>&gt;<br/>&gt; (2, -1, 2, -1, 0)<br/>&gt; (0, -3, 1, 1, 1)<br/>&gt; (-3, 1, -1, -1, 1)<br/>&gt; (-3, 0, 0, 1, -1)</p><p>I can certainly LLL reduce this, after adding in the 2s; I get<br/>&lt;196/195, 364/363, 441/440, 1575/1573&gt;</p><p>&gt; So it looks like this off the shelf LLL algorithm isn&apos;t what I want<br/>at<br/>&gt; all.  Do you know of any way of doing that kind of reduction?  Or,<br/>more<br/>&gt; specifically, of getting a simple set of unison vectors for the<br/>consistent<br/>&gt; 29+58 temperament?</p><p>The above does it; however you did most of the work, so I presume you<br/>must have some idea how to proceed. One can brute force it by first<br/>getting a 13-limit notation with a basis of about the right size,<br/>dual to a set of ets containing 29 and 58, and then searching for<br/>elements of the kernel of 29&amp;58--one should not need exponents beyond<br/>+-2, so a search would be feasible. If we find something of rank 4<br/>which can be extended to make a basis for the kernel of both 29 and<br/>58, we are ready to LLL reduce it. Since you did the above<br/>calculation, however, perhaps you have another idea.</p></div><h3><a id=1493 href="#1493">ðŸ”—</a>graham@microtonal.co.uk</h3><span>11/22/2001 4:08:00 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>In-Reply-To: &lt;<a href="mailto:9thca4+t6o3@eGroups.com">9thca4+t6o3@eGroups.com</a>&gt;<br/>Gene wrote:</p><p>&gt; The above does it; however you did most of the work, so I presume you<br/>&gt; must have some idea how to proceed.</p><p>It took me a lot of work to get the &quot;correct&quot; lattice.  I had to guess a<br/>transformation matrix that would allow me to divide through by a common<br/>factor of 29, and check that it worked in Mathcad.  And I wasn&apos;t following<br/>a deterministic process.  I had to think quite hard about how the unison<br/>vectors could be combined to get the 29s, and still be linearly<br/>independent.  I expect I could get a computer to do the same job, but that<br/>would mean alot more work, and I don&apos;t want to go reinventing any wheels.<br/>I&apos;m not that hung up on unison vectors anyway.  The program already does<br/>what I want it to.</p><p>&gt; One can brute force it by first<br/>&gt; getting a 13-limit notation with a basis of about the right size,<br/>&gt; dual to a set of ets containing 29 and 58, and then searching for<br/>&gt; elements of the kernel of 29&amp;58--one should not need exponents beyond<br/>&gt; +-2, so a search would be feasible. If we find something of rank 4<br/>&gt; which can be extended to make a basis for the kernel of both 29 and<br/>&gt; 58, we are ready to LLL reduce it. Since you did the above<br/>&gt; calculation, however, perhaps you have another idea.</p><p>Yes, brute force would give the right results, but I&apos;m not happy with it<br/>as a solution.  For the theory to be complete, we really need to prove<br/>that you can always find a set of simplified unison vectors, and that a<br/>particular algorithm will always produce them.  I think that&apos;d be harder<br/>for brute force.</p><p>This may even be more important than going from unison vectors to a<br/>temperament.  History shows that good temperaments don&apos;t get discovered by<br/>somebody sitting down and saying &quot;Hey, I wonder what would happen if I<br/>simplified all these intervals&quot;.  It&apos;s more likely that they&apos;ll hit on a<br/>good temperament, and then think about what simplifications it makes.</p><p>                              Graham</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            