<a href="/tuning-math">back to list</a><h1>hexaMu vs. heptaMu</h1><h3>pitchcolor &#x3C;pitchcolor@aol.com&#x3E;</h3><span>7/9/2003 1:50:14 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Here is the issue as I see it: does the number of bits specified<br/>by the unit name reflect the proper subdivision of the halfstep as<br/>well as the MIDI data format? My feeling is that it needs to do<br/>both. How do we accomplish this? Here&apos;s my answer:</p><p>The data format in the MIDI spec says 7 data bits. This is the<br/>conventional or standard way to interpret the data, and this is<br/>why I have been arguing for the prefix hepta rather than going<br/>with monz&apos;s hexa, etc. When you say hexaMu, you mean 6 bits<br/>per halfstep, which is correct; however, we are still talking about<br/>a byte which has 7 data bits, which has seemed to me reason<br/>enough to call it heptaMu. So which fact should the unit name<br/>reflect?</p><p>As monz said, MIDI specs state tuning matters in terms of a<br/>helfstep, so it makes sense to do the same here; however, this<br/>requires a reinterpretation of the data. A logical reinterpretation<br/>would resolve our disagreement over hexa versus hepta. The<br/>change makes sense to me, and this is how I think it should be<br/>stated:</p><p>&apos;Center detent&apos; data such as the data I have on my pitch bend<br/>page can also be seen as a form of _signed data. The 7 data<br/>bits can just as well be seen as 6 data bits with a least<br/>significant sign bit. 0 = below, 1 = above. Thus the 7 data bits<br/>become 6 data bits with a _sign _bit. I hope this is not<br/>something somene already pointed out and I just missed it. At<br/>any rate, an update to my webpage would contain all of this info<br/>in logical order, so that the data format is clear from both the<br/>conventional interpretation and this modified interpretation. This<br/>also means that the remark about signed data at the bottom of<br/>the page will become part of a larger description of signed data<br/>types. HeptaMu becomes hexaMu, end of story.</p><p>What do you think?</p><p>Aaron</p><p>P.S. here&apos;s the page again, (NOT updated yet):<br/><a href="http://members.aol.com/pitchcolor/ideas/pitchbend.html">http://members.aol.com/pitchcolor/ideas/pitchbend.html</a></p></div><h3>monz &#x3C;monz@attglobal.net&#x3E;</h3><span>7/10/2003 12:34:52 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>hi Aaron,</p><p>&gt; From: &quot;pitchcolor&quot; &lt;<a href="mailto:pitchcolor@aol.com">pitchcolor@aol.com</a>&gt;<br/>&gt; To: &lt;<a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>&gt;<br/>&gt; Sent: Wednesday, July 09, 2003 1:50 PM<br/>&gt; Subject: [tuning-math] hexaMu vs. heptaMu<br/>&gt;<br/>&gt;<br/>&gt; Here is the issue as I see it: does the number of bits specified<br/>&gt; by the unit name reflect the proper subdivision of the halfstep as<br/>&gt; well as the MIDI data format? My feeling is that it needs to do<br/>&gt; both. How do we accomplish this? Here&apos;s my answer:<br/>&gt;<br/>&gt;<br/>&gt; &lt;snip&gt;<br/>&gt;<br/>&gt; &apos;Center detent&apos; data such as the data I have on my pitch bend<br/>&gt; page can also be seen as a form of _signed data. The 7 data<br/>&gt; bits can just as well be seen as 6 data bits with a least<br/>&gt; significant sign bit.</p><p>no, actually, it&apos;s the *most* significant bit which<br/>acts as the sign flag.</p><p>as i explained here on Monday<br/><a href="http://groups.yahoo.com/group/tuning/message/45352">http://groups.yahoo.com/group/tuning/message/45352</a></p><p>&gt;&gt; the &quot;x&quot; represents the status flag at the<br/>&gt;&gt; beginning of the byte, and is not recognized<br/>&gt;&gt; as part of the tuning resolution.<br/>&gt;&gt;<br/>&gt;&gt;<br/>&gt;&gt;<br/>&gt;&gt; x 64 32 16 8 4 2 1 -- decimal value<br/>&gt;&gt; x  1  0  0 0 0 0 0 -- bits<br/>&gt;&gt;<br/>&gt;&gt; = 64 decimal = the plain MIDI-note,<br/>&gt;&gt; 0 cents deviation from 12edo.<br/>&gt;&gt;<br/>&gt;&gt;<br/>&gt;&gt;<br/>&gt;&gt; x 64 32 16 8 4 2 1 -- decimal value<br/>&gt;&gt; x  1  0  0 0 0 0 1 -- bits<br/>&gt;&gt;<br/>&gt;&gt; = 65 decimal = one unit (1.5625 cents)<br/>&gt;&gt; above the 12edo MIDI-note.<br/>&gt;&gt;<br/>&gt;&gt;<br/>&gt;&gt;<br/>&gt;&gt; x 64 32 16 8 4 2 1 -- decimal value<br/>&gt;&gt; x  0  1  1 1 1 1 1 -- bits<br/>&gt;&gt;<br/>&gt;&gt; = 63 decimal = one unit (1.5625 cents)<br/>&gt;&gt; below the 12edo MIDI-note.</p><p>&gt; 0 = below, 1 = above. Thus the 7 data bits<br/>&gt; become 6 data bits with a _sign _bit. I hope this is not<br/>&gt; something somene already pointed out and I just missed it.</p><p>i already revised my hexamu page a couple of days<br/>ago to say this.</p><p><a href="http://sonic-arts.org/dict/hexamu.htm">http://sonic-arts.org/dict/hexamu.htm</a></p><p>it&apos;s in the second paragraph quoted here:</p><p>&gt;&gt; &quot;However, as of 2003, almost all MIDI hardware, including<br/>&gt;&gt; both keyboards and other &quot;regular&quot; musical instruments<br/>&gt;&gt; and most computer soundcards, ignores the less significant<br/>&gt;&gt; byte of the two MIDI pitch-bend data bytes, thus limiting<br/>&gt;&gt; tuning resolution to only 7 bits.<br/>&gt;&gt;<br/>&gt;&gt; Because the pitch-bend protocol uses the most significant<br/>&gt;&gt; of these bits only to designate the frequency of the 12edo<br/>&gt;&gt; MIDI-note which lies as close as possible to the center<br/>&gt;&gt; of the pitch-bend range (namely, 1/2-unit above the exact<br/>&gt;&gt; center), in effect making this bit merely a flag which<br/>&gt;&gt; indicates the sign showing the direction of the pitch-bend,<br/>&gt;&gt; and because the smallest total pitch-bend range from this<br/>&gt;&gt; center is +/- 100 cents, the effective maximum resolution<br/>&gt;&gt; for all of this hardware is 6 bits per Semitone.</p><p>-monz</p></div><h3>pitchcolor &#x3C;pitchcolor@aol.com&#x3E;</h3><span>7/10/2003 11:31:13 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi monz,</p><p>&gt; &gt; The 7 data<br/>&gt; &gt; bits can just as well be seen as 6 data bits with a least<br/>&gt; &gt; significant sign bit.<br/>&gt;<br/>&gt;<br/>&gt; no, actually, it&apos;s the *most* significant bit which<br/>&gt; acts as the sign flag.</p><p>In any case, the interpretation is unorthodox. Usually a sign bit<br/>indicates that the 2s complement will be taken from the data<br/>bits, and that isn&apos;t what goes on here. This unusual &apos;sign&apos; bit isn&apos;t<br/>really a sign bit. Let&apos;s call it a &apos;flag&apos;. It means specifically:</p><p>0 = n - 1<br/>1 = n</p><p>where n is the given MIDI note number</p><p>The 6 data bits then indicate 64 versions of a MIDI note, either<br/>focused on n-1 or n according to the flag.</p><p>Now, this interpretation may cause some minor confusion in the<br/>relation of a MIDI note with a sample. No matter what the flag is,<br/>the sample is still taken from n. When the flag is 0, the sample is<br/>still taken from n, not from n-1.<br/>...<br/>&gt; i already revised my hexamu page a couple of days<br/>&gt; ago to say this.</p><p>Great! I sometimes can&apos;t keep up because I don&apos;t have web<br/>access from home - just email. I will be updating my page soon.<br/>Glad to see the work on 768 taking shape - this is useful info for<br/>all pitch bending MIDI users.</p><p>Aaron</p></div><h3>monz &#x3C;monz@attglobal.net&#x3E;</h3><span>7/10/2003 11:55:56 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>hi Aaron,</p><p>&gt; From: &quot;pitchcolor&quot; &lt;<a href="mailto:pitchcolor@aol.com">pitchcolor@aol.com</a>&gt;<br/>&gt; To: &lt;<a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>&gt;<br/>&gt; Sent: Thursday, July 10, 2003 11:31 AM<br/>&gt; Subject: [tuning-math] Re: hexaMu vs. heptaMu<br/>&gt;<br/>&gt;<br/>&gt; Hi monz,<br/>&gt;<br/>&gt; &gt; &gt; The 7 data<br/>&gt; &gt; &gt; bits can just as well be seen as 6 data bits<br/>&gt; &gt; &gt; with a least significant sign bit.<br/>&gt; &gt;<br/>&gt; &gt;<br/>&gt; &gt; no, actually, it&apos;s the *most* significant bit which<br/>&gt; &gt; acts as the sign flag.<br/>&gt;<br/>&gt; In any case, the interpretation is unorthodox.<br/>&gt; Usually a sign bit indicates that the 2s complement<br/>&gt; will be taken from the data bits, and that isn&apos;t<br/>&gt; what goes on here. This unusual &apos;sign&apos; bit isn&apos;t<br/>&gt; really a sign bit. Let&apos;s call it a &apos;flag&apos;. It<br/>&gt; means specifically:<br/>&gt;<br/>&gt; 0 = n - 1<br/>&gt; 1 = n<br/>&gt;<br/>&gt; where n is the given MIDI note number<br/>&gt;<br/>&gt; The 6 data bits then indicate 64 versions of a MIDI note, either<br/>&gt; focused on n-1 or n according to the flag.<br/>&gt;<br/>&gt; Now, this interpretation may cause some minor<br/>&gt; confusion in the relation of a MIDI note with<br/>&gt; a sample. No matter what the flag is, the sample<br/>&gt; is still taken from n. When the flag is 0, the<br/>&gt; sample is still taken from n, not from n-1.</p><p>i agree with what you say, and in fact that bit<br/>doesn&apos;t *really* indicate sign, since the values<br/>which are less than &quot;n&quot; (the 12edo MIDI-note)<br/>are not measured downward from n (i.e., using<br/>negative numbers), but rather as you say, upward<br/>from &quot;n-1&quot;.</p><p>but in practice it might still be easier to<br/>think of it as a sign bit, and in fact, in the<br/>dodekamu implementation in Cakewalk and numerous<br/>other software sequencers, it does actually work<br/>that way.  the user actually has a choice to render<br/>a note with pitch-bend either by using negative<br/>values for the pitch-bend data or by keeping track<br/>of the MIDI-notes by assigning them mentally to<br/>8192 dodekamus above the MIDI-note specified as &quot;0&quot;.</p><p>i&apos;ve seen it done both ways, but of course the<br/>method using negative numbers works better because<br/>the score shows the MIDI-note that&apos;s closest to<br/>the target microtonal note, which is what one<br/>expects to see.</p><p>-monz</p></div>