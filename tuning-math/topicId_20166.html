<a href="/tuning-math">back to list</a><h1>Searching for the best val for a mapping</h1><h3>Mike Battaglia &#x3C;battaglia01@gmail.com&#x3E;</h3><span>1/11/2012 12:28:05 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Is the best way to do this to just do a brute force search of all vals<br/>that lie at most some number of alterations away from the patent val?</p><p>For example, if I&apos;m looking for the best val in the 2.3.5 subgroup for<br/>11-EDO, I&apos;d set some cutoff for the number of alterations (let&apos;s say<br/>at 2) and then look at 11p, 11b, 11c, 11bc, 11bb, 11cc, 11bbc, 11bcc,<br/>and 11bbcc, and pick the best?</p><p>Or is there some more elegant way I don&apos;t know of?</p><p>-Mike</p></div><h3>Carl Lumma &#x3C;carl@lumma.org&#x3E;</h3><span>1/11/2012 12:44:30 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Mike wrote:</p><p>&gt;Is the best way to do this to just do a brute force search of all vals<br/>&gt;that lie at most some number of alterations away from the patent val?</p><p>I found that testing the patent vals based on octaves<br/>+/-0.5 cents from pure essentially never misses the best val.<br/>In fact it beats a monte carlo sampling of val space near the<br/>patent val until you do a truly ridiculous number of trials.<br/>And that&apos;s only with the octaves in 0.1 cent steps.  You can<br/>use 0.01 cent resolution and you&apos;ll definitely get the goose<br/>with only 50 tests.  The reason this works, at least in the<br/>case of TOP damage, is no doubt due to the existence of TOP-FP<br/>octaves.</p><p>Graham has a method proven to find the best val within given<br/>error bounds.  See his source code.</p><p>-Carl</p></div><h3>gbreed@gmail.com</h3><span>1/11/2012 12:49:59 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>That&apos;s a simple way but not an efficient one. It has exponential complexity.<br/>What I do is predict the range of mappings for each prime recursively given the mappings of smaller primes. That converges faster on good mappings if you set a strict target. It&apos;s all in the code.</p><p>        Graham</p><p>------Original message------<br/>From: Mike Battaglia &lt;<a href="mailto:battaglia01@gmail.com">battaglia01@gmail.com</a>&gt;<br/>To: &lt;<a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>&gt;<br/>Date: Wednesday, January 11, 2012 3:28:05 PM GMT-0500<br/>Subject: [tuning-math] Searching for the best val for a mapping</p><p>Is the best way to do this to just do a brute force search of all vals<br/>that lie at most some number of alterations away from the patent val?</p><p>For example, if I&apos;m looking for the best val in the 2.3.5 subgroup for<br/>11-EDO, I&apos;d set some cutoff for the number of alterations (let&apos;s say<br/>at 2) and then look at 11p, 11b, 11c, 11bc, 11bb, 11cc, 11bbc, 11bcc,<br/>and 11bbcc, and pick the best?</p><p>Or is there some more elegant way I don&apos;t know of?</p><p>-Mike</p><p>------------------------------------</p><p>Yahoo! Groups Links</p></div><h3>Carl Lumma &#x3C;carl@lumma.org&#x3E;</h3><span>1/11/2012 12:55:23 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>My method has O(1) complexity.  You can&apos;t beat that!<br/>I can&apos;t guarantee it&apos;ll work for TE error like it does<br/>for TOP, but I think it&apos;s highly likely.</p><p>-Carl</p><p>At 12:49 PM 1/11/2012, you wrote:<br/>&gt;Content-Transfer-Encoding: 7bit<br/>&gt;<br/>&gt;That&apos;s a simple way but not an efficient one. It has exponential complexity.<br/>&gt;What I do is predict the range of mappings for each prime recursively<br/>&gt;given the mappings of smaller primes. That converges faster on good<br/>&gt;mappings if you set a strict target. It&apos;s all in the code.<br/>&gt;<br/>&gt;        Graham<br/>&gt;<br/>&gt;------Original message------<br/>&gt;From: Mike Battaglia &lt;<a href="mailto:battaglia01@gmail.com">battaglia01@gmail.com</a>&gt;<br/>&gt;To: &lt;<a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>&gt;<br/>&gt;Date: Wednesday, January 11, 2012 3:28:05 PM GMT-0500<br/>&gt;Subject: [tuning-math] Searching for the best val for a mapping<br/>&gt;<br/>&gt;Is the best way to do this to just do a brute force search of all vals<br/>&gt;that lie at most some number of alterations away from the patent val?<br/>&gt;<br/>&gt;For example, if I&apos;m looking for the best val in the 2.3.5 subgroup for<br/>&gt;11-EDO, I&apos;d set some cutoff for the number of alterations (let&apos;s say<br/>&gt;at 2) and then look at 11p, 11b, 11c, 11bc, 11bb, 11cc, 11bbc, 11bcc,<br/>&gt;and 11bbcc, and pick the best?<br/>&gt;<br/>&gt;Or is there some more elegant way I don&apos;t know of?<br/>&gt;<br/>&gt;-Mike<br/>&gt;</p></div><h3>Mike Battaglia &#x3C;battaglia01@gmail.com&#x3E;</h3><span>1/11/2012 2:07:18 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>But will it work out for ridiculous wacked out subgroups?</p><p>Sent from my iPhone</p><p>On Jan 11, 2012, at 3:55 PM, Carl Lumma &lt;<a href="mailto:carl@lumma.org">carl@lumma.org</a>&gt; wrote:</p><p>My method has O(1) complexity. You can&apos;t beat that!<br/>I can&apos;t guarantee it&apos;ll work for TE error like it does<br/>for TOP, but I think it&apos;s highly likely.</p><p>-Carl</p><p>At 12:49 PM 1/11/2012, you wrote:<br/>&gt;Content-Transfer-Encoding: 7bit<br/>&gt;<br/>&gt;That&apos;s a simple way but not an efficient one. It has exponential<br/>complexity.<br/>&gt;What I do is predict the range of mappings for each prime recursively<br/>&gt;given the mappings of smaller primes. That converges faster on good<br/>&gt;mappings if you set a strict target. It&apos;s all in the code.<br/>&gt;<br/>&gt; Graham<br/>&gt;<br/>&gt;------Original message------<br/>&gt;From: Mike Battaglia &lt;<a href="mailto:battaglia01@gmail.com">battaglia01@gmail.com</a>&gt;<br/>&gt;To: &lt;<a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>&gt;<br/>&gt;Date: Wednesday, January 11, 2012 3:28:05 PM GMT-0500<br/>&gt;Subject: [tuning-math] Searching for the best val for a mapping<br/>&gt;<br/>&gt;Is the best way to do this to just do a brute force search of all vals<br/>&gt;that lie at most some number of alterations away from the patent val?<br/>&gt;<br/>&gt;For example, if I&apos;m looking for the best val in the 2.3.5 subgroup for<br/>&gt;11-EDO, I&apos;d set some cutoff for the number of alterations (let&apos;s say<br/>&gt;at 2) and then look at 11p, 11b, 11c, 11bc, 11bb, 11cc, 11bbc, 11bcc,<br/>&gt;and 11bbcc, and pick the best?<br/>&gt;<br/>&gt;Or is there some more elegant way I don&apos;t know of?<br/>&gt;<br/>&gt;-Mike<br/>&gt;</p></div><h3>Carl Lumma &#x3C;carl@lumma.org&#x3E;</h3><span>1/11/2012 2:24:57 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>At 02:07 PM 1/11/2012, Mike wrote:</p><p>&gt;But will it work out for ridiculous wacked out subgroups?</p><p>Should do.  You can always compare it to Graham&apos;s method<br/>and see what happens.  -C.</p><p>&gt;On Jan 11, 2012, at 3:55 PM, Carl Lumma &lt;&lt;<a href="mailto:carl@lumma.org">mailto:carl@lumma.org</a>&gt;<a href="mailto:carl@lumma.org">carl@lumma.org</a>&gt; wrote:<br/>&gt;<br/>&gt;&gt;<br/>&gt;&gt;My method has O(1) complexity. You can&apos;t beat that!<br/>&gt;&gt;I can&apos;t guarantee it&apos;ll work for TE error like it does<br/>&gt;&gt;for TOP, but I think it&apos;s highly likely.<br/>&gt;&gt;<br/>&gt;&gt;-Carl</p></div><h3>gbreed@gmail.com</h3><span>1/11/2012 11:28:59 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>It&apos;s at least linear time because you have to loop through the primes. It may be that you have to increase the resolution as you add more primes and complexity gets hidden that way.</p><p>        Graham</p><p>------Original message------<br/>From: Carl Lumma &lt;<a href="mailto:carl@lumma.org">carl@lumma.org</a>&gt;<br/>To: &lt;<a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>&gt;<br/>Date: Wednesday, January 11, 2012 12:55:23 PM GMT-0800<br/>Subject: Re: [tuning-math] Searching for the best val for a mapping</p><p>My method has O(1) complexity.  You can&apos;t beat that!<br/>I can&apos;t guarantee it&apos;ll work for TE error like it does<br/>for TOP, but I think it&apos;s highly likely.</p><p>-Carl</p><p>At 12:49 PM 1/11/2012, you wrote:<br/>&gt;Content-Transfer-Encoding: 7bit<br/>&gt;<br/>&gt;That&apos;s a simple way but not an efficient one. It has exponential complexity.<br/>&gt;What I do is predict the range of mappings for each prime recursively<br/>&gt;given the mappings of smaller primes. That converges faster on good<br/>&gt;mappings if you set a strict target. It&apos;s all in the code.<br/>&gt;<br/>&gt;        Graham<br/>&gt;<br/>&gt;------Original message------<br/>&gt;From: Mike Battaglia &lt;<a href="mailto:battaglia01@gmail.com">battaglia01@gmail.com</a>&gt;<br/>&gt;To: &lt;<a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>&gt;<br/>&gt;Date: Wednesday, January 11, 2012 3:28:05 PM GMT-0500<br/>&gt;Subject: [tuning-math] Searching for the best val for a mapping<br/>&gt;<br/>&gt;Is the best way to do this to just do a brute force search of all vals<br/>&gt;that lie at most some number of alterations away from the patent val?<br/>&gt;<br/>&gt;For example, if I&apos;m looking for the best val in the 2.3.5 subgroup for<br/>&gt;11-EDO, I&apos;d set some cutoff for the number of alterations (let&apos;s say<br/>&gt;at 2) and then look at 11p, 11b, 11c, 11bc, 11bb, 11cc, 11bbc, 11bcc,<br/>&gt;and 11bbcc, and pick the best?<br/>&gt;<br/>&gt;Or is there some more elegant way I don&apos;t know of?<br/>&gt;<br/>&gt;-Mike<br/>&gt;</p><p>------------------------------------</p><p>Yahoo! Groups Links</p></div><h3>Carl Lumma &#x3C;carl@lumma.org&#x3E;</h3><span>1/11/2012 11:59:50 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I assumed we were thinking of the scaling with ET number... -C.</p><p>At 11:28 PM 1/11/2012, you wrote:<br/>&gt;Content-Transfer-Encoding: 7bit<br/>&gt;<br/>&gt;It&apos;s at least linear time because you have to loop through the primes.<br/>&gt;It may be that you have to increase the resolution as you add more<br/>&gt;primes and complexity gets hidden that way.<br/>&gt;<br/>&gt;        Graham</p></div>