<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math LLL in Python</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>LLL in Python</h1><h3><a id=19679 href="#19679">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>10/4/2011 3:28:45 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I&apos;ve been checking my LLL routine.  It&apos;s already live on my<br/>website to simplify the unison vectors.  The previous<br/>algorithm (na&iuml;ve Tenney reduction) was failing to find<br/>simple things like 100:99 for 13-limit magic.  The<br/>vectors/ratios you see now are the simplest ones within 3<br/>lattice points of the LLL reduced set.</p><p>Now, there are various problems with LLL as a standard form<br/>for generators or unison vectors.  There&apos;s a free parameter<br/>that controls the strictness of the results, and<br/>implementations tend not to document what value they use.<br/>Because of this, different definitions of it can disagree.<br/>Even when they should agree, trivial implementation details<br/>can affect the results because the output isn&apos;t strictly<br/>defined.</p><p>What I&apos;ve done is to follow the algorithm as defined in the<br/>&quot;Modern Computer Algebra&quot; book I own.  I&apos;ve tested it with<br/>the two examples in the book.  I know that these examples<br/>disagree with Pari/GP but I don&apos;t know what variant of the<br/>algorithm they implemented.  I know that Wikipedia is<br/>describing a different variant and the example (which<br/>happens to use exactly the same input as my book) is wrong,<br/>but given that I don&apos;t really understand the example I<br/>don&apos;t know how to correct it.</p><p>I also know that the 3x3 example in &quot;Modern Computer<br/>Algebra&quot; doesn&apos;t follow the algorithm they described.  It<br/>comes down to whether halves should round up or down.  They<br/>strictly defined the rounding, and &half; should most definitely<br/>round up.  That&apos;s good, because halves rounding up is the<br/>easiest thing to implement in Python.  According to the<br/>example, though, &half; rounds down.  I don&apos;t know why. I&apos;ve<br/>fudged it so that halves always round down. They&apos;re<br/>probably doing something cleverer, like the bankers&apos;<br/>rounding used by default in IEEE 754:</p><p><a href="http://en.wikipedia.org/wiki/Bankers%27_rounding#Round_half_to_even">http://en.wikipedia.org/wiki/Bankers%27_rounding#Round_half_to_even</a></p><p>Maybe they didn&apos;t realize the floating point library they<br/>were using was implemented differently to how they<br/>described.  It does matter in that you get different<br/>results for different rounding rules.  It probably doesn&apos;t<br/>matter in that all the alternatives will fulfill the<br/>promises the LLL algorithm gives you.</p><p>I would paste the code here, but my email client completely<br/>screws up the line wrapping.  You can find it in the file<br/><a href="http://regutils.py">regutils.py</a> in the bundle<br/><a href="http://x31eq.com/temper/regular.zip">http://x31eq.com/temper/regular.zip</a></p><p>It works for inner products that correspond to different<br/>weightings of the Euclidean axes.  It doesn&apos;t work for<br/>inner products that are more generalized than that, so it&apos;s<br/>no good for minimizing Cangwu badness.  If you&apos;re using a<br/>library that doesn&apos;t allow you to specify the inner<br/>product, you can still get Tenney-weighted LLL to work by<br/>weighting the vectors before you feed them in and reversing<br/>the process on any vectors that come out.</p><p>                      Graham</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            