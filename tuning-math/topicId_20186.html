<a href="/tuning-math">back to list</a><h1>Extracting from some set of target intervals those consistent with a subgroup</h1><h3><a id=20186 href="#20186">ðŸ”—</a>Mike Battaglia &#x3C;battaglia01@gmail.com&#x3E;</h3><span>1/16/2012 1:38:33 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I&apos;m trying to find an elegant way to find the intersection of some<br/>subgroup with some set of target intervals in the parent group. For<br/>example, let&apos;s say I want to find the intersection of the 15-odd-limit<br/>tonality diamond with the 2.9.11/7.15 subgroup. What&apos;s the easiest way<br/>to do so?</p><p>The above situation specifically is rather easy, but for an arbitrary<br/>subgroup and an arbitrary set of target intervals it might not be. I&apos;d<br/>rather code something up that lets me find the intersection of an<br/>arbitrary subgroup with an arbitrary set of target intervals.</p><p>I had a few ideas about how to do this:</p><p>1) Build a projection matrix that zeros out components that aren&apos;t in<br/>my subgroup, multiply all my target monzos by that, and prune for<br/>duplicates. But I&apos;d also like to express the monzos in the new<br/>subgroup basis, which is where I&apos;m running into trouble.<br/>2) Treat the shift to a new subgroup as the same thing as a change of<br/>basis. Keenan suggested using Gram-Schmidt Orthogonalization as a way<br/>to &quot;complete&quot; the subgroup basis within the original limit; I&apos;ll call<br/>these &quot;junk vectors.&quot; Then, if I get any junk vector components when I<br/>shift the basis, I&apos;ll know the target interval isn&apos;t in the subgroup I<br/>want. (Some finessing of this approach is required for subgroup bases<br/>like <a href="http://2.9.7.11">2.9.7.11</a>, but it&apos;s trivial and not worth talking about.)</p><p>#1 makes me happy in some kind of OCD way, but #2 is probably simpler.<br/>The problem is that MATLAB doesn&apos;t have Gram-Schmidt<br/>Orthogonalization, and I don&apos;t have the time to implement a routine<br/>for it now. What I really need is the simplest way to get a set of<br/>junk vectors that are linearly independent from my subgroup basis<br/>vectors, expressed in the original basis. I know how to implement this<br/>in NP time (try combinations of primes and check to see if the<br/>determinant of the matrix is nonzero), but this is pretty slow<br/>especially given all the overhead MATLAB throws onto things.</p><p>Does anyone know a quick algorithm to get a complementary set of<br/>vectors, which is linearly independent from a set of other vectors, in<br/>a way that the union of the two sets spans the entire vector space?</p><p>I also remember Graham had some way to do this too, involving writing<br/>a matrix that expresses the subgroup in the original basis, and going<br/>from there.</p><p>-Mike</p></div><h3><a id=20187 href="#20187">ðŸ”—</a>Mike Battaglia &#x3C;battaglia01@gmail.com&#x3E;</h3><span>1/16/2012 2:07:25 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>The term for what I&apos;m looking for is apparently &quot;complementary subspace.&quot;</p><p>Any subgroup has a corresponding &quot;full-limit,&quot; defined as the group of<br/>all primes up to the largest prime factor in the subspace. The<br/>subgroup spans a subspace of this group.</p><p>What would be of great help to me is to find the quickest way to find<br/>the complementary subspace of this space, and then get a set of basis<br/>vectors for it. I feel like it&apos;s related to the null space of the<br/>matrix which represents the new partial basis in terms of the old one,<br/>but I&apos;m not sure what the exact connection is.</p><p>I don&apos;t have Gram-Schmidt orthogonalization in MATLAB, but I have QR<br/>decomposition; maybe that&apos;ll be of some help?</p><p>-Mike</p><p>On Mon, Jan 16, 2012 at 4:38 PM, Mike Battaglia &lt;<a href="mailto:battaglia01@gmail.com">battaglia01@gmail.com</a>&gt; wrote:<br/>&gt; I&apos;m trying to find an elegant way to find the intersection of some<br/>&gt; subgroup with some set of target intervals in the parent group. For<br/>&gt; example, let&apos;s say I want to find the intersection of the 15-odd-limit<br/>&gt; tonality diamond with the 2.9.11/7.15 subgroup. What&apos;s the easiest way<br/>&gt; to do so?<br/>&gt;<br/>&gt; The above situation specifically is rather easy, but for an arbitrary<br/>&gt; subgroup and an arbitrary set of target intervals it might not be. I&apos;d<br/>&gt; rather code something up that lets me find the intersection of an<br/>&gt; arbitrary subgroup with an arbitrary set of target intervals.<br/>&gt;<br/>&gt; I had a few ideas about how to do this:<br/>&gt;<br/>&gt; 1) Build a projection matrix that zeros out components that aren&apos;t in<br/>&gt; my subgroup, multiply all my target monzos by that, and prune for<br/>&gt; duplicates. But I&apos;d also like to express the monzos in the new<br/>&gt; subgroup basis, which is where I&apos;m running into trouble.<br/>&gt; 2) Treat the shift to a new subgroup as the same thing as a change of<br/>&gt; basis. Keenan suggested using Gram-Schmidt Orthogonalization as a way<br/>&gt; to &quot;complete&quot; the subgroup basis within the original limit; I&apos;ll call<br/>&gt; these &quot;junk vectors.&quot; Then, if I get any junk vector components when I<br/>&gt; shift the basis, I&apos;ll know the target interval isn&apos;t in the subgroup I<br/>&gt; want. (Some finessing of this approach is required for subgroup bases<br/>&gt; like <a href="http://2.9.7.11">2.9.7.11</a>, but it&apos;s trivial and not worth talking about.)<br/>&gt;<br/>&gt; #1 makes me happy in some kind of OCD way, but #2 is probably simpler.<br/>&gt; The problem is that MATLAB doesn&apos;t have Gram-Schmidt<br/>&gt; Orthogonalization, and I don&apos;t have the time to implement a routine<br/>&gt; for it now. What I really need is the simplest way to get a set of<br/>&gt; junk vectors that are linearly independent from my subgroup basis<br/>&gt; vectors, expressed in the original basis. I know how to implement this<br/>&gt; in NP time (try combinations of primes and check to see if the<br/>&gt; determinant of the matrix is nonzero), but this is pretty slow<br/>&gt; especially given all the overhead MATLAB throws onto things.<br/>&gt;<br/>&gt; Does anyone know a quick algorithm to get a complementary set of<br/>&gt; vectors, which is linearly independent from a set of other vectors, in<br/>&gt; a way that the union of the two sets spans the entire vector space?<br/>&gt;<br/>&gt; I also remember Graham had some way to do this too, involving writing<br/>&gt; a matrix that expresses the subgroup in the original basis, and going<br/>&gt; from there.<br/>&gt;<br/>&gt; -Mike</p></div><h3><a id=20188 href="#20188">ðŸ”—</a>Keenan Pepper &#x3C;keenanpepper@gmail.com&#x3E;</h3><span>1/16/2012 4:56:56 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Mike Battaglia &lt;battaglia01@...&gt; wrote:<br/>&gt;<br/>&gt; The term for what I&apos;m looking for is apparently &quot;complementary subspace.&quot;<br/>&gt;<br/>&gt; Any subgroup has a corresponding &quot;full-limit,&quot; defined as the group of<br/>&gt; all primes up to the largest prime factor in the subspace. The<br/>&gt; subgroup spans a subspace of this group.<br/>&gt;<br/>&gt; What would be of great help to me is to find the quickest way to find<br/>&gt; the complementary subspace of this space, and then get a set of basis<br/>&gt; vectors for it. I feel like it&apos;s related to the null space of the<br/>&gt; matrix which represents the new partial basis in terms of the old one,<br/>&gt; but I&apos;m not sure what the exact connection is.<br/>&gt;<br/>&gt; I don&apos;t have Gram-Schmidt orthogonalization in MATLAB, but I have QR<br/>&gt; decomposition; maybe that&apos;ll be of some help?</p><p>QR actually generalizes Gram-Schmidt. Anything you can do with Gram-Schmidt you can do with QR just as well.</p><p>Let A be the non-square matrix whose columns are the monzos of the subgroup generators.</p><p>octave:1&gt; A = [[1;0;0;0;0] [0;2;0;0;0] [0;0;0;-1;1] [0;1;1;0;0]]<br/>A =</p><p>   1   0   0   0<br/>   0   2   0   1<br/>   0   0   0   1<br/>   0   0  -1   0<br/>   0   0   1   0</p><p>Now we do QR decomposition of A.</p><p>octave:2&gt; [Q,R,S] = qr(A);<br/>octave:3&gt; Q<br/>Q =</p><p>   0.00000   0.00000   0.00000   1.00000   0.00000<br/>  -1.00000   0.00000   0.00000   0.00000   0.00000<br/>  -0.00000  -0.00000   1.00000   0.00000   0.00000<br/>  -0.00000   0.70711   0.00000  -0.00000   0.70711<br/>  -0.00000  -0.70711  -0.00000   0.00000   0.70711</p><p>A has 4 columns, meaning the subgroup has dimension 4. Therefore, the first 4 columns of Q are a basis for the subgroup. (They&apos;re actually just the normalized columns of A, in a different permutation.) The rest of the columns of Q are the &quot;junk monzos&quot; that you want.</p><p>So, if you want a change-of-basis matrix, here&apos;s what you do:</p><p>octave:4&gt; [A Q(:,5:5)]<br/>ans =</p><p>   1.00000   0.00000   0.00000   0.00000   0.00000<br/>   0.00000   2.00000   0.00000   1.00000   0.00000<br/>   0.00000   0.00000   0.00000   1.00000   0.00000<br/>   0.00000   0.00000  -1.00000   0.00000   0.70711<br/>   0.00000   0.00000   1.00000   0.00000   0.70711</p><p>This matrix is guaranteed to have full rank, with the first columns of it being A and the rest spanning a complementary subspace.</p><p>Let&apos;s do another example: 2.7/5.11/5</p><p>octave:1&gt; A = [[1;0;0;0;0] [0;0;-1;1;0] [0;0;-1;0;1]];<br/>octave:2&gt; [Q,R,S] = qr(A);<br/>octave:3&gt; Q<br/>Q =</p><p>   0.00000   0.00000  -1.00000   0.00000   0.00000<br/>  -0.00000   0.00000   0.00000   0.57735  -0.81650<br/>   0.70711   0.40825   0.00000   0.47140   0.33333<br/>  -0.70711   0.40825   0.00000   0.47140   0.33333<br/>  -0.00000  -0.81650  -0.00000   0.47140   0.33333</p><p>octave:4&gt; [A Q(:,4:5)]<br/>ans =</p><p>   1.00000   0.00000   0.00000   0.00000   0.00000<br/>   0.00000   0.00000   0.00000   0.57735  -0.81650<br/>   0.00000  -1.00000  -1.00000   0.47140   0.33333<br/>   0.00000   1.00000   0.00000   0.47140   0.33333<br/>   0.00000   0.00000   1.00000   0.47140   0.33333</p><p>In this case the last 2 columns of this matrix span the 2D complementary subspace. They are guaranteed to be orthogonal to all the columns of A and to each other, which avoids numerical instability.</p><p>The only serious drawback to this method is that all the math is floating point rather than integer, and you can&apos;t fix that with just QR. Maybe Gene has some analog to QR for integer matrices.</p><p>RREF is to Hermite normal form as QR decomposition is to ___?</p><p>Keenan</p></div><h3><a id=20190 href="#20190">ðŸ”—</a>genewardsmith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>1/16/2012 7:13:27 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, &quot;Keenan Pepper&quot; &lt;keenanpepper@...&gt; wrote:</p><p>&gt; The only serious drawback to this method is that all the math is floating point rather than integer, and you can&apos;t fix that with just QR. Maybe Gene has some analog to QR for integer matrices.</p><p>You might try our old friend from the saturation problem, the right reducing matrix for Smith normal form.</p></div>