<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math As promised, some Python code for continued fraction convergents</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>As promised, some Python code for continued fraction convergents</h1><h3><a id=14958 href="#14958">ðŸ”—</a>Aaron Krister Johnson &#x3C;aaron@akjmusic.com&#x3E;</h3><span>5/30/2006 5:39:26 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;     From: &quot;Gene Ward Smith&quot; <a href="mailto:genewardsmith@coolgoose.com">genewardsmith@coolgoose.com</a><br/>&gt;     Date: Sat May 27, 2006 10:46am(PDT)<br/>&gt; Subject: Re: best rational approximation<br/>&gt;<br/>&gt; Gene wrote:<br/>&gt;<br/>&gt; If you have some x, call it x0. Then set n0 = floor(x0), and<br/>&gt; x1 = 1/(x0-n0). Iterate this, n_i = floor(x_i), and<br/>&gt; x_(i+1) = 1/(x_i-n_i). You then get a sequence of positive integers<br/>&gt; &lt;n0, n1, n2, ...&gt; which is the continued fraction for x; for every<br/>&gt; irrational x, there is a *unique* continued fraction, which is pretty<br/>&gt; neat.<br/>&gt;<br/>&gt; Now set h[-2] = 0, h[-1] = 1, h[i] = n_i h[i-1] + h[i-2], and similarly<br/>&gt; k[-2] = 1, k[-1] = 0, k[i] = n_i k[i-1] + k[i-2].  Then Q[i] = h[i]/k[i]<br/>&gt; is the ith continued fraction approximate for x, starting from i=0.</p><p>I&apos;m posting this to the normal tuning groups as well as tuning-math, because I<br/>think it should be dymystified, and it&apos;s quite fun and useful!</p><p>Hopefully, you will understand what Gene wrote above in a very concrete way by<br/>the time you are done reading this...</p><p>This is cool...I figured out that on a calculator with a &apos;1/x&apos; button, to get<br/>the &lt;n0,n1,n2,....&gt; sequence for the simple continued fraction of x, you:<br/>&#x9;<br/>&#x9;1. Write down the integer part of x (floor(x))<br/>&#x9;2. Take the integer part of x away from x (x-floor(x))<br/>&#x9;3. you now have a number between 0 and 1. Take its&apos; inverse<br/>&#x9;&#x9;(i.e. &apos;1/x&apos; on the calculator)<br/>&#x9;4. Goto step &apos;1&apos; and repeat as long as desired...</p><p>The caveat is that a calculator, and most computer situations actually, have<br/>limited decimal point precision. So for instance, the continued fraction<br/>expansion for sqrt(2) should be &lt;1,2,2,2,2,2,2,2,2,2,......&gt;, however, once<br/>the precision runs out on a calculator, you will see that chain of &apos;2&apos;s gets<br/>disrupted......</p><p>Here are some meantone fifths that I figured out by hand with a calculator<br/>using Gene&apos;s algorithm; some Python code do do this &apos;automagically&apos; follows<br/>below. To understand how I got the convergents&apos; numerators and denominators,<br/>take the current continued fraction expansion number, multiply it by the<br/>previous numerator (or denominator) and add the previous-previous numerator<br/>(or denominator).....for example, below, where the top row says &apos;39&apos;, we do<br/>&#x9;(39*3)+1=118<br/>        (39*2)+1=79<br/>..which gives us the next convergent, 118/79.</p><p>1/3-comma fifth:</p><p>    1  2  39    1   ;;;; the cont. fraction expans of 1.49380158....</p><p>0 1 1  3 118  121   ;;;; the convergents (numerators)<br/>- - -  - ---  ---<br/>1 0 1  2  79   81   ;;;; the convergents (denoominators)</p><p>2/7-comma fifth:</p><p>    1  2   46    1</p><p>0 1 1  3  139  142<br/>- - -  -  ---  ---<br/>1 0 1  2   93   95</p><p>1/4-comma fifth:</p><p>    1  2  53    4</p><p>0 1 1  3 160  643<br/>- - -  - ---  ---<br/>1 0 1  2 107  430</p><p>1/5-comma fifth:</p><p>    1  2   66    1</p><p>0 1 1  3  199  202<br/>- - -  -  ---  ---<br/>1 0 1  2  133  135</p><p>1/6-comma fifth:</p><p>    1  2   80    12</p><p>0 1 1  3  241  2895<br/>- - -  -  ---  ----<br/>1 0 1  2  161  1934</p><p>1/7-comma fifth:</p><p>    1  2  93    2</p><p>0 1 1  3 280  563<br/>- - -  - ---  ---<br/>1 0 1  2 187  376</p><p>1/8-comma fifth:</p><p>    1   2  106    1</p><p>0 1 1   3  319  322<br/>- - -   -  ---  ---<br/>1 0 1   2  213  215</p><p>etc, etc........</p><p>here&apos;s some python code, to be put in a library.<br/>I call my own math functions library &apos;math_stuff.py&apos;</p><p>from math import sqrt, log, floor</p><p>def contfrac(a): ### continued fraction expansion<br/>        terms=[]<br/>        count=0<br/>        b=1<br/>        while ((b != 0) and (count &lt; 24)): ### 24 times, emprical accuracy<br/>                                           ### limit<br/>                terms.append(floor(a/(b+0.0)))<br/>                a,b = b, a % b<br/>                count = count + 1<br/>        return terms</p><p>def ra(x): ### &apos;rational approximation&apos;, or convergent<br/>        numerators=[0,1]<br/>        denominators=[1,0]<br/>        expansion=contfrac(x) ### call the contfrac function<br/>        for num in expansion: ### [-1] and [-2] index &apos;previous&apos;<br/>                              ### and &apos;previous-previous&apos;<br/>                numerators.append((num*numerators[-1])+numerators[-2])<br/>                denominators.append((num*denominators[-1])+denominators[-2])<br/>        for index in range(len(numerators)):<br/>                print &quot;%i/%i&quot; % (numerators[index], denominators[index])<br/>        print</p><p>Here&apos;s an example of a shell session where I approximated the sqrt(2) with<br/>rationals:</p><p>akj@aaron:~$ python<br/>Python 2.4.1 (#1, Apr 10 2005, 22:30:36)<br/>[GCC 3.3.5] on linux2<br/>Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.<br/>&gt;&gt;&gt; from math_stuff import *<br/>&gt;&gt;&gt; ra(sqrt(2))<br/>0/1<br/>1/0<br/>1/1<br/>3/2<br/>7/5<br/>17/12<br/>41/29<br/>99/70<br/>239/169<br/>577/408<br/>1393/985<br/>3363/2378<br/>8119/5741<br/>19601/13860<br/>47321/33461<br/>114243/80782<br/>275807/195025<br/>665857/470832<br/>1607521/1136689<br/>3880899/2744210<br/>9369319/6625109<br/>22619537/15994428<br/>54608393/38613965<br/>77227930/54608393<br/>131836323/93222358<br/>209064253/147830751</p><p>&gt;&gt;&gt; 209064253/147830751.0<br/>1.4142135623730951<br/>&gt;&gt;&gt; sqrt(2)<br/>1.4142135623730951 #### they match!!!<br/>&gt;&gt;&gt;</p><p>Notice the use of the &apos;.0&apos; in Python, to tell the interpreter you want a<br/>floating point answer.</p><p>Hope this was enlightening!</p><p>Best,<br/>Aaron.</p></div><h3><a id=14961 href="#14961">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>5/30/2006 4:05:45 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;Here&apos;s an example of a shell session where I approximated the sqrt(2)<br/>&gt;with rationals:<br/>//<br/>&gt;0/1<br/>&gt;1/0<br/>&gt;1/1<br/>&gt;3/2<br/>&gt;7/5<br/>&gt;17/12<br/>&gt;41/29<br/>&gt;99/70<br/>&gt;239/169<br/>&gt;577/408<br/>&gt;1393/985<br/>&gt;3363/2378<br/>&gt;8119/5741<br/>&gt;19601/13860<br/>&gt;47321/33461<br/>&gt;114243/80782<br/>...</p><p>Here are the mediants I find on the way to an answer that<br/>is within a factor of 1.0000001 of sqrt(2)...</p><p>|3/2<br/>|4/3<br/>|7/5<br/>|10/7<br/>|17/12<br/>|24/17<br/>|41/29<br/>|58/41<br/>|99/70<br/>|140/99<br/>|239/169<br/>|338/239<br/>|577/408<br/>|816/577<br/>|1393/985<br/>|1970/1393<br/>|3363/2378</p><p>Your results are every-other number of mine.  As I&apos;ve showed,<br/>this lets me find simpler ratios within a range of the target.<br/>It&apos;s this range bit that everyone here seems to be ignoring,<br/>but which is a central part of music theory applications from<br/>harmonic entropy to beat-synched scales.  Whether I&apos;m missing<br/>any ratios is a question I could use help answering.</p><p>-Carl</p></div><h3><a id=14962 href="#14962">ðŸ”—</a>Gene Ward Smith &#x3C;genewardsmith@coolgoose.com&#x3E;</h3><span>5/30/2006 5:57:28 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Carl Lumma &lt;ekin@...&gt; wrote:</p><p>&gt; It&apos;s this range bit that everyone here seems to be ignoring,<br/>&gt; but which is a central part of music theory applications from<br/>&gt; harmonic entropy to beat-synched scales.  Whether I&apos;m missing<br/>&gt; any ratios is a question I could use help answering.</p><p>And the question is?</p></div><h3><a id=14964 href="#14964">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>5/30/2006 9:12:30 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Aaron Krister Johnson wrote:</p><p>&gt; here&apos;s some python code, to be put in a library.<br/>&gt; I call my own math functions library &apos;math_stuff.py&apos;<br/>&gt; &gt; &gt; from math import sqrt, log, floor<br/>&gt; &gt; def contfrac(a): ### continued fraction expansion<br/>&gt;         terms=[]<br/>&gt;         count=0<br/>&gt;         b=1<br/>&gt;         while ((b != 0) and (count &lt; 24)): ### 24 times, emprical accuracy<br/>&gt;                                            ### limit<br/>&gt;                 terms.append(floor(a/(b+0.0)))<br/>&gt;                 a,b = b, a % b<br/>&gt;                 count = count + 1<br/>&gt;         return terms<br/>&gt; &gt; def ra(x): ### &apos;rational approximation&apos;, or convergent<br/>&gt;         numerators=[0,1]<br/>&gt;         denominators=[1,0]<br/>&gt;         expansion=contfrac(x) ### call the contfrac function<br/>&gt;         for num in expansion: ### [-1] and [-2] index &apos;previous&apos;<br/>&gt;                               ### and &apos;previous-previous&apos;<br/>&gt;                 numerators.append((num*numerators[-1])+numerators[-2])<br/>&gt;                 denominators.append((num*denominators[-1])+denominators[-2])<br/>&gt;         for index in range(len(numerators)):<br/>&gt;                 print &quot;%i/%i&quot; % (numerators[index], denominators[index])<br/>&gt;         print</p><p>By the by, I&apos;ve decided to rewrite this to use generators and not worry about keeping track of the numerators:</p><p>from __future__ import generators<br/>from __future__ import division</p><p>empirical_accuracy_limit = 24</p><p>def ra(x):<br/>    &quot;&quot;&quot;nice output for the rational approximation&quot;&quot;&quot;<br/>    for pair in convergent(x):<br/>        print &quot;%i/%i&quot; % pair</p><p>def convergent(x):<br/>    &quot;&quot;&quot;&apos;rational approximation&apos; or convergent&quot;&quot;&quot;<br/>    prev, curr = 1, 0</p><p>    for num in contfrac(x):<br/>        prev, curr = curr, num*curr + prev<br/>        yield nint(x*curr), curr</p><p>def contfrac(a):<br/>    &quot;&quot;&quot;Continued fraction expansion&quot;&quot;&quot;<br/>    b=1<br/>    for count in range(empirical_accuracy_limit):<br/>        if b==0:<br/>            return<br/>        yield int(a/b)<br/>        a, b = b, a%b</p><p>def nint(x):<br/>    &quot;&quot;&quot;nearest integer&quot;&quot;&quot;<br/>    return int(round(x))</p><p>It works in 2.2 and 2.3.  You shouldn&apos;t need the future imports in 2.4 because it has generators as standard and the division shouldn&apos;t matter (see below)</p><p>&gt; Here&apos;s an example of a shell session where I approximated the sqrt(2) with &gt; rationals:<br/>&gt; &gt; akj@aaron:~$ python<br/>&gt; Python 2.4.1 (#1, Apr 10 2005, 22:30:36)<br/>&gt; [GCC 3.3.5] on linux2<br/>&gt; Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.<br/>&gt; &gt;&gt;&gt;&gt;from math_stuff import *<br/>&gt;&gt;&gt;&gt;ra(sqrt(2))<br/>&gt; &gt; 0/1<br/>&gt; 1/0<br/>&gt; 1/1<br/>&gt; 3/2<br/>&gt; 7/5<br/>&gt; 17/12<br/>&gt; 41/29<br/>&gt; 99/70<br/>&gt; 239/169<br/>&gt; 577/408<br/>&gt; 1393/985<br/>&gt; 3363/2378<br/>&gt; 8119/5741<br/>&gt; 19601/13860<br/>&gt; 47321/33461<br/>&gt; 114243/80782<br/>&gt; 275807/195025<br/>&gt; 665857/470832<br/>&gt; 1607521/1136689<br/>&gt; 3880899/2744210<br/>&gt; 9369319/6625109<br/>&gt; 22619537/15994428<br/>&gt; 54608393/38613965<br/>&gt; 77227930/54608393<br/>&gt; 131836323/93222358<br/>&gt; 209064253/147830751</p><p>Here&apos;s my equivalent</p><p>&gt;&gt;&gt; ra(math.sqrt(2))<br/>1/1<br/>3/2<br/>7/5<br/>17/12<br/>41/29<br/>99/70<br/>239/169<br/>577/408<br/>1393/985<br/>3363/2378<br/>8119/5741<br/>19601/13860<br/>47321/33461<br/>114243/80782<br/>275807/195025<br/>665857/470832<br/>1607521/1136689<br/>3880899/2744210<br/>9369319/6625109<br/>22619537/15994428<br/>54608393/38613965<br/>77227930/54608393<br/>131836323/93222358<br/>209064253/147830751</p><p>I think it&apos;s the same</p><p>&gt; &gt; &gt;&gt;&gt;&gt;209064253/147830751.0<br/>&gt; &gt; 1.4142135623730951<br/>&gt; &gt;&gt;&gt;&gt;sqrt(2)<br/>&gt; &gt; 1.4142135623730951 #### they match!!!<br/>&gt; &gt;&gt;&gt;&gt;                 &gt; &gt; &gt; Notice the use of the &apos;.0&apos; in Python, to tell the interpreter you want a &gt; floating point answer.</p><p>You can also use the future division, so that / always returns floating point.</p><p>&gt;&gt;&gt; from __future__ import division<br/>&gt;&gt;&gt; 209064253/147830751<br/>1.4142135623730951</p><p>In your code it&apos;s better to do float(b) than (b+0.0) because it&apos;s clearer what your intention is.  Better would be to initialize b as a float.  But even then I don&apos;t think you need to worry.  If a is an integer you&apos;ll only get 1 result with b as 1.  If a is a float then everything gets promoted to floats automatically.</p><p>Also note the whole expression</p><p>floor(a/(b+0.0))</p><p>which returns a float could be simplified to</p><p>a//b</p><p>with future division.  But I prefer to return an integer.</p><p>                 Graham</p></div><h3><a id=14967 href="#14967">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>5/31/2006 1:19:14 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt; It&apos;s this range bit that everyone here seems to be ignoring,<br/>&gt;&gt; but which is a central part of music theory applications from<br/>&gt;&gt; harmonic entropy to beat-synched scales.  Whether I&apos;m missing<br/>&gt;&gt; any ratios is a question I could use help answering.<br/>&gt;<br/>&gt;And the question is?</p><p>I tried to be very clear about the problem I&apos;m trying to solve --<br/>that of finding ratios of least tenney height within an arbitrary<br/>range of an arbitrary target.  I&apos;ve shown convergents don&apos;t do the<br/>job.  Does the procedure I&apos;ve described?</p><p>-Carl</p></div><h3><a id=14972 href="#14972">ðŸ”—</a>Gene Ward Smith &#x3C;genewardsmith@coolgoose.com&#x3E;</h3><span>5/31/2006 1:46:38 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Carl Lumma &lt;ekin@...&gt; wrote:</p><p>&gt; I tried to be very clear about the problem I&apos;m trying to solve --<br/>&gt; that of finding ratios of least tenney height within an arbitrary<br/>&gt; range of an arbitrary target.  I&apos;ve shown convergents don&apos;t do the<br/>&gt; job.  Does the procedure I&apos;ve described?</p><p>What would do the job is pretty simple--look at all the<br/>semiconvergents up to your range cutoff.</p></div><h3><a id=14973 href="#14973">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>5/31/2006 1:50:10 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt; I tried to be very clear about the problem I&apos;m trying to solve --<br/>&gt;&gt; that of finding ratios of least tenney height within an arbitrary<br/>&gt;&gt; range of an arbitrary target.  I&apos;ve shown convergents don&apos;t do the<br/>&gt;&gt; job.  Does the procedure I&apos;ve described?<br/>&gt;<br/>&gt;What would do the job is pretty simple--look at all the<br/>&gt;semiconvergents up to your range cutoff.</p><p>Thanks!  I think that&apos;s what I&apos;m doing.  I&apos;ll have to check.</p><p>-Carl</p></div><h3><a id=14982 href="#14982">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>5/31/2006 2:38:43 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt; I tried to be very clear about the problem I&apos;m trying to solve --<br/>&gt;&gt; that of finding ratios of least tenney height within an arbitrary<br/>&gt;&gt; range of an arbitrary target.  I&apos;ve shown convergents don&apos;t do the<br/>&gt;&gt; job.  Does the procedure I&apos;ve described?<br/>&gt;<br/>&gt;What would do the job is pretty simple--look at all the<br/>&gt;semiconvergents up to your range cutoff.</p><p>Ok, so here&apos;s what Wikipedia says about them:</p><p>&gt;If h_(n-1)/k_(n-1) and h_n/k_n are successive convergents,<br/>&gt;then any fraction of the form<br/>&gt;<br/>&gt;h_(n-1) + ah_n<br/>&gt;--------------<br/>&gt;k_(n-1) + ak_n<br/>&gt;<br/>&gt;where &apos;a&apos; is a nonnegative integer and the numerators and<br/>&gt;denominators are between the n and n + 1 terms inclusive are called<br/>&gt;semiconvergents, secondary convergents, or intermediate fractions.<br/>&gt;Often the term is taken to mean that being a semiconvergent excludes<br/>&gt;the possibility of being a convergent, rather than that a convergent<br/>&gt;is a kind of semiconvergent.<br/>&gt;The semiconvergents to the continued fraction expansion of a real<br/>&gt;number x include all the rational approximations which are better<br/>&gt;than any approximation with a smaller denominator. Another useful<br/>&gt;property is that consecutive semiconvergents a/b and c/d are such<br/>&gt;that ad - bc = +/-1.</p><p>Did you mean the term to exclude or include convergents?<br/>My results...</p><p>&gt;Here are the mediants I find on the way to an answer that<br/>&gt;is within a factor of 1.0000001 of sqrt(2)...<br/>&gt;<br/>&gt;|3/2<br/>&gt;|4/3<br/>&gt;|7/5<br/>&gt;|10/7<br/>&gt;|17/12<br/>&gt;|24/17<br/>&gt;|41/29<br/>&gt;|58/41<br/>&gt;|99/70<br/>&gt;|140/99<br/>&gt;|239/169<br/>&gt;|338/239<br/>&gt;|577/408<br/>&gt;|816/577<br/>&gt;|1393/985<br/>&gt;|1970/1393<br/>&gt;|3363/2378</p><p>...appear to meet the ad - bc = +/-1 condition.</p><p>-Carl</p></div><h3><a id=14997 href="#14997">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>5/31/2006 11:34:51 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;Did you mean the term to exclude or include convergents?<br/>&gt;My results...<br/>&gt;<br/>&gt;&gt;Here are the mediants I find on the way to an answer that<br/>&gt;&gt;is within a factor of 1.0000001 of sqrt(2)...<br/>&gt;&gt;<br/>&gt;&gt;|3/2<br/>&gt;&gt;|4/3<br/>&gt;&gt;|7/5<br/>&gt;&gt;|10/7<br/>&gt;&gt;|17/12<br/>&gt;&gt;|24/17<br/>&gt;&gt;|41/29<br/>&gt;&gt;|58/41<br/>&gt;&gt;|99/70<br/>&gt;&gt;|140/99<br/>&gt;&gt;|239/169<br/>&gt;&gt;|338/239<br/>&gt;&gt;|577/408<br/>&gt;&gt;|816/577<br/>&gt;&gt;|1393/985<br/>&gt;&gt;|1970/1393<br/>&gt;&gt;|3363/2378<br/>&gt;<br/>&gt;...appear to meet the ad - bc = +/-1 condition.<br/>&gt;<br/>&gt;-Carl</p><p>Scala will find both convergents and semiconvergents with<br/>its &quot;convergents /semi&quot; command, and even tell you which is which.<br/>My Scheme code seems to match Scala&apos;s output here perfectly,<br/>returning both convergents and semiconvergents.  That&apos;s good.</p><p>What&apos;s weird is, all the stuff on convergents I read on the<br/>web, hardly anyone mentioned semiconvergents, and nobody mentioned<br/>my algorithm, which is dead simple both conceptually and<br/>computationally.</p><p>I still don&apos;t have a proof that this catches all ratios with least<br/>n*d, but it seems like it does.</p><p>-Carl</p></div><h3><a id=15002 href="#15002">ðŸ”—</a>Gene Ward Smith &#x3C;genewardsmith@coolgoose.com&#x3E;</h3><span>6/1/2006 2:22:21 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Carl Lumma &lt;ekin@...&gt; wrote:</p><p>&gt; I still don&apos;t have a proof that this catches all ratios with least<br/>&gt; n*d, but it seems like it does.</p><p>Semiconvergents do that.</p></div><h3><a id=15027 href="#15027">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>6/1/2006 2:27:21 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt; I still don&apos;t have a proof that this catches all ratios with least<br/>&gt;&gt; n*d, but it seems like it does.<br/>&gt;<br/>&gt;Semiconvergents do that.</p><p>Is the proof known?  Googling for &quot;Hardy Wright semiconvergent&quot;<br/>and &quot;Niven Zuckerman semiconvergent&quot; isn&apos;t giving me much luck.</p><p>-Carl</p></div><h3><a id=15028 href="#15028">ðŸ”—</a>Gene Ward Smith &#x3C;genewardsmith@coolgoose.com&#x3E;</h3><span>6/1/2006 3:42:13 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Carl Lumma &lt;ekin@...&gt; wrote:<br/>&gt;<br/>&gt; &gt;&gt; I still don&apos;t have a proof that this catches all ratios with least<br/>&gt; &gt;&gt; n*d, but it seems like it does.<br/>&gt; &gt;<br/>&gt; &gt;Semiconvergents do that.<br/>&gt;<br/>&gt; Is the proof known?  Googling for &quot;Hardy Wright semiconvergent&quot;<br/>&gt; and &quot;Niven Zuckerman semiconvergent&quot; isn&apos;t giving me much luck.</p><p>Niven and Zuckerman stick it in the exercises as a starred (difficult)<br/>exercise, which is sort of annoying. Maybe I need to put the basic<br/>information on semiconvergents on Wikipedia somewhere.</p><p>NZ define (in their exercises) a &quot;good approximation&quot; a/b to x as<br/>being one where |bx-a| is minimal over all u/v with v &lt;= b. Then one<br/>exercise is to show an approximation is &quot;good&quot; iff a/b is a<br/>convergent. Then they define a &quot;fair approximation&quot; as one where<br/>|x-a/b| is minimal among all u/v with v &lt;= b, and then ask you to show<br/>that every &quot;fair approximation&quot; is a convergent or a semiconvergent.<br/>Niven and Zukerman is where I learned these facts long, long ago and<br/>not far away in Berkeley as an undergraduate, and I don&apos;t know another<br/>source offhand.</p><p>Not all semiconvergents are &quot;fair approximations&quot;; 17-et has a fifth<br/>3.93 cents sharp, sharper than 12 is flat. On the other hand, 29-et is<br/>1.49 cents sharper, which beats out 12 and makes it &quot;fair&quot;. It isn&apos;t<br/>&quot;good&quot; however, because 12-et is 1.955 relative cents flat, and 29-et<br/>is 3.609 relative cents sharp (to get relative cents, multiply the<br/>error in cents by n/12.) The next &quot;good&quot; one is 41-et, which has a<br/>fifth 1.654 relative cents sharp.</p><p>The &quot;fair&quot; list for fifths goes 1, 2, 3, 5, 7, 12, 29, 41, 53, 200,<br/>253, 306, 359, 665 ...</p></div><h3><a id=15029 href="#15029">ðŸ”—</a>Gene Ward Smith &#x3C;genewardsmith@coolgoose.com&#x3E;</h3><span>6/1/2006 4:45:36 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, &quot;Gene Ward Smith&quot;<br/>&lt;genewardsmith@...&gt; wrote:</p><p>&gt; Maybe I need to put the basic<br/>&gt; information on semiconvergents on Wikipedia somewhere.</p><p>Actually I did put a section on semiconvergents in there almost a year<br/>ago to the day, which is still there; there is now a section following<br/>it on best rational approximations which I edited to say that<br/>convergents and semiconvergents give you all of the best rational<br/>approximations, which wasn&apos;t stated explicitly. So Wikipedia seems to<br/>be doing OK.</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            