<a href="/tuning-math">back to list</a><h1>Another LLL implementation</h1><h3>genewardsmith@juno.com</h3><span>11/20/2001 12:39:19 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>This is from Calc; see<br/><a href="http://www.maths.uq.edu.au/~krm/krm_calc.html#[49]">http://www.maths.uq.edu.au/~krm/krm_calc.html#[49]</a></p><p>/* The Pohst Algorithm updating only from where necessary */<br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &quot;integer.h&quot;<br/>#include &quot;fun.h&quot;<br/>extern MPI *MAXI, *PMAXI;</p><p>extern unsigned int MLLLVERBOSE;<br/>extern unsigned int HERMITEVERBOSE;<br/>unsigned int GCDFLAG;</p><p>MPMATI *BASIS_REDUCTION(MPMATI *Bptr, MPMATI **Eptr, USI rowstage,<br/>USI m1, USI n1)<br/>/*<br/> * Input: *Bptr, a matrix of MPI&apos;s, whose first row is not zero.<br/> * Output: a pointer to an MPMATI whose rows form a reduced basis for<br/> * the lattice spanned by the rows of *Bptr. This basis is reduced in<br/>the<br/> * sense of the paper &quot;Factoring polynomials with rational<br/>coefficients&quot; by<br/> * A. K. Lenstra, H. W. Lenstra and L. Lovasz, Math. Ann. 261, 515-<br/>534 (1982)<br/> * using the modified version in &quot;Solving exponential Diophantine<br/>equations<br/> * using lattice basis reduction algorithms&quot; by B. M. M. De Weger, J.<br/>No. Theory<br/> * 26, 325-367 (1987). A change of basis matrix **Eptr is also<br/>returned.<br/> * De Weger&apos;s algorithm has been changed to cater for arbitrary<br/>matrices. The<br/> * the rows are now in general linearly dependent.<br/> * We use the fact that the Gram Schmidt process detects the first<br/>row<br/> * which is a linear combination of the preceding rows. We employ a<br/>modification<br/> * of the LLL algorithm outlined by M. Pohst in J. Symbolic<br/>Computation (1987)4,<br/> * 123-127.  We call this the MLLL algorithm.<br/> * The last sigma rows of the matrix **Eptr are relation vectors.<br/> * m1 / n1 is usually taken to be 3 / 4.<br/> */<br/>{<br/>&#x9;unsigned int i, k, l, n, m, t, flag = 0, Flag = 0;<br/>&#x9;unsigned int flagg, beta, K1 = 0, tau = 2, sigma = 0, rho;<br/>&#x9;MPI **D, *X, *Y, *Z, *H, *Tmp, *R, *M1, *N1;<br/>&#x9;MPMATI *C, *L, *B1ptr;</p><p>&#x9;m = Bptr-&gt;C;<br/>&#x9;n = Bptr-&gt;R;<br/>&#x9;<br/>/* We initial Eptr outside the function whenever we call the<br/>function. */<br/>/* This is because we have to do so in SMITH(). */</p><p>/*&#x9;MAXI = MAXELTI(Bptr);<br/>&#x9;PMAXI = MAXELTI(*Eptr); */<br/>&#x9;B1ptr = COPYMATI(Bptr);<br/>&#x9;D = (MPI **)mmalloc((1 + n) * sizeof(MPI *));<br/>&#x9;D[0] = ONEI();<br/>&#x9;for (i = 1; i &lt;= n; i++)<br/>&#x9;&#x9;D[i] = ZEROI();<br/>&#x9;C = ZEROMNI(n, m);<br/>&#x9;L = ZEROMNI(n, n);</p><p>&#x9;found:<br/>&#x9;n = B1ptr-&gt;R;<br/>&#x9;i = (K1 == 0) ? 1 : K1;<br/>&#x9;/* K1 = no. of consecutive rows of *B1ptr that don&apos;t need<br/>updating<br/>for the Gram Schmidt process. */<br/>&#x9;while (i &lt;= B1ptr-&gt;R)<br/>&#x9;{<br/>&#x9;&#x9;BASIS_UPDATE(i, m, &amp;C, &amp;L, B1ptr, D);<br/>&#x9;&#x9;flag = 1;<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;if (!EQZEROI(C-&gt;V[i - 1][t]))<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;}&#x9;<br/>&#x9;&#x9;if (flag)<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;X = ZEROI();<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;H = MULTI(C-&gt;V[i - 1][t], C-&gt;V[i - 1][t]);<br/>&#x9;&#x9;&#x9;Tmp = X;<br/>&#x9;&#x9;&#x9;X = ADDI(X, H);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(H);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;&#x9;D[i] = INT(X, D[i - 1]);&#x9;<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;i++;<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;printf(&quot;i = %u\n&quot;, i);<br/>&#x9;}<br/>&#x9;beta =  (flag) ? i : i - 1;<br/>&#x9;rho = K1 = i - 1;<br/>if (MLLLVERBOSE)<br/>&#x9;printf(&quot;completed updating the basis\n&quot;);<br/>/* Here K1 = no. of LI rows in *B1ptr found by Gram Schmidt process.<br/>   flag = 0 means all the rho = beta rows of *B1ptr are LI;<br/>   flag = 1 means that the first rho = beta - 1 rows of *B1ptr are<br/>LI, but the<br/>   beta-th row is a LC of the preceding rows. So beta = number of<br/>rows of *B1ptr<br/>   currently being examined by the LLL algorithm. */<br/>&#x9;k = tau;<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;printf(&quot;beta = %u\n&quot;, beta);<br/>&#x9;M1 = CHANGE(m1);<br/>&#x9;N1 = CHANGE(n1);<br/>&#x9;while (k &lt;= beta)<br/>&#x9;{<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;printf(&quot;beta - k = %u\n&quot;, beta -k);<br/>&#x9;&#x9;l = k - 1;<br/>&#x9;&#x9;Flag = STEP4(k, l, &amp;L, &amp;B1ptr, Eptr, D, rowstage);<br/>&#x9;&#x9;if (Flag)/* STEP 9 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;printf(&quot;relation vector number %u<br/>found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;goto found;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[k - 2], D[k]);<br/>&#x9;&#x9;Y = MULTI(D[k - 1], D[k - 1]);<br/>&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;Y = MULT_I(Y, m1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;R = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k - 2]);<br/>&#x9;&#x9;Z = ADD0I(X, R);<br/>&#x9;&#x9;Tmp = Z;<br/>&#x9;&#x9;Z = MULT_I(Z, n1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;if (RSV(Y, Z) == 1)/*&amp; STEP 5 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flagg = 0;<br/>&#x9;&#x9;&#x9;if (EQZEROI(D[k]) &amp;&amp; EQZEROI(R))<br/>&#x9;&#x9;&#x9;{/* CASE B=0 of STEP 7 of POHST. */<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(D[k - 1]);<br/>&#x9;&#x9;&#x9;&#x9;D[k - 1] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;STEP8(k, &amp;B1ptr, &amp;L, Eptr, rowstage);<br/>&#x9;&#x9;&#x9;&#x9;if (k - 1 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;K1 = k - 1;<br/>&#x9;&#x9;&#x9;&#x9;/* The swap may have changed 2nd last<br/>row */<br/>&#x9;&#x9;&#x9;&#x9;/* of *B1ptr. */<br/>&#x9;&#x9;&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(C-&gt;V[k - 2][t]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;C-&gt;V[k - 2][t] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;beta--;<br/>&#x9;&#x9;&#x9;&#x9;flagg = 1;<br/>&#x9;&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;continue;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;if (flagg == 0)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;for (i = k + 1; i &lt;= beta; i++)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;STEP7(i, k, &amp;L, D);<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;STEP8(k, &amp;B1ptr, &amp;L, Eptr, rowstage);<br/>&#x9;&#x9;&#x9;if (k - 2 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;K1 = k - 2;<br/>&#x9;&#x9;&#x9;/* swap will change last two rows of *B1ptr.<br/>*/<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;Y = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k -<br/>2]);<br/>&#x9;&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;&#x9;Y = ADD0I(Y, X);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;Tmp = D[k - 1];<br/>&#x9;&#x9;&#x9;D[k - 1] = INT0(Y, D[k - 1]);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;else<br/>&#x9;&#x9;{ /* STEP 6 of POHST. */<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;for (l = k - 2; l &gt;= 1; l--)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;Flag = &#x9;STEP4(k, l, &amp;L, &amp;B1ptr, Eptr,<br/>D, rowstage);<br/>&#x9;&#x9;&#x9;&#x9;if (Flag)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;relation vector<br/>number %u found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;goto found; /* STEP 9 of<br/>POHST. */<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;k++;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;FREEMPI(Z);<br/>&#x9;}<br/>&#x9;FREEMPI(M1);<br/>&#x9;FREEMPI(N1);<br/>&#x9;FREEMATI(C);</p><p>&#x9;printf(&quot;L = \n&quot;);<br/>&#x9;PRINTMATI(0,L-&gt;R-1,0,L-&gt;C-1,L);<br/>&#x9;for (i = 0; i &lt;= Bptr-&gt;R; i++)<br/>&#x9;{<br/>&#x9;&#x9;printf(&quot;D[%u] = &quot;, i);PRINTI(D[i]);printf(&quot;, &quot;);<br/>&#x9;}<br/>&#x9;printf(&quot;\n&quot;);<br/>&#x9;FREEMATI(L);<br/>&#x9;for (i = 0; i &lt;= Bptr-&gt;R; i++)<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;ffree((char *)D, (1 + Bptr-&gt;R) * sizeof(MPI *));<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;{<br/>&#x9;&#x9;printf(&quot;number of basis vectors found = %u ;\n&quot;, rho);<br/>&#x9;&#x9;printf(&quot;number of relation vectors found = %u .\n&quot;,<br/>sigma);<br/>&#x9;}<br/>&#x9;return (B1ptr);<br/>}</p><p>unsigned int STEP4(k, l, Lptr, Bptr, Eptr, D, i)<br/>/*<br/> * updates *Lptr, *Bptr and *Eptr.<br/> * returns 1 if row k of *Bptr becomes zero, returns zero otherwise.<br/> */<br/>unsigned int k, l, i;<br/>MPI *D[];<br/>MPMATI **Lptr, **Bptr, **Eptr;<br/>{<br/>&#x9;unsigned int j, flag = 1, t, m, n;<br/>&#x9;MPI *X, *Y, *R, *Tmp;<br/>&#x9;MPMATI *TmpMATI;</p><p>&#x9;m = (*Bptr)-&gt;C;<br/>&#x9;n = (*Eptr)-&gt;R;<br/>&#x9;Y = MULT_I((*Lptr)-&gt;V[k - 1][l - 1], 2);<br/>&#x9;if (RSV(Y, D[l]) == 1)<br/>&#x9;{<br/>&#x9;&#x9;R = NEAREST_INTI((*Lptr)-&gt;V[k - 1][l - 1], D[l]);<br/>&#x9;&#x9;X = MINUSI(R);<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = ADD_MULT_ROWI(l - 1, k - 1, X, *Bptr);<br/>/*<br/>&#x9;&#x9;MAXI = UPDATEMAXI(MAXI, *Bptr);<br/>*/<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>&#x9;&#x9;TmpMATI = *Eptr;<br/>&#x9;&#x9;*Eptr = ADD_MULT_ROWI(l + i - 1, k + i - 1, X, *Eptr);<br/>/*<br/>&#x9;&#x9;PMAXI = UPDATEMAXI(PMAXI, *Eptr);<br/>*/<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;for (j = 1; j &lt; l; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;X = MULTI((*Lptr)-&gt;V[l - 1][j - 1], R);<br/>&#x9;&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][j - 1];<br/>&#x9;&#x9;&#x9;(*Lptr)-&gt;V[k - 1][j - 1] = SUBI((*Lptr)-&gt;V[k -<br/> 1][j - 1], X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[l], R);<br/>&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][l - 1];<br/>&#x9;&#x9;(*Lptr)-&gt;V[k - 1][l - 1] = SUBI((*Lptr)-&gt;V[k - 1][l -<br/>1], X);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;FREEMPI(R);<br/>&#x9;}<br/>&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;{<br/>&#x9;&#x9;if (!EQZEROI((*Bptr)-&gt;V[k - 1][t]))<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;}<br/>&#x9;}&#x9;<br/>&#x9;if (flag)<br/>&#x9;{<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = DELETE_ROWI(k, *Bptr);<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>&#x9;&#x9;for (j = k - 1; j &lt; n - i - 1; j++)<br/>&#x9;&#x9;&#x9;*Eptr = SWAP_ROWSI1(j + i, j + i + 1, *Eptr);<br/>&#x9;}<br/>&#x9;FREEMPI(Y);<br/>&#x9;return (flag);<br/>}</p><p>void STEP8(USI k, MPMATI **B1ptr, MPMATI **Lptr, MPMATI **Eptr, USI i)<br/>{<br/>&#x9;MPI *T;</p><p>&#x9;*B1ptr = SWAP_ROWSI1(k - 2, k - 1, *B1ptr);<br/>&#x9;*Eptr = SWAP_ROWSI1(k + i - 2, k + i - 1, *Eptr);<br/>&#x9;T = COPYI((*Lptr)-&gt;V[k - 1][ k - 2]);<br/>&#x9;*Lptr = SWAP_ROWSI1(k - 2, k - 1, *Lptr);<br/>&#x9;FREEMPI((*Lptr)-&gt;V[ k - 1][k - 2]);<br/>&#x9;(*Lptr)-&gt;V[k - 1][k - 2] = T;<br/>&#x9;FREEMPI((*Lptr)-&gt;V[k - 2][k - 2]);<br/>&#x9;(*Lptr)-&gt;V[k - 2][k - 2] = ZEROI();<br/>&#x9;return;<br/>}</p><p>void STEP7(USI i, USI k, MPMATI **Lptr, MPI *D[])<br/>{<br/>&#x9;MPI *X1, *X2, *X3, *Y1, *Y2, *Tmp;</p><p>&#x9;X1 = MULTI((*Lptr)-&gt;V[i - 1][k - 2], (*Lptr)-&gt;V[k - 1][k -<br/>2]);<br/>&#x9;Y1 = MULTI((*Lptr)-&gt;V[i - 1][k - 1], D[k - 2]);<br/>&#x9;Tmp = Y1;<br/>&#x9;Y1 = ADDI(Y1, X1);<br/>&#x9;FREEMPI(Tmp);<br/>&#x9;FREEMPI(X1);<br/>&#x9;X2 = MULTI((*Lptr)-&gt;V[i - 1][k - 2], D[k]);<br/>&#x9;X3 = MINUSI((*Lptr)-&gt;V[k - 1][k - 2]);<br/>&#x9;Y2 = MULTI((*Lptr)-&gt;V[i - 1][k - 1], X3);<br/>&#x9;FREEMPI(X3);<br/>&#x9;Tmp = Y2;<br/>&#x9;Y2 = ADDI(Y2, X2);<br/>&#x9;FREEMPI(Tmp);<br/>&#x9;FREEMPI(X2);<br/>&#x9;FREEMPI((*Lptr)-&gt;V[i - 1][k - 2]);<br/>&#x9;(*Lptr)-&gt;V[i - 1][k - 2] = INT(Y1, D[k - 1]);<br/>&#x9;FREEMPI((*Lptr)-&gt;V[i - 1][k - 1]);<br/>&#x9;(*Lptr)-&gt;V[i - 1][k - 1] = INT(Y2, D[k - 1]);<br/>&#x9;FREEMPI(Y1);<br/>&#x9;FREEMPI(Y2);<br/>&#x9;return;<br/>}</p><p>void BASIS_UPDATE(USI i, USI m, MPMATI **Cptr, MPMATI **Lptr, MPMATI<br/>*B1ptr, MPI *D[])<br/>{<br/>&#x9;unsigned int j, k, t;<br/>&#x9;MPI *X, *Tmp, *X1, *X2, *H;</p><p>&#x9;for (k = 1; k &lt;= m; k++)<br/>&#x9;{<br/>&#x9;&#x9;FREEMPI((*Cptr)-&gt;V[i - 1][k - 1]);<br/>&#x9;&#x9;(*Cptr)-&gt;V[i - 1][k - 1] = COPYI(B1ptr-&gt;V[i - 1][k -<br/>1]);<br/>&#x9;}<br/>&#x9;for (j = 1; j &lt; i; j++)<br/>&#x9;{<br/>&#x9;&#x9;X = ZEROI();<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;if (((*Cptr)-&gt;V[j - 1][t])-&gt;S != 0 &amp;&amp; (B1ptr-<br/>&gt;V[i - 1][t])-&gt;S != 0)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;H = MULTI((*Cptr)-&gt;V[j - 1][t], B1ptr-<br/>&gt;V[i - 1][t]);<br/>&#x9;&#x9;&#x9;&#x9;Tmp = X;<br/>&#x9;&#x9;&#x9;&#x9;X = ADDI(X, H);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(H);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;}<br/>&#x9;&#x9;FREEMPI((*Lptr)-&gt;V[i - 1][j - 1]);<br/>&#x9;&#x9;(*Lptr)-&gt;V[i - 1][j - 1] = X;<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;if (((*Cptr)-&gt;V[i - 1][t])-&gt;S == 0)<br/>&#x9;&#x9;&#x9;&#x9;X1 = ZEROI();<br/>&#x9;&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;&#x9;X1 = MULTI((*Cptr)-&gt;V[i - 1][t], D<br/>[j]);<br/>&#x9;&#x9;&#x9;if (((*Cptr)-&gt;V[j - 1][t])-&gt;S != 0 &amp;&amp;<br/>((*Lptr)-&gt;V[i - 1][j - 1])-&gt;S != 0)<br/>&#x9;&#x9;&#x9;&#x9;X2 = MULTI((*Cptr)-&gt;V[j - 1][t],<br/>(*Lptr)-&gt;V[i - 1][j - 1]);<br/>&#x9;&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;&#x9;X2 = ZEROI();<br/>&#x9;&#x9;&#x9;Tmp = X1;<br/>&#x9;&#x9;&#x9;X1 = SUBI(X1, X2);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(X2);<br/>&#x9;&#x9;&#x9;FREEMPI((*Cptr)-&gt;V[i - 1][t]);<br/>&#x9;&#x9;&#x9;(*Cptr)-&gt;V[i - 1][t] = INT(X1, D[j - 1]);<br/>&#x9;&#x9;&#x9;FREEMPI(X1);<br/>&#x9;&#x9;}<br/>&#x9;}<br/>&#x9;return;<br/>}</p><p>void CSWAP_UPDATE(USI k, USI m, MPI *S, MPMATI **Cptr, MPI *D[])<br/>{<br/>&#x9;unsigned int t;<br/>&#x9;MPI *Tmp1, *Tmp2, *Tmp3, *Tmp4;</p><p>&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;{<br/>&#x9;&#x9;Tmp1 = MULTI((*Cptr)-&gt;V[k - 1][t], D[k - 2]);<br/>&#x9;&#x9;Tmp2 = MULTI((*Cptr)-&gt;V[k - 2][t], S);<br/>&#x9;&#x9;Tmp3 = ADDI(Tmp1, Tmp2);<br/>&#x9;&#x9;FREEMPI(Tmp1);<br/>&#x9;&#x9;FREEMPI(Tmp2);<br/>&#x9;<br/>&#x9;&#x9;Tmp1 = MULTI((*Cptr)-&gt;V[k - 2][t], D[k]);<br/>&#x9;&#x9;Tmp2 = MULTI((*Cptr)-&gt;V[k - 1][t], S);<br/>&#x9;&#x9;Tmp4 = SUBI(Tmp1, Tmp2);<br/>&#x9;&#x9;FREEMPI(Tmp1);<br/>&#x9;&#x9;FREEMPI(Tmp2);<br/>&#x9;&#x9;FREEMPI((*Cptr)-&gt;V[k - 2][t]);<br/>&#x9;&#x9;FREEMPI((*Cptr)-&gt;V[k - 1][t]);<br/>&#x9;&#x9;(*Cptr)-&gt;V[k - 2][t] = INT(Tmp3, D[k - 1]);<br/>&#x9;&#x9;(*Cptr)-&gt;V[k - 1][t] = INT(Tmp4, D[k - 1]);<br/>&#x9;&#x9;FREEMPI(Tmp3);<br/>&#x9;&#x9;FREEMPI(Tmp4);<br/>&#x9;}<br/>&#x9;return;<br/>}</p><p>MPMATI *BASIS_REDUCTION0(MPMATI *Bptr, USI m1, USI n1)<br/>/*<br/> * Input: *Bptr, a matrix of MPI&apos;s, whose first row is not zero.<br/> * Output: a pointer to an MPMATI whose rows form a reduced basis for<br/> * the lattice spanned by the rows of *Bptr. This basis is reduced in<br/>the<br/> * sense of the paper &quot;Factoring polynomials with rational<br/>coefficients&quot; by<br/> * A. K. Lenstra, H. W. Lenstra and L. Lovasz, Math. Ann. 261, 515-<br/>534 (1982)<br/> * using the modified version in &quot;Solving exponential Diophantine<br/>equations<br/> * using lattice basis reduction algorithms&quot; by B. M. M. De Weger, J.<br/>No. Theory<br/> * 26, 325-367 (1987). No change of basis matrix is returned.<br/> * De Weger&apos;s algorithm has been changed to cater for arbitrary<br/>matrices. The<br/> * the rows are now in general linearly dependent.<br/> * We use the fact that the Gram Schmidt process detects the first<br/>row<br/> * which is a linear combination of the preceding rows. We employ a<br/>modification<br/> * of the LLL algorithm outlined by M. Pohst in J. Symbolic<br/>Computation (1987)4,<br/> * 123-127.  We call this the MLLL algorithm.<br/> * If we are using this algorithm to find small multipliers for the<br/>extended<br/> * gcd problem, GCDFLAG is set in EXTGCD() and gcdflag is set below.<br/> * m1 / n1 is usually taken to be 3 / 4.<br/> */<br/>{<br/>&#x9;unsigned int i, k, l, n, m, t, flag = 0, Flag = 0, gcdflag =<br/>0;<br/>&#x9;unsigned int flagg, beta, K1 = 0, tau = 2, sigma = 0, rho;<br/>&#x9;MPI **D, *X, *Y, *Z, *H, *Tmp, *R, *M1, *N1;<br/>&#x9;MPMATI *C, *L, *B1ptr;<br/>&#x9;unsigned int norig;</p><p>&#x9;Z = NULL;<br/>&#x9;m = Bptr-&gt;C;<br/>&#x9;n = Bptr-&gt;R;<br/>&#x9;norig = n;<br/>&#x9;B1ptr = COPYMATI(Bptr);<br/>&#x9;D = (MPI **)mmalloc((1 + n) * sizeof(MPI *));<br/>&#x9;D[0] = ONEI();<br/>&#x9;for (i = 1; i &lt;= n; i++)<br/>&#x9;&#x9;D[i] = ZEROI();<br/>&#x9;C = ZEROMNI(n, m);<br/>&#x9;L = ZEROMNI(n, n);</p><p>&#x9;found:<br/>&#x9;n = B1ptr-&gt;R;<br/>&#x9;i = (K1 == 0) ? 1 : K1;<br/>&#x9;/* K1 = no. of consecutive rows of *B1ptr that don&apos;t need<br/>updating<br/>for the Gram Schmidt process. */<br/>&#x9;while (i &lt;= B1ptr-&gt;R)<br/>&#x9;{<br/>&#x9;&#x9;BASIS_UPDATE(i, m, &amp;C, &amp;L, B1ptr, D);<br/>&#x9;&#x9;flag = 1;<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;if (!EQZEROI(C-&gt;V[i - 1][t]))<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;}&#x9;<br/>&#x9;&#x9;if (flag)<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;X = ZEROI();<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;H = MULTI(C-&gt;V[i - 1][t], C-&gt;V[i - 1][t]);<br/>&#x9;&#x9;&#x9;Tmp = X;<br/>&#x9;&#x9;&#x9;X = ADDI(X, H);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(H);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;&#x9;D[i] = INT(X, D[i - 1]);&#x9;<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;i++;<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;printf(&quot;i = %u\n&quot;, i);<br/>&#x9;}<br/>&#x9;beta =  (flag) ? i : i - 1;<br/>&#x9;rho = K1 = i - 1;<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;printf(&quot;BASIS0 completed updating the basis\n&quot;);<br/>/* Here K1 = no. of LI rows in *B1ptr found by Gram Schmidt process.<br/>   flag = 0 means all the rho = beta rows of *B1ptr are LI;<br/>   flag = 1 means that the first rho = beta - 1 rows of *B1ptr are<br/>LI, but the<br/>   beta-th row is a LC of the preceding rows. So beta = number of<br/>rows of *B1ptr<br/>   currently being examined by the LLL algorithm. */<br/>&#x9;k = tau;<br/>&#x9;M1 = CHANGE(m1);<br/>&#x9;N1 = CHANGE(n1);<br/>&#x9;while (k &lt;= beta)<br/>&#x9;{<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;printf(&quot;beta - k = %u\n&quot;, beta -k);<br/>&#x9;&#x9;l = k - 1;<br/>&#x9;&#x9;Flag = STEP40(k, l, &amp;L, &amp;B1ptr, D);<br/>&#x9;&#x9;if (k &gt;= norig &amp;&amp; GCDFLAG)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;gcdflag = 1;<br/>&#x9;&#x9;&#x9;goto FOUND;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;if (Flag)/* STEP 9 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;printf(&quot;relation vector number %u<br/>found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;goto found;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[k - 2], D[k]);<br/>&#x9;&#x9;Y = MULTI(D[k - 1], D[k - 1]);<br/>&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;Y = MULT_I(Y, m1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;R = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k - 2]);<br/>&#x9;&#x9;Z = ADD0I(X, R);<br/>&#x9;&#x9;Tmp = Z;<br/>&#x9;&#x9;Z = MULT_I(Z, n1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;if (RSV(Y, Z) == 1)/*&amp; STEP 5 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flagg = 0;<br/>&#x9;&#x9;&#x9;if (EQZEROI(D[k]) &amp;&amp; EQZEROI(R))<br/>&#x9;&#x9;&#x9;{/* CASE B=0 of STEP 7 of POHST. */<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(D[k - 1]);<br/>&#x9;&#x9;&#x9;&#x9;D[k - 1] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;STEP80(k, &amp;B1ptr, &amp;L);<br/>&#x9;&#x9;&#x9;&#x9;if (k - 1 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;K1 = k - 1;<br/>&#x9;&#x9;&#x9;&#x9;/* The swap may have changed 2nd last<br/>row */<br/>&#x9;&#x9;&#x9;&#x9;/* of *B1ptr. */<br/>&#x9;&#x9;&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(C-&gt;V[k - 2][t]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;C-&gt;V[k - 2][t] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;beta--;<br/>&#x9;&#x9;&#x9;&#x9;flagg = 1;<br/>&#x9;&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;continue;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;if (flagg == 0)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;for (i = k + 1; i &lt;= beta; i++)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;STEP7(i, k, &amp;L, D);<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;STEP80(k, &amp;B1ptr, &amp;L);<br/>&#x9;&#x9;&#x9;if (k - 2 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;K1 = k - 2;<br/>&#x9;&#x9;&#x9;/* swap will change last two rows of *B1ptr.<br/>*/<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;Y = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k -<br/>2]);<br/>&#x9;&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;&#x9;Y = ADD0I(Y, X);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;Tmp = D[k - 1];<br/>&#x9;&#x9;&#x9;D[k - 1] = INT0(Y, D[k - 1]);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;else<br/>&#x9;&#x9;{ /* STEP 6 of POHST. */<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>FOUND:<br/>&#x9;&#x9;&#x9;for (l = k - 2; l &gt;= 1; l--)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;Flag = &#x9;STEP40(k, l, &amp;L, &amp;B1ptr, D);<br/>&#x9;&#x9;&#x9;&#x9;if (Flag)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;relation<br/>vector number %u found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;goto found; /* STEP 9 of<br/>POHST. */<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;k++;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;if (!gcdflag)<br/>&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;}<br/>&#x9;FREEMPI(M1);<br/>&#x9;FREEMPI(N1);<br/>&#x9;FREEMATI(C);<br/>/*<br/>&#x9;printf(&quot;L = \n&quot;);<br/>&#x9;PRINTMATI(0,L-&gt;R-1,0,L-&gt;C-1,L);<br/>&#x9;for (i = 0; i &lt;= norig; i++)<br/>&#x9;{<br/>&#x9;&#x9;printf(&quot;D[%u] = &quot;, i);PRINTI(D[i]);printf(&quot;, &quot;);<br/>&#x9;}<br/>&#x9;printf(&quot;\n&quot;);<br/>*/<br/>&#x9;FREEMATI(L);<br/>&#x9;for (i = 0; i &lt;= norig; i++)<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;ffree((char *)D, (1 + norig) * sizeof(MPI *));<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;{<br/>&#x9;&#x9;printf(&quot;number of basis vectors found = %u ;\n&quot;, rho);<br/>&#x9;&#x9;printf(&quot;number of relation vectors found = %u .\n&quot;,<br/>sigma);<br/>&#x9;}<br/>&#x9;return (B1ptr);<br/>}</p><p>unsigned int STEP40(k, l, Lptr, Bptr, D)<br/>/*<br/> * updates *Lptr, *Bptr.<br/> * returns 1 if row k of *Bptr becomes zero, returns zero otherwise.<br/> */<br/>unsigned int k, l;<br/>MPI *D[];<br/>MPMATI **Lptr, **Bptr;<br/>{<br/>&#x9;unsigned int j, flag = 1, t, m;<br/>&#x9;MPI *X, *Y, *R, *Tmp;<br/>&#x9;MPMATI *TmpMATI;</p><p>&#x9;m = (*Bptr)-&gt;C;<br/>&#x9;Y = MULT_I((*Lptr)-&gt;V[k - 1][l - 1], 2);<br/>&#x9;if (RSV(Y, D[l]) == 1)<br/>&#x9;{<br/>&#x9;&#x9;R = NEAREST_INTI((*Lptr)-&gt;V[k - 1][l - 1], D[l]);<br/>&#x9;&#x9;X = MINUSI(R);<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = ADD_MULT_ROWI(l - 1, k - 1, X, *Bptr);<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;printf(&quot;Row %u -&gt; Row %u + &quot;, k,k);PRINTI<br/>(X);printf(&quot; x Row %u\n&quot;, l);<br/>&#x9;&#x9;&#x9;PRINTMATI(0,(*Bptr)-&gt;R-1,0,(*Bptr)-&gt;C-<br/>1,*Bptr);<br/>&#x9;&#x9;&#x9;GetReturn();<br/>&#x9;&#x9;}<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>/*<br/>&#x9;&#x9;MAXI = UPDATEMAXI(MAXI, *Bptr);<br/>*/<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;for (j = 1; j &lt; l; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;X = MULTI((*Lptr)-&gt;V[l - 1][j - 1], R);<br/>&#x9;&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][j - 1];<br/>&#x9;&#x9;&#x9;(*Lptr)-&gt;V[k - 1][j - 1] = SUBI((*Lptr)-&gt;V[k -<br/> 1][j - 1], X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[l], R);<br/>&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][l - 1];<br/>&#x9;&#x9;(*Lptr)-&gt;V[k - 1][l - 1] = SUBI((*Lptr)-&gt;V[k - 1][l -<br/>1], X);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;FREEMPI(R);<br/>&#x9;}<br/>&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;{<br/>&#x9;&#x9;if (!EQZEROI((*Bptr)-&gt;V[k - 1][t]))<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;}<br/>&#x9;}&#x9;<br/>&#x9;if (flag)<br/>&#x9;{<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = DELETE_ROWI(k, *Bptr);<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>&#x9;}<br/>&#x9;FREEMPI(Y);<br/>&#x9;return (flag);<br/>}</p><p>unsigned int STEP400(k, l, Lptr, Bptr, D, gcdflag, norig)<br/>/*<br/> * updates *Lptr, *Bptr.<br/> * returns 1 if row k of *Bptr becomes zero, returns zero otherwise.<br/> */<br/>unsigned int k, l, gcdflag, norig;<br/>MPI *D[];<br/>MPMATI **Lptr, **Bptr;<br/>{<br/>&#x9;unsigned int j, flag = 1, t, m;<br/>&#x9;MPI *X, *Y, *R, *Tmp;<br/>&#x9;MPMATI *TmpMATI;</p><p>&#x9;m = (*Bptr)-&gt;C;<br/>&#x9;Y = MULT_I((*Lptr)-&gt;V[k - 1][l - 1], 2);<br/>&#x9;if (RSV(Y, D[l]) == 1)<br/>&#x9;{<br/>&#x9;&#x9;R = NEAREST_INTI((*Lptr)-&gt;V[k - 1][l - 1], D[l]);<br/>&#x9;&#x9;X = MINUSI(R);<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = ADD_MULT_ROWI(l - 1, k - 1, X, *Bptr);<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>/*<br/>&#x9;&#x9;MAXI = UPDATEMAXI(MAXI, *Bptr);<br/>*/<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;for (j = 1; j &lt; l; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;X = MULTI((*Lptr)-&gt;V[l - 1][j - 1], R);<br/>&#x9;&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][j - 1];<br/>&#x9;&#x9;&#x9;(*Lptr)-&gt;V[k - 1][j - 1] = SUBI((*Lptr)-&gt;V[k -<br/> 1][j - 1], X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[l], R);<br/>&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][l - 1];<br/>&#x9;&#x9;(*Lptr)-&gt;V[k - 1][l - 1] = SUBI((*Lptr)-&gt;V[k - 1][l -<br/>1], X);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;FREEMPI(R);<br/>&#x9;}<br/>&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;{<br/>&#x9;&#x9;if (!EQZEROI((*Bptr)-&gt;V[k - 1][t]))<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;}<br/>&#x9;}&#x9;<br/>&#x9;if (flag)<br/>&#x9;{<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = DELETE_ROWI(k, *Bptr);<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>&#x9;}<br/>&#x9;FREEMPI(Y);<br/>&#x9;return (flag);<br/>}</p><p>void STEP80(k, B1ptr, Lptr)<br/>MPMATI **B1ptr, **Lptr;<br/>unsigned int k;<br/>{<br/>&#x9;MPI *T;</p><p>&#x9;*B1ptr = SWAP_ROWSI1(k - 2, k - 1, *B1ptr);<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;{<br/>&#x9;&#x9;printf(&quot;Swapping Rows %u and %u\n&quot;, k-1,k);<br/>&#x9;&#x9;PRINTMATI(0,(*B1ptr)-&gt;R-1,0,(*B1ptr)-&gt;C-1,*B1ptr);<br/>&#x9;&#x9;GetReturn();<br/>&#x9;}<br/>&#x9;T = COPYI((*Lptr)-&gt;V[k - 1][k - 2]);<br/>&#x9;*Lptr = SWAP_ROWSI1(k - 2, k - 1, *Lptr);<br/>&#x9;FREEMPI((*Lptr)-&gt;V[k - 1][k - 2]);<br/>&#x9;(*Lptr)-&gt;V[k - 1][k - 2] = T;<br/>&#x9;FREEMPI((*Lptr)-&gt;V[k - 2][k - 2]);<br/>&#x9;(*Lptr)-&gt;V[k - 2][k - 2] = ZEROI();<br/>&#x9;return;<br/>}</p><p>MPMATI *EXTGCD(MPMATI *Dptr, MPI **Aptr, MPMATI **Q, USI m1, USI n1)<br/>/*<br/> * Input: an n x 1 vector of MPI&apos;s.<br/> * Output: *Aptr = gcd of the vector of MPI&apos;s. Also we return a small<br/>set of<br/> * multipliers using the LLL method of Havas and Matthews.<br/> * parameters m1 and n1 were put in at the request of George Havas on<br/>11/7/94.<br/> * Normally m1/n1 = 3/4.<br/> * matrix Q of the LLL extended gcd paper of Havas-Matthews is<br/>returned.<br/> */<br/>{<br/>&#x9;MPMATI *Temp, *P, *SM, *R;<br/>&#x9;USI i, m, n, *alpha, nz;<br/>&#x9;MPI **Tptr;</p><p>&#x9;n = Dptr-&gt;R;<br/>&#x9;m = n - 1;<br/>&#x9;alpha = KB_ROWP(Dptr, &amp;R, &amp;nz);<br/>&#x9;Temp = HERMITE1P(Dptr, R, &amp;P, alpha, nz);<br/>&#x9;FREEMATI(R);<br/>&#x9;ffree((char *)alpha, (Dptr-&gt;C) * sizeof(USI));<br/>&#x9;*Aptr = COPYI(Temp-&gt;V[0][0]);<br/>&#x9;FREEMATI(Temp);<br/>&#x9;Tptr = P-&gt;V[0];<br/>&#x9;for (i = 0; i &lt; m; i++)<br/>&#x9;&#x9;P-&gt;V[i] = P-&gt;V[i+1];<br/>&#x9;P-&gt;V[n - 1] = Tptr;<br/>&#x9;GCDFLAG = 1;<br/>&#x9;*Q = BASIS_REDUCTION0(P, m1, n1);&#x9;<br/>&#x9;SM = BUILDMATI(1, n);<br/>&#x9;for (i = 0; i &lt; n; i++)<br/>&#x9;&#x9;SM-&gt;V[0][i] = COPYI((*Q)-&gt;V[m][i]);<br/>&#x9;FREEMATI(P);<br/>&#x9;GCDFLAG = 0;<br/>&#x9;return (SM);<br/>}</p><p>MPI *LENGTHSQRI(MPMATI *Mptr, USI i)<br/>/*<br/> * Returns the square of the length of row i of matrix *Mptr.<br/> */<br/>{<br/>&#x9;MPI *SUM, *T, *T1;<br/>&#x9;USI j;<br/>&#x9;<br/>&#x9;SUM = ZEROI();<br/>&#x9;for (j = 0; j &lt; Mptr-&gt;C; j++)<br/>&#x9;{<br/>&#x9;&#x9;T = SUM;<br/>&#x9;&#x9;T1 = MULTI(Mptr-&gt;V[i][j], Mptr-&gt;V[i][j]);<br/>&#x9;&#x9;SUM = ADD0I(SUM, T1);<br/>&#x9;&#x9;FREEMPI(T);<br/>&#x9;&#x9;FREEMPI(T1);<br/>&#x9;}<br/>&#x9;return (SUM);<br/>}</p><p>MPI *LENGTHSQCI(MPMATI *Mptr, USI j)<br/>/*<br/> * Returns the square of the length of column j of matrix *Mptr.<br/> */<br/>{<br/>&#x9;MPI *SUM, *T, *T1;<br/>&#x9;USI i;<br/>&#x9;<br/>&#x9;SUM = ZEROI();<br/>&#x9;for (i = 0; i &lt; Mptr-&gt;R; i++)<br/>&#x9;{<br/>&#x9;&#x9;T = SUM;<br/>&#x9;&#x9;T1 = MULTI(Mptr-&gt;V[i][j], Mptr-&gt;V[i][j]);<br/>&#x9;&#x9;SUM = ADD0I(SUM, T1);<br/>&#x9;&#x9;FREEMPI(T);<br/>&#x9;&#x9;FREEMPI(T1);<br/>&#x9;}<br/>&#x9;return (SUM);<br/>}</p><p>MPMATI *BASIS_REDUCTION00(MPMATI *Bptr, USI m1, USI n1, USI norig)<br/>/*<br/> * Input: *Bptr, a matrix of MPI&apos;s, whose first row is not zero.<br/> * Output: a pointer to an MPMATI whose rows form a reduced basis for<br/> * the lattice spanned by the rows of *Bptr. This basis is reduced in<br/>the<br/> * sense of the paper &quot;Factoring polynomials with rational<br/>coefficients&quot; by<br/> * A. K. Lenstra, H. W. Lenstra and L. Lovasz, Math. Ann. 261, 515-<br/>534 (1982)<br/> * using the modified version in &quot;Solving exponential Diophantine<br/>equations<br/> * using lattice basis reduction algorithms&quot; by B. M. M. De Weger, J.<br/>No. Theory<br/> * 26, 325-367 (1987). No change of basis matrix is returned.<br/> * De Weger&apos;s algorithm has been changed to cater for arbitrary<br/>matrices. The<br/> * the rows are now in general linearly dependent.<br/> * We use the fact that the Gram Schmidt process detects the first<br/>row<br/> * which is a linear combination of the preceding rows. We employ a<br/>modification<br/> * of the LLL algorithm outlined by M. Pohst in J. Symbolic<br/>Computation (1987)4,<br/> * 123-127.  We call this the MLLL algorithm.<br/> * If we are using this algorithm to find small multipliers for the<br/>extended<br/> * gcd problem, GCDFLAG is set in IMPROVEP() and gcdflag is set below.<br/> * m1 / n1 is usually taken to be 3 / 4.<br/> * For use in IMPROVEP().<br/> */<br/>{<br/>&#x9;unsigned int i, k, n, m, t, flag = 0, Flag = 0, gcdflag = 0;<br/>&#x9;unsigned int flagg, beta, K1 = 0, tau = 2, sigma = 0, rho,<br/>norigg;<br/>&#x9;unsigned int K, j, REPEAT, iterate;<br/>&#x9;int l, tt;<br/>&#x9;MPI **D, *X, *Y, *Z, *H, *Tmp, *R, *M1, *N1;<br/>&#x9;MPI *t1, *t2, *t3, *t4;<br/>&#x9;MPMATI *C, *L, *B1ptr, *temp1;</p><p>&#x9;Z = NULL;<br/>&#x9;m = Bptr-&gt;C;<br/>&#x9;norigg = n = Bptr-&gt;R;<br/>&#x9;B1ptr = COPYMATI(Bptr);<br/>&#x9;D = (MPI **)mmalloc((1 + n) * sizeof(MPI *));<br/>&#x9;D[0] = ONEI();<br/>&#x9;for (i = 1; i &lt;= n; i++)<br/>&#x9;&#x9;D[i] = ZEROI();<br/>&#x9;C = ZEROMNI(n, m);<br/>&#x9;L = ZEROMNI(n, n);</p><p>&#x9;found:<br/>&#x9;n = B1ptr-&gt;R;<br/>&#x9;i = (K1 == 0) ? 1 : K1;<br/>&#x9;/* K1 = no. of consecutive rows of *B1ptr that don&apos;t need<br/>updating<br/>for the Gram Schmidt process. */<br/>&#x9;while (i &lt;= B1ptr-&gt;R)<br/>&#x9;{<br/>&#x9;&#x9;BASIS_UPDATE(i, m, &amp;C, &amp;L, B1ptr, D);<br/>&#x9;&#x9;flag = 1;<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;if (!EQZEROI(C-&gt;V[i - 1][t]))<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;}&#x9;<br/>&#x9;&#x9;if (flag)<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;X = ZEROI();<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;H = MULTI(C-&gt;V[i - 1][t], C-&gt;V[i - 1][t]);<br/>&#x9;&#x9;&#x9;Tmp = X;<br/>&#x9;&#x9;&#x9;X = ADDI(X, H);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(H);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;&#x9;D[i] = INT(X, D[i - 1]);&#x9;<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;i++;<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;printf(&quot;i = %u\n&quot;, i);<br/>&#x9;}<br/>/*<br/>&#x9;strcpy(buff, &quot;L.out&quot;);<br/>&#x9;outfile = fopen(buff, &quot;w&quot;);<br/>&#x9;FPRINTMATI(outfile,0,L-&gt;R-1,0,L-&gt;C-1,L);<br/>&#x9;fclose(outfile);<br/>&#x9;for (t = 0;t &lt; B1ptr-&gt;R; t++){<br/>&#x9;&#x9;printf(&quot;D[%u] = &quot;, t);PRINTI(D[t]);printf(&quot;\n&quot;);<br/>&#x9;}<br/>&#x9;GetReturn();<br/>*/<br/>&#x9;beta =  (flag) ? i : i - 1;<br/>&#x9;rho = K1 = i - 1;<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;printf(&quot;completed updating the basis\n&quot;);<br/>/* Here K1 = no. of LI rows in *B1ptr found by Gram Schmidt process.<br/>   flag = 0 means all the rho = beta rows of *B1ptr are LI;<br/>   flag = 1 means that the first rho = beta - 1 rows of *B1ptr are<br/>LI, but the<br/>   beta-th row is a LC of the preceding rows. So beta = number of<br/>rows of *B1ptr<br/>   currently being examined by the LLL algorithm. */<br/>&#x9;k = tau;<br/>&#x9;M1 = CHANGE(m1);<br/>&#x9;N1 = CHANGE(n1);<br/>&#x9;while (k &lt;= beta)<br/>&#x9;{<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;printf(&quot;beta - k = %u\n&quot;, beta -k);<br/>&#x9;&#x9;if (gcdflag)<br/>&#x9;&#x9;&#x9;l = norig;<br/>&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;l = k - 1;<br/>&#x9;&#x9;Flag = STEP40(k, l, &amp;L, &amp;B1ptr, D);<br/>&#x9;&#x9;if (k &gt; norig &amp;&amp; GCDFLAG)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;gcdflag = 1;<br/>&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;printf(&quot;improving row %u\n&quot;, k);<br/>&#x9;&#x9;&#x9;goto FOUND;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;if (Flag)/* STEP 9 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;printf(&quot;relation vector number %u<br/>found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;goto found;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[k - 2], D[k]);<br/>&#x9;&#x9;Y = MULTI(D[k - 1], D[k - 1]);<br/>&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;Y = MULT_I(Y, m1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;R = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k - 2]);<br/>&#x9;&#x9;Z = ADD0I(X, R);<br/>&#x9;&#x9;Tmp = Z;<br/>&#x9;&#x9;Z = MULT_I(Z, n1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;if (RSV(Y, Z) == 1)/*&amp; STEP 5 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flagg = 0;<br/>&#x9;&#x9;&#x9;if (EQZEROI(D[k]) &amp;&amp; EQZEROI(R))<br/>&#x9;&#x9;&#x9;{/* CASE B=0 of STEP 7 of POHST. */<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(D[k - 1]);<br/>&#x9;&#x9;&#x9;&#x9;D[k - 1] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;STEP80(k, &amp;B1ptr, &amp;L);<br/>&#x9;&#x9;&#x9;&#x9;if (k - 1 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;K1 = k - 1;<br/>&#x9;&#x9;&#x9;&#x9;/* The swap may have changed 2nd last<br/>row */<br/>&#x9;&#x9;&#x9;&#x9;/* of *B1ptr. */<br/>&#x9;&#x9;&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(C-&gt;V[k - 2][t]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;C-&gt;V[k - 2][t] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;beta--;<br/>&#x9;&#x9;&#x9;&#x9;flagg = 1;<br/>&#x9;&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;continue;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;if (flagg == 0)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;for (i = k + 1; i &lt;= beta; i++)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;STEP7(i, k, &amp;L, D);<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;STEP80(k, &amp;B1ptr, &amp;L);<br/>&#x9;&#x9;&#x9;if (k - 2 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;K1 = k - 2;<br/>&#x9;&#x9;&#x9;/* swap will change last two rows of *B1ptr.<br/>*/<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;Y = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k -<br/>2]);<br/>&#x9;&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;&#x9;Y = ADD0I(Y, X);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;Tmp = D[k - 1];<br/>&#x9;&#x9;&#x9;D[k - 1] = INT0(Y, D[k - 1]);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;else<br/>&#x9;&#x9;{ /* STEP 6 of POHST. */<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>FOUND:<br/>&#x9;&#x9;&#x9;if (gcdflag)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;gcdflag set\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;K = norig + 1;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;&#x9;K = k;<br/>&#x9;&#x9;&#x9;for (l = K - 2; l &gt;= 1; l--)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;Flag = &#x9;STEP40(k, l, &amp;L, &amp;B1ptr, D);<br/>&#x9;&#x9;&#x9;&#x9;if (Flag)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;relation<br/>vector number %u found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;goto found; /* STEP 9 of<br/>POHST. */<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;k++;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;if (!gcdflag)<br/>&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;}<br/>&#x9;FREEMPI(M1);<br/>&#x9;FREEMPI(N1);<br/>&#x9;FREEMATI(C);<br/>&#x9;FREEMATI(L);<br/>&#x9;for (i = 0; i &lt;= norigg; i++)<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;ffree((char *)D, (1 + norigg) * sizeof(MPI *));<br/>&#x9;/* Now to improve the last n - norig rows of *B1ptr, using<br/>Gauss<br/>lattice reduction - pointed out by George Havas in Sims&apos; book -<br/>8/11/94: */</p><p>/*<br/>&#x9;strcpy(buff, &quot;progress&quot;);<br/>&#x9;outfile = fopen(buff, &quot;a+&quot;);<br/>&#x9;FPRINTMATI(outfile,0,B1ptr-&gt;R-1,0,B1ptr-&gt;C-1,B1ptr);<br/>*/</p><p>&#x9;REPEAT = 1;<br/>&#x9;temp1 = BUILDMATI(1, B1ptr-&gt;C);<br/>&#x9;for (k = 0; k &lt; B1ptr-&gt;C; k++)<br/>&#x9;&#x9;temp1-&gt;V[0][k] = ZEROI();<br/>&#x9;iterate = 0;<br/>&#x9;QSORTMATI(B1ptr, 0, norig - 1);<br/>&#x9;while (REPEAT)<br/>&#x9;{<br/>&#x9;&#x9;REPEAT = 0;<br/>&#x9;&#x9;for (j = 1; j &lt; norig; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;t4 = DOTRI(B1ptr, j, j);<br/>&#x9;&#x9;&#x9;for (i = 0; i &lt; j; i++)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;t1 = DOTRI(B1ptr, j, i);<br/>&#x9;&#x9;&#x9;&#x9;t2 = DOTRI(B1ptr, i, i);<br/>&#x9;&#x9;&#x9;&#x9;t3 = NEAREST_INTI(t1, t2);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t1);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t2);<br/>&#x9;&#x9;&#x9;&#x9;if (t3-&gt;S == 0)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(t3);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;continue;<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;t1 = t3;<br/>&#x9;&#x9;&#x9;&#x9;t3 = MINUSI(t3);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t1);<br/>&#x9;&#x9;&#x9;&#x9;for (k = 0; k &lt; B1ptr-&gt;C; k++)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(temp1-&gt;V[0][k]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;X = MULTI(t3, B1ptr-&gt;V[i][k]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;temp1-&gt;V[0][k] = ADDI(X,<br/>B1ptr-&gt;V[j][k]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;t1 = DOTRI(temp1, 0, 0);<br/>&#x9;&#x9;&#x9;&#x9;tt = RSV(t1, t4);<br/>&#x9;&#x9;&#x9;&#x9;tt = RSV(t1, t4);<br/>&#x9;&#x9;&#x9;&#x9;if (tt == -1)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;ADD_MULT_ROWI0(i, j, t3,<br/>B1ptr);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;Gauss-<br/>improving nullspace row %u: length squared was = &quot;, j + 1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;PRINTI(t4);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;lengthsquared<br/>now = &quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;PRINTI(t1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;}<br/>/*<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf(outfile, &quot;Gauss-<br/>improving nullspace row %u: length squared was = &quot;, j + 1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FPRINTI(outfile, t4);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf(outfile, &quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf<br/>(outfile, &quot;lengthsquared now = &quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FPRINTI(outfile, t1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf(outfile, &quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fflush(outfile);<br/>*/<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(t4);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;t4 = t1;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;REPEAT = 1;<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(t1);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t3);<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t4);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;iterate++;<br/>&#x9;&#x9;QSORTMATI(B1ptr, 0, norig - 1);<br/>&#x9;}<br/>&#x9;REPEAT = 1;<br/>&#x9;iterate = 0;<br/>&#x9;while (REPEAT)<br/>&#x9;{<br/>&#x9;&#x9;REPEAT = 0;<br/>&#x9;&#x9;for (j = norig; j &lt; B1ptr-&gt;R; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;t4 = DOTRI(B1ptr, j, j);<br/>&#x9;&#x9;&#x9;for (i = 0; i &lt; norig; i++)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;t1 = DOTRI(B1ptr, j, i);<br/>&#x9;&#x9;&#x9;&#x9;t2 = DOTRI(B1ptr, i, i);<br/>&#x9;&#x9;&#x9;&#x9;t3 = NEAREST_INTI(t1, t2);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t1);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t2);<br/>&#x9;&#x9;&#x9;&#x9;if (t3-&gt;S == 0)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(t3);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;continue;<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;t1 = t3;<br/>&#x9;&#x9;&#x9;&#x9;t3 = MINUSI(t3);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t1);<br/>&#x9;&#x9;&#x9;&#x9;for (k = 0; k &lt; B1ptr-&gt;C; k++)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(temp1-&gt;V[0][k]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;X = MULTI(t3, B1ptr-&gt;V[i][k]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;temp1-&gt;V[0][k] = ADDI(X,<br/>B1ptr-&gt;V[j][k]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;t1 = DOTRI(temp1, 0, 0);<br/>&#x9;&#x9;&#x9;&#x9;tt = RSV(t1, t4);<br/>&#x9;&#x9;&#x9;&#x9;tt = RSV(t1, t4);<br/>&#x9;&#x9;&#x9;&#x9;if (tt == -1)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;ADD_MULT_ROWI0(i, j, t3,<br/>B1ptr);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;Gauss-<br/>improving row %u: length squared was = &quot;, j + 1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;PRINTI(t4);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;lengthsquared<br/>now = &quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;PRINTI(t1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;}<br/>/*<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf(outfile, &quot;Gauss-<br/>improving row %u: length squared was = &quot;, j + 1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FPRINTI(outfile, t4);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf(outfile, &quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf<br/>(outfile, &quot;lengthsquared now = &quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FPRINTI(outfile, t1);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fprintf(outfile, &quot;\n&quot;);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;fflush(outfile);<br/>*/<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(t4);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;t4 = t1;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;REPEAT = 1;<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(t1);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(t3);<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;FREEMPI(t4);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;iterate++;<br/>&#x9;}<br/>&#x9;FREEMATI(temp1);<br/>/*<br/>&#x9;fclose(outfile);<br/>*/<br/>&#x9;return (B1ptr);<br/>}</p><p>MPMATI *BASIS_REDUCTION000(MPMATI *Bptr, USI m1, USI n1, MPI *N)<br/>/*<br/> * Input: *Bptr, a matrix of MPI&apos;s, whose first row is not zero.<br/> * Output: a pointer to an MPMATI whose rows form a reduced basis for<br/> * the lattice spanned by the rows of *Bptr. This basis is reduced in<br/>the<br/> * sense of the paper &quot;Factoring polynomials with rational<br/>coefficients&quot; by<br/> * A. K. Lenstra, H. W. Lenstra and L. Lovasz, Math. Ann. 261, 515-<br/>534 (1982)<br/> * using the modified version in &quot;Solving exponential Diophantine<br/>equations<br/> * using lattice basis reduction algorithms&quot; by B. M. M. De Weger, J.<br/>No. Theory<br/> * 26, 325-367 (1987). No change of basis matrix is returned.<br/> * De Weger&apos;s algorithm has been changed to cater for arbitrary<br/>matrices. The<br/> * the rows are now in general linearly dependent.<br/> * We use the fact that the Gram Schmidt process detects the first<br/>row<br/> * which is a linear combination of the preceding rows. We employ a<br/>modification<br/> * of the LLL algorithm outlined by M. Pohst in J. Symbolic<br/>Computation (1987)4,<br/> * 123-127.  We call this the MLLL algorithm.<br/> * If we are using this algorithm to find small multipliers for the<br/>extended<br/> * gcd problem, GCDFLAG is set in EXTGCD() and gcdflag is set below.<br/> * m1 / n1 is usually taken to be 3 / 4.<br/> */<br/>{<br/>&#x9;unsigned int i, k, l, n, m, t, flag = 0, Flag = 0, gcdflag =<br/>0;<br/>&#x9;unsigned int flagg, beta, K1 = 0, tau = 2, sigma = 0, rho;<br/>&#x9;MPI **D, *X, *Y, *Z, *H, *Tmp, *R, *M1, *N1;<br/>&#x9;MPMATI *C, *L, *B1ptr;<br/>&#x9;unsigned int norig;</p><p>&#x9;Z = NULL;<br/>&#x9;m = Bptr-&gt;C;<br/>&#x9;n = Bptr-&gt;R;<br/>&#x9;norig = n;<br/>&#x9;B1ptr = COPYMATI(Bptr);<br/>&#x9;D = (MPI **)mmalloc((1 + n) * sizeof(MPI *));<br/>&#x9;D[0] = ONEI();<br/>&#x9;for (i = 1; i &lt;= n; i++)<br/>&#x9;&#x9;D[i] = ZEROI();<br/>&#x9;C = ZEROMNI(n, m);<br/>&#x9;L = ZEROMNI(n, n);</p><p>&#x9;found:<br/>&#x9;n = B1ptr-&gt;R;<br/>&#x9;i = (K1 == 0) ? 1 : K1;<br/>&#x9;/* K1 = no. of consecutive rows of *B1ptr that don&apos;t need<br/>updating<br/>for the Gram Schmidt process. */<br/>&#x9;while (i &lt;= B1ptr-&gt;R)<br/>&#x9;{<br/>&#x9;&#x9;BASIS_UPDATE(i, m, &amp;C, &amp;L, B1ptr, D);<br/>&#x9;&#x9;flag = 1;<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;if (!EQZEROI(C-&gt;V[i - 1][t]))<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;}&#x9;<br/>&#x9;&#x9;if (flag)<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;X = ZEROI();<br/>&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;H = MULTI(C-&gt;V[i - 1][t], C-&gt;V[i - 1][t]);<br/>&#x9;&#x9;&#x9;Tmp = X;<br/>&#x9;&#x9;&#x9;X = ADDI(X, H);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(H);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;&#x9;D[i] = INT(X, D[i - 1]);&#x9;<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;i++;<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;printf(&quot;i = %u\n&quot;, i);<br/>&#x9;}<br/>&#x9;beta =  (flag) ? i : i - 1;<br/>&#x9;rho = K1 = i - 1;<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;printf(&quot;completed updating the basis\n&quot;);<br/>/* Here K1 = no. of LI rows in *B1ptr found by Gram Schmidt process.<br/>   flag = 0 means all the rho = beta rows of *B1ptr are LI;<br/>   flag = 1 means that the first rho = beta - 1 rows of *B1ptr are<br/>LI, but the<br/>   beta-th row is a LC of the preceding rows. So beta = number of<br/>rows of *B1ptr<br/>   currently being examined by the LLL algorithm. */<br/>&#x9;k = tau;<br/>&#x9;M1 = CHANGE(m1);<br/>&#x9;N1 = CHANGE(n1);<br/>&#x9;while (k &lt;= beta)<br/>&#x9;{<br/>&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;printf(&quot;beta - k = %u\n&quot;, beta -k);<br/>&#x9;&#x9;l = k - 1;<br/>&#x9;&#x9;Flag = STEP4000(k, l, &amp;L, &amp;B1ptr, D, N);<br/>&#x9;&#x9;if (k &gt;= norig &amp;&amp; GCDFLAG)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;gcdflag = 1;<br/>&#x9;&#x9;&#x9;goto FOUND;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;if (Flag)/* STEP 9 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;printf(&quot;relation vector number %u<br/>found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;goto found;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[k - 2], D[k]);<br/>&#x9;&#x9;Y = MULTI(D[k - 1], D[k - 1]);<br/>&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;Y = MULT_I(Y, m1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;R = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k - 2]);<br/>&#x9;&#x9;Z = ADD0I(X, R);<br/>&#x9;&#x9;Tmp = Z;<br/>&#x9;&#x9;Z = MULT_I(Z, n1);<br/>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;if (RSV(Y, Z) == 1)/*&amp; STEP 5 of POHST. */<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flagg = 0;<br/>&#x9;&#x9;&#x9;if (EQZEROI(D[k]) &amp;&amp; EQZEROI(R))<br/>&#x9;&#x9;&#x9;{/* CASE B=0 of STEP 7 of POHST. */<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(D[k - 1]);<br/>&#x9;&#x9;&#x9;&#x9;D[k - 1] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;STEP8000(k, &amp;B1ptr, &amp;L, N);<br/>&#x9;&#x9;&#x9;&#x9;if (k - 1 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;K1 = k - 1;<br/>&#x9;&#x9;&#x9;&#x9;/* The swap may have changed 2nd last<br/>row */<br/>&#x9;&#x9;&#x9;&#x9;/* of *B1ptr. */<br/>&#x9;&#x9;&#x9;&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(C-&gt;V[k - 2][t]);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;C-&gt;V[k - 2][t] = ZEROI();<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;&#x9;beta--;<br/>&#x9;&#x9;&#x9;&#x9;flagg = 1;<br/>&#x9;&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;continue;<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;if (flagg == 0)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;for (i = k + 1; i &lt;= beta; i++)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;STEP7(i, k, &amp;L, D);<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;STEP8000(k, &amp;B1ptr, &amp;L, N);<br/>&#x9;&#x9;&#x9;if (k - 2 &lt; K1)<br/>&#x9;&#x9;&#x9;&#x9;K1 = k - 2;<br/>&#x9;&#x9;&#x9;/* swap will change last two rows of *B1ptr.<br/>*/<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;Y = MULTI(L-&gt;V[k - 1][k - 2], L-&gt;V[k - 1][k -<br/>2]);<br/>&#x9;&#x9;&#x9;Tmp = Y;<br/>&#x9;&#x9;&#x9;Y = ADD0I(Y, X);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;Tmp = D[k - 1];<br/>&#x9;&#x9;&#x9;D[k - 1] = INT0(Y, D[k - 1]);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>&#x9;&#x9;&#x9;if (k &gt; 2)<br/>&#x9;&#x9;&#x9;&#x9;k--;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;else<br/>&#x9;&#x9;{ /* STEP 6 of POHST. */<br/>&#x9;&#x9;&#x9;FREEMPI(R);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;&#x9;FREEMPI(Y);<br/>FOUND:<br/>&#x9;&#x9;&#x9;for (l = k - 2; l &gt;= 1; l--)<br/>&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;Flag = &#x9;STEP4000(k, l, &amp;L, &amp;B1ptr, D,<br/>N);<br/>&#x9;&#x9;&#x9;&#x9;if (Flag)<br/>&#x9;&#x9;&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;sigma++;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;if (MLLLVERBOSE)<br/>&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;relation<br/>vector number %u found\n&quot;, sigma);<br/>&#x9;&#x9;&#x9;&#x9;&#x9;tau = k++;<br/>&#x9;&#x9;&#x9;&#x9;&#x9;goto found; /* STEP 9 of<br/>POHST. */<br/>&#x9;&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;}<br/>&#x9;&#x9;&#x9;k++;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;if (!gcdflag)<br/>&#x9;&#x9;&#x9;FREEMPI(Z);<br/>&#x9;&#x9;else<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;}<br/>&#x9;FREEMPI(M1);<br/>&#x9;FREEMPI(N1);<br/>&#x9;FREEMATI(C);<br/>&#x9;FREEMATI(L);<br/>&#x9;for (i = 0; i &lt;= norig; i++)<br/>&#x9;&#x9;FREEMPI(D[i]);<br/>&#x9;ffree((char *)D, (1 + norig) * sizeof(MPI *));<br/>&#x9;if (MLLLVERBOSE)<br/>&#x9;{<br/>&#x9;&#x9;printf(&quot;number of basis vectors found = %u ;\n&quot;, rho);<br/>&#x9;&#x9;printf(&quot;number of relation vectors found = %u .\n&quot;,<br/>sigma);<br/>&#x9;}<br/>&#x9;return (B1ptr);<br/>}</p><p>unsigned int STEP4000(USI k, USI l, MPMATI **Lptr, MPMATI **Bptr, MPI<br/>*D[], MPI *N)<br/>/*<br/> * updates *Lptr, *Bptr.<br/> * returns 1 if row k of *Bptr becomes zero, returns zero otherwise.<br/> */<br/>{<br/>&#x9;unsigned int i,  j, flag = 1, t, m, n;<br/>&#x9;MPI *X, *Y, *R, *Tmp, *Temp;<br/>&#x9;MPMATI *TmpMATI;</p><p>&#x9;m = (*Bptr)-&gt;C;<br/>&#x9;Y = MULT_I((*Lptr)-&gt;V[k - 1][l - 1], 2);<br/>&#x9;if (RSV(Y, D[l]) == 1)<br/>&#x9;{<br/>&#x9;&#x9;R = NEAREST_INTI((*Lptr)-&gt;V[k - 1][l - 1], D[l]);<br/>&#x9;&#x9;X = MINUSI(R);<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = ADD_MULT_ROWI(l - 1, k - 1, X, *Bptr);<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>&#x9;n = (*Bptr)-&gt;R;<br/>&#x9;for (i = 0; i &lt; n; i++)<br/>&#x9;{<br/>&#x9;&#x9;for (j = n; j &lt; m; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;Temp = POWERI(N, m - j);<br/>&#x9;&#x9;&#x9;(*Bptr)-&gt;V[i][j] = INTI((*Bptr)-&gt;V[i][j],<br/>Temp);<br/>&#x9;&#x9;&#x9;FREEMPI(Temp);<br/>&#x9;&#x9;}<br/>&#x9;}<br/>&#x9;&#x9;if (HERMITEVERBOSE)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;printf(&quot;Row %u -&gt; Row %u + &quot;, k,k);PRINTI(X);printf(&quot;<br/>x Row %u\n&quot;, l);<br/>&#x9;&#x9;PRINTMATI(0,(*Bptr)-&gt;R-1,0,(*Bptr)-&gt;C-1,*Bptr);<br/>&#x9;&#x9;GetReturn();<br/>&#x9;&#x9;}<br/>&#x9;for (i = 0; i &lt; n; i++)<br/>&#x9;{<br/>&#x9;&#x9;for (j = n; j &lt; m; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;Temp = POWERI(N, m - j);<br/>&#x9;&#x9;&#x9;(*Bptr)-&gt;V[i][j] = MULTI((*Bptr)-&gt;V[i][j],<br/>Temp);<br/>&#x9;&#x9;&#x9;FREEMPI(Temp);<br/>&#x9;&#x9;}<br/>&#x9;}<br/>/*<br/>&#x9;&#x9;MAXI = UPDATEMAXI(MAXI, *Bptr);<br/>*/<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;for (j = 1; j &lt; l; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;X = MULTI((*Lptr)-&gt;V[l - 1][j - 1], R);<br/>&#x9;&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][j - 1];<br/>&#x9;&#x9;&#x9;(*Lptr)-&gt;V[k - 1][j - 1] = SUBI((*Lptr)-&gt;V[k -<br/> 1][j - 1], X);<br/>&#x9;&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;}<br/>&#x9;&#x9;X = MULTI(D[l], R);<br/>&#x9;&#x9;Tmp = (*Lptr)-&gt;V[k - 1][l - 1];<br/>&#x9;&#x9;(*Lptr)-&gt;V[k - 1][l - 1] = SUBI((*Lptr)-&gt;V[k - 1][l -<br/>1], X);</p><p>&#x9;&#x9;FREEMPI(Tmp);<br/>&#x9;&#x9;FREEMPI(X);<br/>&#x9;&#x9;FREEMPI(R);<br/>&#x9;}<br/>&#x9;for (t = 0; t &lt; m; t++)<br/>&#x9;{<br/>&#x9;&#x9;if (!EQZEROI((*Bptr)-&gt;V[k - 1][t]))<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;flag = 0;&#x9;<br/>&#x9;&#x9;&#x9;break;<br/>&#x9;&#x9;}<br/>&#x9;}&#x9;<br/>&#x9;if (flag)<br/>&#x9;{<br/>&#x9;&#x9;TmpMATI = *Bptr;<br/>&#x9;&#x9;*Bptr = DELETE_ROWI(k, *Bptr);<br/>&#x9;&#x9;FREEMATI(TmpMATI);<br/>&#x9;}<br/>&#x9;FREEMPI(Y);<br/>&#x9;return (flag);<br/>}<br/>void STEP8000(USI k, MPMATI **B1ptr, MPMATI **Lptr, MPI *N)<br/>{<br/>&#x9;MPI *T, *Temp;<br/>&#x9;USI i, j, n, m;</p><p>&#x9;*B1ptr = SWAP_ROWSI1(k - 2, k - 1, *B1ptr);<br/>&#x9;T = COPYI((*Lptr)-&gt;V[k - 1][k - 2]);<br/>&#x9;*Lptr = SWAP_ROWSI1(k - 2, k - 1, *Lptr);<br/>&#x9;FREEMPI((*Lptr)-&gt;V[k - 1][k - 2]);<br/>&#x9;(*Lptr)-&gt;V[k - 1][k - 2] = T;<br/>&#x9;FREEMPI((*Lptr)-&gt;V[k - 2][k - 2]);<br/>&#x9;(*Lptr)-&gt;V[k - 2][k - 2] = ZEROI();</p><p>&#x9;n = (*B1ptr)-&gt;R;<br/>&#x9;m = (*B1ptr)-&gt;C;<br/>&#x9;for (i = 0; i &lt; n; i++)<br/>&#x9;{<br/>&#x9;&#x9;for (j = n; j &lt; m; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;Temp = POWERI(N, m - j);<br/>&#x9;&#x9;&#x9;(*B1ptr)-&gt;V[i][j] = INTI((*B1ptr)-&gt;V[i][j],<br/>Temp);<br/>&#x9;&#x9;&#x9;FREEMPI(Temp);<br/>&#x9;&#x9;}<br/>&#x9;}<br/>&#x9;if (HERMITEVERBOSE)<br/>&#x9;{<br/>&#x9;&#x9;printf(&quot;Swapping Rows %u and %u\n&quot;, k-1,k);<br/>&#x9;&#x9;PRINTMATI(0,(*B1ptr)-&gt;R-1,0,(*B1ptr)-&gt;C-1,*B1ptr);<br/>&#x9;&#x9;GetReturn();<br/>&#x9;}<br/>&#x9;for (i = 0; i &lt; n; i++)<br/>&#x9;{<br/>&#x9;&#x9;for (j = n; j &lt; m; j++)<br/>&#x9;&#x9;{<br/>&#x9;&#x9;&#x9;Temp = POWERI(N, m - j);<br/>&#x9;&#x9;&#x9;(*B1ptr)-&gt;V[i][j] = MULTI((*B1ptr)-&gt;V[i][j],<br/>Temp);<br/>&#x9;&#x9;&#x9;FREEMPI(Temp);<br/>&#x9;&#x9;}<br/>&#x9;}</p><p>&#x9;return;<br/>}</p></div>