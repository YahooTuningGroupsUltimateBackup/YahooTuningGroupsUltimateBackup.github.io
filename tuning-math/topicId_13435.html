<a href="/tuning-math">back to list</a><h1>TOP vs prime-RMS benchmarks and code</h1><h3><a id=13435 href="#13435">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>11/20/2005 7:03:07 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I&apos;ve written and tested a plain-Python algorithm for TOP now.  It&apos;s<br/>not the optimal (it looks at n*n points where Gene only suggests<br/>n*(n-1)/2) but isn&apos;t much more complicated than the prime-RMS version<br/>(17 lines against 12).  The TOP is running more than an order of<br/>magnitude slower and I don&apos;t think tweaks to the algorithm will change<br/>that.  Of course, if you have better code, I can try it.  Here are the<br/>results then, for getting the optimal error for the prime mappings of<br/>all equal temperaments with 10 to 99 steps:</p><p> 5-limit RMS in   6.8ms<br/> 5-limit TOP in  65.3ms<br/> 7-limit RMS in   8.3ms<br/> 7-limit TOP in 132.0ms<br/>11-limit RMS in   9.5ms<br/>11-limit TOP in 232.7ms<br/>13-limit RMS in  10.4ms<br/>13-limit TOP in 369.7ms<br/>17-limit RMS in  11.5ms<br/>17-limit TOP in 556.2ms<br/>19-limit RMS in  13.2ms<br/>19-limit TOP in 811.0ms</p><p>The updated code should be at <a href="http://www.microtonal.co.uk/temper.py">http://www.microtonal.co.uk/temper.py</a><br/>now.  I&apos;ll copy the relevant methods here -- remember that Yahoo<br/>removes the indentation for web viewing.</p><p>There will be faster algorithms, but there&apos;s always a speed penalty<br/>for that.  The only way I can currently do linear temperaments uses a<br/>library that prints out logging info so there wouldn&apos;t be a fair<br/>comparison.  Nobody likes that method anyway.</p><p>Oh yes, I noticed a bug in the PORMSWE stuff.  The step and stretch<br/>methods were mixed up, and one was garbage.  So if anybody was using<br/>that, update!</p><p>  def getPORMSWE(self):<br/>    &quot;&quot;&quot;Return the prime, optimum, RMS, weighted error.</p><p>    This is the RMS of the prime intervals where octave stretching<br/>    is allowed, with each prime interval weighted according to its size.<br/>    &quot;&quot;&quot;<br/>    avgStretches, avgSquares = self.getPrimeStretching()<br/>    return sqrt(1.0 - (avgStretches**2 / avgSquares))</p><p>  def getPORMSWEStep(self):<br/>    &quot;&quot;&quot;Return the stretched step size<br/>       for the prime, optimum, RMS, weighted error.<br/>    &quot;&quot;&quot;<br/>    return self.getPORMSWEStretch() / self.basis[0]</p><p>  def getPORMSWEStretch(self):<br/>    &quot;&quot;&quot;Return the stretch for the prime, optimum, RMS, weighted error.<br/>    &quot;&quot;&quot;<br/>    avgStretches, avgSquares = self.getPrimeStretching()<br/>    return avgStretches / avgSquares</p><p>  def getPrimeStretching(self):<br/>    &quot;&quot;&quot;Used by getPORMSWE() and getPORMSWEStretch().<br/>    Not likely to be much use on its own.<br/>    &quot;&quot;&quot;<br/>    sumStretches = sumSquares = 0.0<br/>    for stretch in self.weightedPrimes():<br/>        sumStretches = sumStretches + stretch<br/>        sumSquares = sumSquares + stretch**2<br/>    return sumStretches/len(self.basis), sumSquares/len(self.basis)</p><p>  def getTOPError(self, stretch):<br/>    &quot;&quot;&quot;TOP Error for a given octave stretch (non-optimal)&quot;&quot;&quot;<br/>    worst = 0.0<br/>    for w in self.weightedPrimes():<br/>      w = w*stretch<br/>      if abs(1-w)&gt;worst:<br/>        worst = abs(1-w)<br/>    return worst</p><p>  def getTOP(self):<br/>    &quot;&quot;&quot;Return the TOP error and the optimum stretch&quot;&quot;&quot;<br/>    best, bestStretch = 1e50, 1.0<br/>    for prime1 in self.weightedPrimes():<br/>      for prime2 in self.weightedPrimes():<br/>        stretch = prime1/prime2<br/>        error = self.getTOPError(stretch)<br/>        if error &lt; best:<br/>          best = error<br/>          bestStretch = stretch<br/>    return best, bestStretch</p><p>  def weightedPrimes(self):<br/>    &quot;&quot;&quot;Used for calculating and optimizing weighted prime errors&quot;&quot;&quot;<br/>    result = [1.0]<br/>    for i in range(1,len(self.basis)):<br/>      result.append(self.basis[i]/self.primes[i-1]/self.basis[0])<br/>    return result</p><p>And here, for reference, is the benchmarking code:</p><p>import temper, time<br/>limits = 1, 3, 5, 7, 11, 13, 17, 19<br/>for d in range(2,8):<br/>    ets = [temper.PrimeET(n, temper.primes[:d]) for n in range(10,100)]<br/>    timestamp = time.time()<br/>    for n in range(1000):<br/>        for et in ets:<br/>            et.getPORMSWE()<br/>    print &quot;%2i-limit RMS in %5.1fms&quot; % (limits[d], time.time()-timestamp)<br/>    timestamp = time.time()<br/>    for n in range(1000):<br/>        for et in ets:<br/>            et.getTOP()<br/>    print &quot;%2i-limit TOP in %5.1fms&quot; % (limits[d], time.time()-timestamp)</p><p>                                  Graham</p></div>