<a href="/tuning-math">back to list</a><h1>Regular temperament invariant</h1><h3><a id=16670 href="#16670">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/7/2007 4:08:37 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>We know that the wedge product of a regular temperament class works as a unique key that doesn&apos;t depend on the exact tuning or the equal temperament mappings or unison vectors used to define it.  As a bivector, the wedge product can be written as:</p><p>T[i][j] = A[i]*B[j] - A[j]*B[i]</p><p>where T is the wedge product, A and B are equal temperament mappings, A[i] is the ith component of a, and so on.  From the definition of a wedge product, we know</p><p>T[i][j] == T[j][i] and T[i][i] == 0</p><p>Usually we don&apos;t show the redundant entries.  But today I&apos;ll think of it as a list of lists.  The first entry, T[0] (I&apos;m counting octaves as 0) is the usual generator mapping (times the number of periods per octave).  The simplest invariant for the temperament is T[0] with the first entry (which we know to be zero) removed.  This works pretty well, but doesn&apos;t identify a unique temperament class.  There are very few examples where two temperament classes with the same T[0] make the top 100 of my searches.  But still, it would be nice to distinguish them.</p><p>(You can also think of the T[i] as mappings for things like equal temperaments where the ith prime is a thing like a unison vector.  But most people round here don&apos;t like thinking that way.)</p><p>The full wedge product is unique, but the problem is that it gets big.  In practice it does slow down the calculation considerably for high prime limits.  The size is roughly quadratic in the number of prime dimensions.  It&apos;s exactly the third entry in Pascal&apos;s triangle.  We already know that some elements are redundant but I&apos;ve never been clear how many or how to remove them.</p><p>An alternative is to take T[0] and T[1] as the invariant. As we know T[0][0]==T[1][1]==0 and T[0][1]==-T[1][0], that leaves only 2n-3 elements for n prime dimensions.  These happen to be the first 2n-3 elements of the wedgie as we usually write it.  (You have to standardize the sign either way.)</p><p>Most of the time this has all the information the wedge product has.  It doesn&apos;t tell us which melodic pattern was intended for a contorted temperament because neither does the wedge product.</p><p>It&apos;s fairly easy to construct the full wedge product from T[0] and T[1].  All you do is pretend that T[0] and T[1] are equal temperament mappings and calculate the wedge product of the temperament that includes them both.  This will give some integer multiple of the correct wedge product.</p><p>It&apos;s easy to remove torsion because you know what a lot of the entries are supposed to be, so you know what factor to divide by.</p><p>A bigger problem is when the wedge product comes out multiplied by zero.  This happens when T[0] and T[1] are collinear.  An example is mystery temperament:</p><p>&lt;29, 46, 67, 81, 100] &amp; &lt;58, 92, 135, 163, 201]</p><p>The full wedgie is</p><p>&lt;&lt;0, 29, 29, 29, 46, 46, 46, -14, -33, -1]]</p><p>Truncating it gives</p><p>&lt;&lt;0, 29, 29, 29, 46, 46, 46]]</p><p>hence</p><p>T[0] = &lt;0, 0, 29, 29, 29]<br/>T[1] = &lt;0, 0, 46, 46, 46]</p><p>This plainly can&apos;t define a temperament because the primes 2 and 3 will always map to unisons.  The solution is to replace T[1] with T[i] where i is the smallest number where T[0][i] is non-zero.  In this case, i is 2.</p><p>T[0] = &lt;0, 0, 29, 29, 29]<br/>T[2] = &lt;-29, -46, 0, -14, -33]</p><p>Removing the redundant elements gives an invariant</p><p>&lt;&lt;0, 29, 29, 29, -46, -14, -33]]</p><p>(Maybe another rule would make the signs agree with a subset of the wedgie.  But never mind.)</p><p>It is possible to reconstruct the wedgie from invariants such as this.  There are always i-1 zero entries at the start.  So you can tell here that i is 2 and we need T[2] instead of T[1].</p><p>This invariant is more efficient to calculate and use as a unique key than the full wedge product.  The other thing I still use wedgies for is checking contorsion.  There&apos;s a fairly simple check in that if the invariant has no common factor there&apos;s no contorsion.  That follows from the elements of the invariant being a subset of the elements of the wedge product.</p><p>It is possible for the invariant to have a common factor without there being contorsion.  That&apos;s because one step in calculating the wedgie from the invariant is to divide through by an erroneous common factor.  There may still be a clever way to check contorsion using the invariant but I don&apos;t know how to do it because I don&apos;t really understand contorsion.</p><p>I want to get a general smallest invariant for regular temperaments in general.  It should have something to do with the wedge product, and have fewer than r*d elements for a rank r dimension d temperament.</p><p>                    Graham</p><p>p.s. To be precise about this, here&apos;s the Python code I used to check it.  It uses files from <a href="http://x31eq.com/temper/regular.zip">http://x31eq.com/temper/regular.zip</a></p><p>import regular_wedgie<br/>from math import sqrt</p><p>def invariant(ets):<br/>    map0, mapi = reduce_mappings(ets)<br/>    assert map0[0]==0<br/>    del map0[0]<br/>    i = map0.index(-mapi[0])<br/>    del mapi[0]<br/>    assert mapi[i]==0<br/>    del mapi[i]<br/>    return tuple(normalize_sign(map0+mapi))</p><p>def expand(reduced_wedgie):<br/>    n_dimensions = (len(reduced_wedgie) + 3)/2<br/>    map0 = (0,)+reduced_wedgie[:n_dimensions-1]<br/>    mapi = [0,0]+list(reduced_wedgie[n_dimensions-1:])<br/>    i = 1<br/>    while map0[i]==0:<br/>        mapi[i] = mapi[i+1]<br/>        i += 1<br/>    mapi[0] = -map0[i]<br/>    mapi[i] = 0<br/>    raw = wedgie((map0, mapi))<br/>    torsion = raw[i-1]/map0[i]<br/>    return tuple([x/torsion for x in raw])</p><p>def reduce_mappings(ets):<br/>    map0 = mapping_without_i(ets, 0)<br/>    i=1<br/>    while map0[i]==0:<br/>        i += 1<br/>    return map0, mapping_without_i(ets, i)</p><p>def wedgie(ets):<br/>    return tuple(normalize_sign(regular_wedgie.wedgie(ets)))</p><p>def check_match(ets):<br/>    direct = invariant(ets)<br/>    direct_wedgie = wedgie(ets)<br/>    reduced = reduce_mappings(ets)<br/>    i = 1<br/>    while reduced[0][i] == 0:<br/>        i += 1<br/>    assert reduced[0][0] == reduced[1][i] == 0<br/>    assert reduced[0][i] == -reduced[1][0]<br/>    assert direct_wedgie == expand(direct)<br/>    if regular_wedgie.hcf(direct)==1:<br/>        assert regular_wedgie.hcf(direct_wedgie)==1<br/>    if i==1:<br/>        assert direct == direct_wedgie[:len(direct)]<br/>        assert direct == tuple(<br/>            normalize_sign(reduced[0][1:] + reduced[1][2:]))</p><p>def mapping_without_i((et1, et2), i):<br/>    assert len(et1)==len(et2)<br/>    return [et1[i]*et2[j] - et1[j]*et2[i]<br/>            for j in range(len(et1))]</p><p>def normalize_sign(mapping):<br/>    nonzeros = [m for m in mapping if m]<br/>    if nonzeros==[] or nonzeros[0]&gt;0:<br/>        return mapping<br/>    return [-m for m in mapping]</p><p>def checks(primes, cutoff=0.17, nETs=20, rank=2):<br/>    cutoff /= sqrt(len(primes))<br/>    ets = regular_wedgie.getEqualTemperaments(<br/>            primes, nETs=nETs, cutoff=cutoff)<br/>    for set in regular_wedgie.combinations(rank, ets):<br/>        check_match(set)</p></div>