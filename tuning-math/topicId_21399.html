<a href="/tuning-math">back to list</a><h1>Max-Variety-3 Scales, and a Conjecture</h1><h3>domeofatonement@...</h3><span>5/7/2014 8:35:39 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I have a conjecture about max-variety-3 scales.  Check out keenan&apos;s post on tuning math for basic background information:<br/> <a href="https://groups.yahoo.com/neo/">https://groups.yahoo.com/neo/</a> groups/tuning-math/ conversations/topics/19334 <a href="https://groups.yahoo.com/neo/groups/tuning-math/conversations/topics/19334">https://groups.yahoo.com/neo/groups/tuning-math/conversations/topics/19334</a></p><p> It is possible to uniquely specify a max-variety-2 scale by listing multiplicities of steps (let&apos;s call these stencils).  For example, the stencil (5, 2) uniquely corresponds to the structure [aabaaab].</p><p> With max-variety-3 (&quot;MV3&quot; from here on) scales this luxury is simply not possible.  For instance, the stencil (2, 2, 1) can either be [abcba] or [abcab].  Therefore some stencils can represent more than one structure.  Let us call these ambistencils, because they are ambiguous.</p><p> Conjecture:<br/> (2, 2, 1) is the only MV3 ambistencil with a prime number of notes.</p><p> Corollary #1:<br/> Every MV3 ambistencil besides (2, 2, 1) has a factor which divides all of the multiplicities of each step size, (assuming that the repetitions of (1, 2, 4) can never be ambistencils).</p><p> Corollary #2: (not completely sure if this is a corollary?)</p><p> (2, 2, 1) is the only MV3 ambistencil with a step size that only appears once.</p><p> Ryan Avella</p></div><h3>gedankenwelt94@...</h3><span>5/17/2014 11:19:43 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Ryan,</p><p> thanks for sharing your observations! I found them very insightful,<br/> and they inspired me to continue investigating MV3 scales again. :)</p><p> What I don&apos;t understand is how corollary #1 follows from the conjecture.<br/> On the contrary, I can clearly see how corollary #1 implies the conjecture.<br/> So maybe &quot;corollary #1&quot; should be a conjecture, and the &quot;conjecture&quot;<br/> a corollary that follows from it?</p><p> In addition, I don&apos;t see why the assumption in corollary #1 about repetitions<br/> of (1, 2, 4) should be relevant:<br/> If they can be ambistencils, then corollary #1 makes a correct statement about<br/> them, and if they can&apos;t, corollary #1 doesn&apos;t make a statement about them at all,<br/> so it shouldn&apos;t matter.</p><p> Does this make sense, or did I make an error in reasoning?</p><p> - Geddy</p></div><h3>gedankenwelt94@...</h3><span>5/25/2014 6:46:06 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I think I might have found an algorithm that generates MV3 scales. I still have to test if the results are completely consistent with the list of MV3 scales with up to 31 notes, and some proofs will have to be made, but even if there are flaws, I think it makes for a useful basis.</p><p> Beforehand a definition, and some consequences concerning stencils (1) and ambistencils (2) if the algorithm actually reliably generates all MV3 scales:</p><p> Definition:<br/> A stencil is a triple (x, y, z) with integers x &gt;= y &gt;= z &gt; 0, where x, y and z represent multiplicities of the three different step sizes a, b and c. Because a, b and c are not specified, scale patterns with those letters interchanged are equivalent.<br/> |(x, y, z)| is the number of the scale patterns associated with (x, y, z) that represent a class of MV3 scales.<br/> Examples:<br/> (i) |(3, 2, 1)| = 0 (no MV3 scales)<br/> (ii) |(1, 1, 1)| = 1 (single MV3 scale pattern =&gt; not an ambistencil)<br/> (iii) |(2, 2, 1)| = 2 (two MV3 scale patterns =&gt; an ambistencil)</p><p> 1) Keenan&apos;s conjecture 1:<br/> |(x, y, z)| &gt;= 1 if and only if one of the following applies:<br/> (i) x = y<br/> (ii) y = z<br/>(iii) (x, y, z) is a multiple of (4, 2, 1)</p><p> 2) Ambistencils:<br/> |(x, y, z)| &gt;= 2 if and only if one of the following applies:<br/> (i) (x, y, z) = (2, 2, 1)<br/> (ii) x = y = z &gt;= 2<br/> (iii) x = y, gcd(y, z) &gt; 1, and gcd(2y, z) divides y<br/> (iv) y = z, gcd(x, y) &gt; 1, and gcd(x, 2y) divides y</p><p> Notice that 2) (iii) and (iv) can be combined as following:<br/> (x = y or y = z), gcd(y, n) &gt; 1, and gcd(2y, n) divides y, where n := x+y+z</p><p> =============================================</p><p> The (rough) algorithm for a given stencil (x, y, z):</p><p> if (x, y, z) is a multiple of (4, 2, 1), return repetition of &apos;aabacab&apos;, and exit<br/> if x = y {<br/> - if (x, y, z) is a multiple of (2, 2, 1), return repetition of &apos;aabcb&apos;<br/> - if y = z, generate and return patterns of type 1 (instructions follow), and exit<br/> - generate and return patterns of type 2 (instructions follow), and exit<br/> }<br/> if y = z, generate and return patterns of type 3 (instructions follow)</p><p> Generating patterns of type 1 to 3:</p><p> Type 1: (y, y, y)<br/> -----------------------<br/> Generate all words over the alphabet {&apos;d&apos;, &apos;e&apos;, &apos;[&apos;, &apos;]&apos;} with a word length of y, using the following rules:</p><p>Start: {&apos;d&apos;, &apos;[]&apos;}<br/>&apos;[]&apos; -&gt; &apos;[][]&apos;<br/> &apos;[]&apos; -&gt; &apos;[e]&apos;<br/>&apos;][&apos; -&gt; &apos;]d[&apos;<br/>&apos;d&apos; -&gt; &apos;dd&apos;, &apos;e&apos; -&gt; &apos;ee&apos;</p><p> ...where:</p><p> &apos;[&apos; := &apos;aba&apos;<br/> &apos;]&apos; := &apos;cbc&apos;</p><p> &apos;d&apos; := &apos;abc&apos; &apos;e&apos; := &apos;cba&apos;</p><p> ...so valid words are either repetitions of &apos;d&apos;, or consist of alternating pairs of square brackets that may contain any number of &apos;e&apos;s, or which may be adjacent to any number of &apos;d&apos;s.</p><p> Then, remove &quot;duplicates&quot;, i.e. words that (or whose reflections) are translation-symmetric to a previously generated word.<br/> Note: When mirroring a word, &apos;[&apos; and &apos;]&apos; stay as they are, and &apos;d&apos; and &apos;e&apos; are interchanged.<br/> Also, don&apos;t forget that interchanging a, b and c is always allowed, so &apos;ddd&apos; and &apos;eee&apos; are the same!</p><p> Example: The resulting words for (7, 7, 7), after removing duplicates, are:<br/> &apos;[eeeee]&apos;, &apos;[eeee]d&apos;, &apos;[eee][]&apos;, &apos;[eee]dd&apos;, &apos;[ee][e]&apos;, &apos;[ee][]d&apos;, &apos;[ee]d[]&apos;, &apos;[e][e]d&apos;, &apos;[e][][]&apos;, &apos;ddddddd&apos;</p><p> Which become: &apos;abacbacbacbacbacbacbc&apos;, &apos;abacbacbacbacbacbcabc&apos;, ...</p><p> Type 2: (y, y, z), y != z, excluding repetitions of (2, 2, 1)<br/> -----------------------<br/> Step 1: (generate primary pattern)<br/> - create MOS pattern with 2y steps &apos;#&apos;, and z steps &apos;c&apos;<br/> - replace the &apos;#&apos;s alternately with &apos;a&apos; and &apos;b&apos;</p><p> Example 1:<br/> For (5, 5, 3), the (10, 3)-MOS pattern is &apos;####c###c###c&apos;. By inserting &apos;a&apos; and &apos;b&apos; alternately, it becomes &apos;ababcabacbabc&apos;.</p><p> Example 2:<br/> For (6, 6, 3), the (12, 3)-MOS pattern is &apos;####c####c####c&apos;, which gives &apos;ababcababcababc&apos;.</p><p> Step 2: (derive other patterns, if possible)<br/> - if gcd(y, z) = 1 or gcd(2y, z) doesn&apos;t divide y, exit<br/> (I&apos;m pretty uncertain about the following part...)<br/> - start with the MOS pattern (the one with &apos;#&apos;s and &apos;c&apos;s), fix one &apos;c&apos;, and swap any other &apos;c&apos; with an adjacent &apos;#&apos; (only one swap per &apos;c&apos;, same direction for all &apos;c&apos;s). Resulting patterns are valid, if either<br/> a) there the chains of &apos;#&apos;s in the original MOS pattern have two distinct lengths, and the chains in the resulting patterns have the same lengths, or<br/> b) if all chains of &apos;#&apos;s in the original MOS pattern are of equal length l, and no chain in the resulting pattern is longer than l+1 or shorter than l-1. - remove duplicates (translational equivalent patterns)<br/> - insert &apos;a&apos;s and &apos;b&apos;s in the remaining valid patterns, as described in step 1</p><p> Example 1 (continued):<br/> For (5, 5, 3), gcd(y=5, z=3) = 1, so no further patterns exist for this stencil.</p><p> Example 2 (continued):<br/> For (6, 6, 3), gcd(y=6, z=3) != 1, and gcd(2y=12, z=3) = 3 divides y=6, so there are further patterns. If we fix the rightmost &apos;c&apos; in &apos;####c####c####c&apos;, we can swap the first, the second, or both &apos;c&apos;s with it&apos;s right neighbour. The results are &apos;#####c####c###c&apos;, &apos;#####c###c####c&apos; and &apos;####c#####c###c&apos;, all of which are valid, though the third one is translationally equivalent to the second one, and therefore removed.<br/> When inserting &apos;a&apos;s and &apos;b&apos;s, we get &apos;ababacbabacbabc&apos; and &apos;ababacbabcababc&apos;, in addition to the primary pattern.</p><p> Type 3: (x, y, y), x != y<br/> -----------------------<br/> Step 1: (generate primary pattern)<br/> - create MOS pattern with x steps &apos;a&apos;, and 2y steps &apos;#&apos;<br/> - replace the &apos;#&apos;s alternately with &apos;b&apos; and &apos;c&apos;</p><p> Example: For (6, 2, 2), the (6, 4)-MOS pattern is &apos;aa#a#aa#a#&apos;. By inserting &apos;b&apos; and &apos;c&apos; alternately, it becomes &apos;aabacaabac&apos;.<br/> Step 2: (derive other patterns, if possible)<br/> - if gcd(x, y) = 1 or gcd(x, 2y) doesn&apos;t divide y, exit<br/> - do the same as in step 2 for type 2, except treating the step with more occurances in the original MOS pattern as a &apos;#&apos;, and the one with fewer occurances as a &apos;c&apos;. In addition, here it can happen that two of the step with fewer occurances become adjacent, which results in an invalid pattern.<br/> - in the last step, insert &apos;b&apos;s and &apos;c&apos;s</p><p> Continued example - (6, 2, 2):<br/> gcd(x=6, y=2) != 1, and gcd(x=6, 2y=4) = 2 divides y=2, so we can go on.<br/> In &apos;aa#a#aa#a#&apos;, &apos;a&apos;-chains come in two lengths, so in resulting patterns the chain lengths must be the same. The only valid result is &apos;aa#aa#a#a#&apos;, giving &apos;aabaacabac&apos;.</p><p> Best<br/> - Gedankenwelt (&quot;Geddy&quot;)</p></div>