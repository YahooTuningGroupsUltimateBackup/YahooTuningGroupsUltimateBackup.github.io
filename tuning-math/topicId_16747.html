<a href="/tuning-math">back to list</a><h1>Scalar complexity from unison vectors</h1><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>9/9/2007 1:20:02 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I&apos;ve mentioned scalar complexity here before but it still isn&apos;t in my errors and complexities PDF.  One definition is that it&apos;s the size of the wedge product of the weighted equal temperament mappings that define the mapping, using a Euclidian metric.  That gives the length of an equal temperament, the area of a linear temperament, and so on. You divide it by the number of prime dimensions to make it comparable to the related complexity measures.</p><p>The other definition is that you use the determinant of the matrix formed from a matrix containing the weighted equal temperament mappings multiplied by its transpose so as to give an RxR matrix for a rank R temperament.  The square root of this determinant divided by the number of prime dimensions is the scalar complexity.  You can also form the matrix by taking the [i,j]th element as the dot product of the ith and jth mappings.</p><p>I&apos;ve been looking at the PDF book of Grassman Algebra and concluded that the two definitions are provably identical. This being the case, it should also be possible to calculate it using unison vectors (or whatever you want to call them) instead of equal temperament mappings.</p><p>I still haven&apos;t noticed an agreed term for unison vectors. They&apos;re commas which are tempered to a unison in a given regular temperament.  Each regular temperament class can be defined using a minimal set of unison vectors.  In this case we need them to be without torsion.</p><p>You weight a unison vector by multiplying each element by the size of the corresponding prime.  (This is the opposite to the weighting of mappings, where you divide instead of multiply, as befits the algebraic dual.)  To turn the wedge product of unison vectors into the wedge product of mappings you have to take the complement and divide by the product of the sizes of the prime intervals (or something like that).</p><p>Unison vectors being the dual of mappings you can also calculate the complexity using a matrix of unison vectors. So you put the minimal set of weighted unison vectors into a matrix.  Then multiply it by its transpose to get the smaller square matrix ((D-R)x(D-R) for a rank R temperament with D prime dimensions)).  Alternatively, construct the matrix so that the [i,j]th element is the dot product of the ith and jth weighted unison vectors.  The scalar complexity is the square root of the determinant of this matrix, divided by the product of the prime weights and the number of prime dimensions.</p><p>This should be the most efficient way of calculating the complexity from unison vectors most of the time because it avoids the need to calculate the wedgie, and wedgies can get big.  So it may be useful as part of a search for temperaments by unison vectors because it tell you when a set of unison vectors is already too complex for what you&apos;re looking for.  It&apos;s particularly efficient for such searches because the square matrices will keep re-using values.  For example, if you construct an NxN lookup table for your N candidate commas where the [i,j]th entry is the dot product of the ith and jth commas, it will contain all the numbers you need for the matrices at the expense of an up-front calculation that&apos;s quadratic in the number of candidate commas.  (About half its entries are duplicates as well.)</p><p>Here&apos;s some Python code to tie down the algorithm.  It uses a Numeric array &quot;primes&quot; containing the sizes of the prime intervals in octaves, and takes the unison vectors as a sequence of sequences.</p><p>def scalarComplexity(uvs):<br/>    dimension = len(uvs[0])<br/>    active_primes = primes[:dimension]<br/>    prime_product = 1.0<br/>    for prime in active_primes:<br/>        prime_product *= prime<br/>    weighted = [uv*active_primes for uv in uvs]</p><p>    MT = Numeric.array(weighted)<br/>    M = Numeric.transpose(MT)<br/>    MTM = Numeric.matrixmultiply(MT, M)<br/>    det = LinearAlgebra.determinant(MTM)<br/>    return math.sqrt(det)/prime_product/dimension</p><p>I still don&apos;t have an efficient way of calculating the error of a temperament from its unison vectors.</p><p>                      Graham</p></div><h3>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>9/9/2007 8:23:31 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>At 01:20 AM 9/9/2007, you wrote:<br/>&gt;I&apos;ve mentioned scalar complexity here before but it still<br/>&gt;isn&apos;t in my errors and complexities PDF.  One definition is<br/>&gt;that it&apos;s the size of the wedge product of the weighted<br/>&gt;equal temperament mappings that define the mapping, using a<br/>&gt;Euclidian metric.  That gives the length of an equal<br/>&gt;temperament, the area of a linear temperament, and so on.<br/>&gt;You divide it by the number of prime dimensions to make it<br/>&gt;comparable to the related complexity measures.</p><p>That sounds like what Paul uses in Middle Path.</p><p>&gt;The other definition is that you use the determinant of the<br/>&gt;matrix formed from a matrix containing the weighted equal<br/>&gt;temperament mappings multiplied by its transpose so as to<br/>&gt;give an RxR matrix for a rank R temperament.  The square<br/>&gt;root of this determinant divided by the number of prime<br/>&gt;dimensions is the scalar complexity.  You can also form the<br/>&gt;matrix by taking the [i,j]th element as the dot product of<br/>&gt;the ith and jth mappings.</p><p>Huh.</p><p>&gt;I&apos;ve been looking at the PDF book of Grassman Algebra and<br/>&gt;concluded that the two definitions are provably identical.<br/>&gt;This being the case, it should also be possible to calculate<br/>&gt;it using unison vectors (or whatever you want to call them)<br/>&gt;instead of equal temperament mappings.<br/>&gt;<br/>&gt;I still haven&apos;t noticed an agreed term for unison vectors.<br/>&gt;They&apos;re commas which are tempered to a unison in a given<br/>&gt;regular temperament.  Each regular temperament class can be<br/>&gt;defined using a minimal set of unison vectors.  In this case<br/>&gt;we need them to be without torsion.<br/>&gt;<br/>&gt;You weight a unison vector by multiplying each element by<br/>&gt;the size of the corresponding prime.  (This is the opposite<br/>&gt;to the weighting of mappings, where you divide instead of<br/>&gt;multiply, as befits the algebraic dual.)  To turn the wedge<br/>&gt;product of unison vectors into the wedge product of mappings<br/>&gt;you have to take the complement and divide by the product of<br/>&gt;the sizes of the prime intervals (or something like that).<br/>&gt;<br/>&gt;Unison vectors being the dual of mappings you can also<br/>&gt;calculate the complexity using a matrix of unison vectors.<br/>&gt;So you put the minimal set of weighted unison vectors into a<br/>&gt;matrix.  Then multiply it by its transpose to get the<br/>&gt;smaller square matrix ((D-R)x(D-R) for a rank R temperament<br/>&gt;with D prime dimensions)).  Alternatively, construct the<br/>&gt;matrix so that the [i,j]th element is the dot product of the<br/>&gt;ith and jth weighted unison vectors.  The scalar complexity<br/>&gt;is the square root of the determinant of this matrix,<br/>&gt;divided by the product of the prime weights and the number<br/>&gt;of prime dimensions.<br/>&gt;<br/>&gt;This should be the most efficient way of calculating the<br/>&gt;complexity from unison vectors most of the time because it<br/>&gt;avoids the need to calculate the wedgie, and wedgies can get<br/>&gt;big.  So it may be useful as part of a search for<br/>&gt;temperaments by unison vectors because it tell you when a<br/>&gt;set of unison vectors is already too complex for what you&apos;re<br/>&gt;looking for.  It&apos;s particularly efficient for such searches<br/>&gt;because the square matrices will keep re-using values.  For<br/>&gt;example, if you construct an NxN lookup table for your N<br/>&gt;candidate commas where the [i,j]th entry is the dot product<br/>&gt;of the ith and jth commas, it will contain all the numbers<br/>&gt;you need for the matrices at the expense of an up-front<br/>&gt;calculation that&apos;s quadratic in the number of candidate<br/>&gt;commas.  (About half its entries are duplicates as well.)<br/>&gt;<br/>&gt;Here&apos;s some Python code to tie down the algorithm.  It uses<br/>&gt;a Numeric array &quot;primes&quot; containing the sizes of the prime<br/>&gt;intervals in octaves, and takes the unison vectors as a<br/>&gt;sequence of sequences.<br/>&gt;<br/>&gt;def scalarComplexity(uvs):<br/>&gt;     dimension = len(uvs[0])<br/>&gt;     active_primes = primes[:dimension]<br/>&gt;     prime_product = 1.0<br/>&gt;     for prime in active_primes:<br/>&gt;         prime_product *= prime<br/>&gt;     weighted = [uv*active_primes for uv in uvs]<br/>&gt;<br/>&gt;     MT = Numeric.array(weighted)<br/>&gt;     M = Numeric.transpose(MT)<br/>&gt;     MTM = Numeric.matrixmultiply(MT, M)<br/>&gt;     det = LinearAlgebra.determinant(MTM)<br/>&gt;     return math.sqrt(det)/prime_product/dimension<br/>&gt;<br/>&gt;I still don&apos;t have an efficient way of calculating the error<br/>&gt;of a temperament from its unison vectors.</p><p>Wow.</p><p>-Carl</p></div><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>9/9/2007 5:54:35 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Carl Lumma wrote:<br/>&gt; At 01:20 AM 9/9/2007, you wrote:<br/>&gt; &gt;&gt;I&apos;ve mentioned scalar complexity here before but it still &gt;&gt;isn&apos;t in my errors and complexities PDF.  One definition is &gt;&gt;that it&apos;s the size of the wedge product of the weighted &gt;&gt;equal temperament mappings that define the mapping, using a &gt;&gt;Euclidian metric.  That gives the length of an equal &gt;&gt;temperament, the area of a linear temperament, and so on. &gt;&gt;You divide it by the number of prime dimensions to make it &gt;&gt;comparable to the related complexity measures.<br/>&gt; &gt; That sounds like what Paul uses in Middle Path.</p><p>According to my PDF, he used the sum-abs of the weighted wedgie.  That&apos;s proportional to the Tenney harmonic distance of a single unison vector, and probably a sensible taxicab distance for an equal temperament.  In general, I don&apos;t know what it means.  How do you calculate areas with a taxicab metric anyway?</p><p>Note that Fokker&apos;s periodicity block determinants are a special case of unweighted scalar complexity.</p><p>                Graham</p></div>