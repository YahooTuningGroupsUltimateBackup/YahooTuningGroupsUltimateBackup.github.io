<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math Optimal octave stretching</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>Optimal octave stretching</h1><h3><a id=10228 href="#10228">ðŸ”—</a>Graham Breed &#x3C;graham@microtonal.co.uk&#x3E;</h3><span>4/12/2004 10:12:48 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I&apos;ve been looking at the RMS weighted error of equal temperaments.  A weighted RMS for an unbound set of intervals is more appropriate than the worst weighted error used by TOP.  The worst error is used to ensure that none of the intervals you plan to use fall outside an acceptable range of mistuning.  The more complex and less frequently used an interval is, the more important that it lie within this range if it is to be heard as a consonance.  Dissonance curves of whatever kind also show larger basins for more simple consonances, so that the range of mistuning is likely to be smaller for more complex intervals.  These factors together conspire to make the most complex intervals the ones that dominate the result, so that if there&apos;s no cutoff the result will not converge.  Hence you decide in advance where the cutoff should be.</p><p>The RMS error, on the other hand, gives the average pain associated with a mistuning.  In this case, it is appropriate to give simple or common intervals (generally the two will be the same) a higher weighting because their mistuning will lead to greater pain.  It doesn&apos;t matter if an interval is classed as a consonance or not, because its presence can still take pain away from a chord.  Ideally, we&apos;d only consider intervals that pass a worst-error threshold, but for simplicity&apos;s sake an unbounded set can be considered.</p><p>It would be nice if a particular error converged for some set of intervals as its size approached infinity -- say an integer limit containing only the primes we&apos;re interested in.  Unfortunately, I can&apos;t find one so I&apos;ll use the simplest error for a set of primes -- the weighted RMS of the prime intervals.  Adding or averaging the errors of the primes is usually the first thing people think of.  We tell them they&apos;re wrong because they don&apos;t take account of things like 15:8 being more complex than 6:5.  This objection doesn&apos;t apply when you consider 2 on a par with other prime numbers, because then 15:8 becomes naturally more complex than 6:5.  A temperament, such as 19-equal in the 5-limit, where the errors of 5:4 and 3:2 cancel out in 6:5 will be a good fit for octave stretching.  It will then have a naturally reduced prime error.</p><p>The obvious weighting to use is the size of the prime interval in octaves.  That should give an indication of the average Tenny-weighted error for an arbitrary set of intervals.  This weighting essentially ensures that prime and composite numbers are treated equally.  If you like, you can set a weighting such that high primes have a much smaller weight than low ones, so that you don&apos;t need to specify the prime limit.</p><p>This is all a bit arbitrary, but so is any algorithm in the absence of sound, empirical data on the strength and tolerance of mistuning for each interval.  This is a particular problem for octave-specific measures, because interval size and perceptual octave stretching come into play.  So we may as well stick with the simplest method if we&apos;re going to bother at all.</p><p>The weighted, square error for an equally tempered interval is given by</p><p>[(km - p)w]**2</p><p>where</p><p>  k is the size of a scale step<br/>  m is the number of scale steps to this tempered interval<br/>  p is the untempered pitch difference of this interval<br/>  w is the weight given to this interval<br/>  **2 is &quot;squared&quot;</p><p>For weighting by interval size, w=1/p, so</p><p>[(km - p)/p]**2 = (km/p - 1)**2</p><p>The mean squared error is then</p><p>Avg[(km/p - 1)**2]</p><p>over m an p for all primes.  Setting x=m/p to be the ideal number of steps to a just octave for each prime, that becomes</p><p>Avg[(kx - 1)**2] = Avg[(kx)**2 - 2kx + 1]</p><p>The optimum value for k is found by setting the derivative with respect to k equal to zero, so</p><p>Avg[2k(x**2) - 2x] = 0<br/>k = Avg(x)/Avg(x**2)</p><p>Then, rearranging the formula for the mean squared error, and plugging in this optimum step size</p><p>Avg[(kx)**2 - 2kx + 1]<br/>= k**2 Avg(x**2) - 2k Avg(x) + 1<br/>= [Avg(x)/Avg(x**2)]**2 Avg(x**2) - 2[Avg(x)/Avg(x**2)] Avg(x) + 1<br/>= Avg(x)**2 / Avg(x**2) - 2[Avg(x)**2]/Avg(x**2) + 1<br/>= 1 - Avg(x)**2/Avg(x**2)</p><p>So the RMS error is</p><p>Sqrt[1 - Avg(x)**2/Avg(x**2)]</p><p>This is quite similar to the sample standard deviation of {x} (that is, the standard deviation you shouldn&apos;t use in error estimation):</p><p>STD(x) = Sqrt[Avg(x**2) - Avg(x)**2]</p><p>So you could write the RMS error as STD(x)/Sqrt(Avg(x**2)) if you happen to have a convenient way of calculating the standard deviation.  As each x will be close to n, the number of steps to a tempered octave, you can simplify the RMS as STD(x)/n.</p><p>Anyway, I&apos;ve adapted my python module at</p><p><a href="http://x31eq.com/temper.py">http://x31eq.com/temper.py</a></p><p>to do these calculations.  Here are some examples:</p><p>&gt;&gt;&gt; temper.PrimeET(12, temper.primes[:2]).getPORMSWE()<br/>0.0025886343681387008<br/>&gt;&gt;&gt; (temper.PrimeET(12, temper.primes[:2]).getPORMSWEStretch()-1)*1200<br/>-1.5596534250319039</p><p>That means 5-limit 12-equal has a prime, optimum, RMS, weighted error of around 0.003.  This is a dimensionless value hopefully comparable to the TOP error.  The optimum octave is flattened by around 1.6 cents.</p><p>&gt;&gt;&gt; temper.PrimeET(19, temper.primes[:2]).getPORMSWE()<br/>0.0015921986407487665<br/>&gt;&gt;&gt; (temper.PrimeET(19, temper.primes[:2]).getPORMSWEStretch()-1)*1200<br/>2.5780456079649738<br/>&gt;&gt;&gt; temper.PrimeET(22, temper.primes[:2]).getPORMSWE()<br/>0.0022460185834616815<br/>&gt;&gt;&gt; (temper.PrimeET(22, temper.primes[:2]).getPORMSWEStretch()-1)*1200<br/>-0.86081876412746894<br/>&gt;&gt;&gt; temper.PrimeET(29, temper.primes[:2]).getPORMSWE()<br/>0.0025604733781234741<br/>&gt;&gt;&gt; (temper.PrimeET(29, temper.primes[:2]).getPORMSWEStretch()-1)*1200<br/>1.6758871121345997<br/>&gt;&gt;&gt; temper.PrimeET(31, temper.primes[:2]).getPORMSWE()<br/>0.0013562866803350085<br/>&gt;&gt;&gt; (temper.PrimeET(31, temper.primes[:2]).getPORMSWEStretch()-1)*1200<br/>0.9757470533824808<br/>&gt;&gt;&gt; temper.PrimeET(50, temper.primes[:2]).getPORMSWE()<br/>0.0013261119467051412<br/>&gt;&gt;&gt; (temper.PrimeET(50, temper.primes[:2]).getPORMSWEStretch()-1)*1200<br/>1.5845318713727963</p><p>50-equal is probably close to the RMS meantone optimum, so the stretch of 1.6 cents is refreshingly close to the 1.7 cents Gene gave for TOP meantone on metatuning.  In fact, it&apos;s a fix because stretched 31-equal is closer to the TOP meantone, and 81 is closer to the meantone PORMSWE:</p><p>&gt;&gt;&gt; temper.PrimeET(81, temper.primes[:2]).getPORMSWE()<br/>0.0013189616858225524<br/>&gt;&gt;&gt; (temper.PrimeET(81, temper.primes[:2]).getPORMSWEStretch()-1)*1200<br/>1.3515272079124507</p><p>But, anyway, the stretching is of the same order of magnitude.</p><p>I would do more comparisons, but I haven&apos;t implemented the TOP optimization yet.  For that matter, I can only do it for 3-limit equal temeperaments, 5-limit linear temperaments, 7-limit planar temperaments, etc.  I&apos;m sure I could work out how to do PORMSWE for linear temperaments, but I haven&apos;t done so yet.  So for now, it&apos;s a case of finding a representative equal temperament.</p><p>Guessing the ennealimmal optimum is difficult, because it seems to lie close to the point where the octave goes from being sharp to flat.  But it looks close to 612-equal, with the stretch stable either side.</p><p>&gt;&gt;&gt; (temper.PrimeET(612, temper.primes[:3]).getPORMSWEStretch()-1)*1200<br/>0.020981278370690859</p><p>That&apos;s the same order of magnitude as the TOP optimum Gene gave of 0.036 cents.</p><p>                 Graham</p></div><h3><a id=10229 href="#10229">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@svpal.org&#x3E;</h3><span>4/12/2004 11:26:51 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;graham@m...&gt; wrote:</p><p>&gt; It would be nice if a particular error converged for some set of<br/>&gt; intervals as its size approached infinity -- say an integer limit<br/>&gt; containing only the primes we&apos;re interested in.  Unfortunately, I<br/>can&apos;t<br/>&gt; find one so I&apos;ll use the simplest error for a set of primes -- the<br/>&gt; weighted RMS of the prime intervals.</p><p>Zeta tuning works along the lines you want here. A Python script<br/>which found the Zeta tuning might be a bit of a pain to write,<br/>though, and it only works for rank one (equal or &quot;dimension zero&quot;)<br/>temperaments.</p><p>&gt; 50-equal is probably close to the RMS meantone optimum, so the<br/>stretch<br/>&gt; of 1.6 cents is refreshingly close to the 1.7 cents Gene gave for<br/>TOP<br/>&gt; meantone on metatuning.</p><p>It would be interested to find the Zeta tunings for comparison; I&apos;ll<br/>need to move to the Linux side to do that.</p><p>&gt; Guessing the ennealimmal optimum is difficult, because it seems to<br/>lie<br/>&gt; close to the point where the octave goes from being sharp to flat.<br/>But<br/>&gt; it looks close to 612-equal, with the stretch stable either side.</p><p>You could try 441 also.</p></div><h3><a id=10230 href="#10230">ðŸ”—</a>Graham Breed &#x3C;graham@microtonal.co.uk&#x3E;</h3><span>4/12/2004 11:53:53 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene Ward Smith wrote:</p><p>&gt; Zeta tuning works along the lines you want here. A Python script &gt; which found the Zeta tuning might be a bit of a pain to write, &gt; though, and it only works for rank one (equal or &quot;dimension zero&quot;) &gt; temperaments.</p><p>That&apos;s the thing you keep mentioning related to the zeta function, is it?</p><p>&gt; You could try 441 also.</p><p>Oh, I did, and many more.  It gives an octave flat by 0.012 cents.  I&apos;ve shown that the optimum lies between 5679- 7173-equal.</p><p>                  Graham</p></div><h3><a id=10232 href="#10232">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@svpal.org&#x3E;</h3><span>4/12/2004 11:24:19 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;graham@m...&gt; wrote:<br/>&gt; Gene Ward Smith wrote:<br/>&gt;<br/>&gt; &gt; Zeta tuning works along the lines you want here. A Python script<br/>&gt; &gt; which found the Zeta tuning might be a bit of a pain to write,<br/>&gt; &gt; though, and it only works for rank one (equal or &quot;dimension<br/>zero&quot;)<br/>&gt; &gt; temperaments.<br/>&gt;<br/>&gt; That&apos;s the thing you keep mentioning related to the zeta function,<br/>is it?</p><p>One of several things I keep mentioning related to the Zeta function.</p></div><h3><a id=10233 href="#10233">ðŸ”—</a>Graham Breed &#x3C;graham@microtonal.co.uk&#x3E;</h3><span>4/13/2004 3:40:55 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I wrote:</p><p>&gt; Oh, I did, and many more.  It gives an octave flat by 0.012 cents.  I&apos;ve &gt; shown that the optimum lies between 5679- 7173-equal.</p><p>I&apos;ve got it working with linear temperaments now.  Here&apos;s the ennealimmal and 5-limit meantone results:</p><p>&gt;&gt;&gt; enne = temper.Temperament(171,612,temper.limit9)<br/>&gt;&gt;&gt; enne.optimizePORMSWE()<br/>&gt;&gt;&gt; enne.getPRMSWError()<br/>2.4769849465587193e-05<br/>&gt;&gt;&gt; (enne.mapping[0][0]*enne.basis[0] - 1)*1200<br/>0.021691213712138335<br/>&gt;&gt;&gt; enne.basis[1]*1200<br/>49.021363311937186<br/>&gt;&gt;&gt; meantone = temper.Temperament(19,31,temper.limit5)<br/>&gt;&gt;&gt; meantone.optimizePORMSWE()<br/>&gt;&gt;&gt; meantone.getPRMSWError()<br/>0.001318517728382543<br/>&gt;&gt;&gt; (meantone.basis[0] - 1)*1200<br/>1.3968513622916845<br/>&gt;&gt;&gt; meantone.basis[1]*1200<br/>504.34774072728203</p><p>                    Graham</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            