<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math Reduced echelon form</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>Reduced echelon form</h1><h3><a id=16671 href="#16671">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/8/2007 4:07:47 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>As the next step on my search for an invariant quantity for temperaments, I&apos;m looking at row echelon form.  This is best described in the Oxford Dictionary of Mathematics, which is unfortunately in a dead tree format so I can&apos;t send a link.   It&apos;s also the result of Gauss-Jordan elimination.</p><p>The idea is to get the left hand side to look as much like the identity matrix as possible.  Because temperament mappings can only contain integers, I implicitly multiply each row through by its lowest common denominator.</p><p>Because of the way the calculation&apos;s done I have to find the greatest common divisor (gcd) of each row.  As a result, all information about contorsion gets lost.</p><p>The result looks pretty much like the wedgie-like invariant I came up with yesterday.  The difference is that each row has a gcd of 1 and a first non-zero entry that&apos;s always postive.  Also, contorted temperaments give the same result as their uncontorted relatives.</p><p>The result can still have contorsion, which is a pain.  So this is no use as a way of removing torsion from a set of unison vectors.  I still haven&apos;t worked out Hermite normal form, which Gene suggested for that.  They seem to be related, anyway.</p><p>The advantage of reduced echelon form over the wedgie-like thing is that, like full wedgies, it&apos;s easily generalized to higher ranks.  I&apos;ve verified that the wedgies are recoverable for ranks 2 and 3.</p><p>The code&apos;s fiddly and likely to be inefficient because of the gcd calculations (which don&apos;t even tell us anything about contorsion).  I haven&apos;t tested yet but it may be faster than my wedge product code because that&apos;s extremely inefficient for ranks greater than 2.  There may be a better way of doing either.</p><p>Here&apos;s that code, with a bit of word wrapping:</p><p>from __future__ import division<br/>import regular_wedgie<br/>from regular_wedgie import hcf<br/>from math import sqrt</p><p>def ref(ets):<br/>    &quot;&quot;&quot;Reduced echelon form&quot;&quot;&quot;<br/>    return [normalize_row(row) for row in raw_ref(ets)]</p><p>def raw_ref(ets):<br/>    &quot;&quot;&quot;Reduced echelon form without removing common factors<br/>    or adjusting signs.<br/>    &quot;&quot;&quot;<br/>    rows = [list(et) for et in ets]<br/>    n_rows = len(rows)<br/>    n_columns = len(rows[0])<br/>    for row in rows:<br/>        assert len(row)==n_columns<br/>    row = column = 0<br/>    while row &lt; n_rows:<br/>        try:<br/>            row, column = reduction_point(rows, row, column)<br/>        except ReductionException:<br/>            raise LowerRankException, &quot;Lower rank temperament&quot;<br/>        n = rows[row][column]<br/>        for i in range(n_rows):<br/>            if i==row:<br/>                continue<br/>            m = rows[i][column]<br/>            for j in range(n_columns):<br/>                rows[i][j] = n*rows[i][j] - m*rows[row][j]<br/>        row += 1<br/>        column += 1<br/>    return rows</p><p>def check_ref(ets):<br/>    try:<br/>        reduced = ref(ets)<br/>    except LowerRankException:<br/>        for element in wedgie(ets):<br/>            assert element==0<br/>        return ###<br/>    torsion = False<br/>    for et in ets:<br/>        try:<br/>            multiples = un_ref(et, reduced)<br/>            for j in range(len(et)):<br/>                total = 0<br/>                for m, v in zip(multiples, reduced):<br/>                    total += m*v[j]<br/>                assert total == et[j], &quot;Failed for %s&quot;%et<br/>        except ContorsionException:<br/>            torsion = True<br/>        except AssertionError:<br/>            print ets<br/>            raise<br/>    wedgie1 = wedgie(ets)<br/>    wedgie2 = wedgie(reduced)<br/>    contorsion1 = hcf(wedgie1)<br/>    contorsion2 = hcf(wedgie2)<br/>    if contorsion2==1:<br/>        assert not torsion<br/>    for m, n in zip(wedgie1, wedgie2):<br/>        assert m*contorsion2 == n*contorsion1, &quot;wedgies don&apos;t match for %s&quot;%str(<br/>                ets)</p><p>def un_ref(et, reduced):<br/>    &quot;&quot;&quot;Return the multiples of reduced that give et.<br/>    Assumes reduced is the result of ref.<br/>    &quot;&quot;&quot;<br/>    result = []<br/>    j=0<br/>    for i in range(len(reduced)):<br/>        while reduced[i][j]==0:<br/>            j += 1<br/>        y, check = divmod(et[j], reduced[i][j])<br/>        if check:<br/>            raise ContorsionException, &quot;%s %s contorted&quot; % (et, reduced)<br/>        result.append(y)<br/>    return tuple(result)</p><p>def wedgie(ets):<br/>    return tuple(normalize_sign(regular_wedgie.wedgie(ets)))</p><p>def normalize_row(mapping):<br/>    torsion = hcf(mapping)<br/>    return normalize_sign([m//torsion for m in mapping])</p><p>def normalize_sign(mapping):<br/>    nonzeros = [m for m in mapping if m]<br/>    if nonzeros==[] or nonzeros[0]&gt;0:<br/>        return mapping<br/>    return [-m for m in mapping]</p><p>def reduction_point(rows, row, column):<br/>    if column &gt;= len(rows[row]):<br/>        raise ReductionException, &quot;Everything zero!&quot;<br/>    try:<br/>        actual_row = first_non_zero(rows, row, column)<br/>        if row != actual_row:<br/>            rows[row], rows[actual_row] = rows[actual_row], rows[row]<br/>        return row, column<br/>    except ReductionException:<br/>        # this column all zer<br/>        # so try the next one<br/>        return reduction_point(rows, row, column+1)</p><p>def first_non_zero(rows, first_row, column):<br/>    for row in range(first_row, len(rows)):<br/>        if rows[row][column]:<br/>            return row<br/>    raise ReductionException, &quot;Zero in all rows&quot;</p></div><h3><a id=16672 href="#16672">ðŸ”—</a>Keenan Pepper &#x3C;keenanpepper@gmail.com&#x3E;</h3><span>7/8/2007 12:01:31 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 7/8/07, Graham Breed &lt;<a href="mailto:gbreed@gmail.com">gbreed@gmail.com</a>&gt; wrote:<br/>&gt; Because of the way the calculation&apos;s done I have to find the<br/>&gt; greatest common divisor (gcd) of each row.  As a result, all<br/>&gt; information about contorsion gets lost.</p><p>What&apos;s &quot;contorsion&quot;? Is it different from torsion?</p><p>Keenan</p></div><h3><a id=16673 href="#16673">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/8/2007 5:42:07 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Keenan Pepper wrote:<br/>&gt; On 7/8/07, Graham Breed &lt;<a href="mailto:gbreed@gmail.com">gbreed@gmail.com</a>&gt; wrote:<br/>&gt; &gt;&gt;Because of the way the calculation&apos;s done I have to find the<br/>&gt;&gt;greatest common divisor (gcd) of each row.  As a result, all<br/>&gt;&gt;information about contorsion gets lost.<br/>&gt; &gt; What&apos;s &quot;contorsion&quot;? Is it different from torsion?</p><p>Contorsion is like torsion but it involves sets of equal temperament mappings (or things like them) instead of unison vectors (or things like them).  I think that makes contorsion the dual of torsion.</p><p>As far as the wedgie&apos;s concerned, they&apos;re the same thing.</p><p>                  Graham</p></div><h3><a id=16676 href="#16676">ðŸ”—</a>Gene Ward Smith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>7/26/2007 11:40:45 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:</p><p> I still haven&apos;t worked out Hermite normal<br/>&gt; form, which Gene suggested for that.  They seem to be<br/>&gt; related, anyway.</p><p>Closely, but I think it would be to your advantage to write up Hermite<br/>form reduction.</p></div><h3><a id=16677 href="#16677">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/31/2007 8:44:46 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene Ward Smith wrote:<br/>&gt; --- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:<br/>&gt; &gt;  I still haven&apos;t worked out Hermite normal &gt; &gt;&gt;form, which Gene suggested for that.  They seem to be &gt;&gt;related, anyway.<br/>&gt; &gt; &gt; Closely, but I think it would be to your advantage to write up Hermite &gt; form reduction.</p><p>The fact is I don&apos;t know how to do that!  I looked at reduced echelon form because one reference said it was the same as Hermite normal form.  But other references plainly contradict that.  Everything I can find is either for non-singular matrices (which is obviously meaningless here), describes the result but not how to get there, or I plain couldn&apos;t understand.</p><p>In the end I found it easier to write a function that does what I want and not worry about what to call it.  I do have one now that preserves contorsion, and is unique as far as I can test.  The problem is I don&apos;t have any other way to be sure that two contorted temperament-like-things are distinct.</p><p>Some 5-limit examples:</p><p>5&amp;7, 7&amp;12, 12&amp;19, 19&amp;31, etc (meantone)</p><p>[[1, 0, -4],<br/> [0, 1, 4]]</p><p>7&amp;24, 7&amp;31, 24&amp;31 (Vicentino-like neutral thirds meantone)</p><p>[[1, 1, 0],<br/> [0, 2, 8]]</p><p>5&amp;24, 5&amp;19, 19&amp;24 (identical wedgie to the previous)</p><p>[[1, 0, -4],<br/> [0, 2, 8]]</p><p>Some of the off-diagonals that are defined as zero in reduced echelon form are the smallest non-negative values here that don&apos;t increase torsion.</p><p>                  Graham</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            