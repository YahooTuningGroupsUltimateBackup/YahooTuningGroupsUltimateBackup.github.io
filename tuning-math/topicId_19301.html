<a href="/tuning-math">back to list</a><h1>Periodicity blocks/hobbits review</h1><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>6/25/2011 4:01:46 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Here are some notes I took when I was investigating Carl<br/>and Gene&apos;s methods for finding unison vectors that worked<br/>well for finding periodicity blocks or hobbits.  I didn&apos;t<br/>write up a friendly reply, so maybe somebody else can work<br/>out what I was doing here.</p><p>From what I remember, Gene was finding good unison vectors<br/>for the equal temperament (val) according to temperamental<br/>complexity defined for the rank 3 temperament.  I couldn&apos;t<br/>reproduce Gene&apos;s working.  Carl was finding simple unison<br/>vectors in full JI space, and whether or not that&apos;s how he<br/>did it, he agreed with TLLL-reduction.  Carl&apos;s method looks<br/>simple and good enough to implement but I didn&apos;t get<br/>further than this.</p><p>The point about JI space is that, although it&apos;s more<br/>complicated than tempered space, you can apply a weighted<br/>LLL to it.</p><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:</p><p>&gt; &gt; Some time back I introduced dwarf scales, which start from a p-limit val v and define a p-limit JI scale by by choosing for each nonzero<br/>&gt; &gt; value i mod v[1] the smallest positive odd integer n such that v(n) = i mod v[1].</p><p>&gt; I take it v[1] is the number of steps to an octave (2:1).  What&apos;s<br/>&gt; v(n)?</p><p>v is an equal temperament val, so v(2) is the number of steps in an octave, which is the same as the first coefficient of the val, v[1].</p><p> Carl said down-thread that dwarf scales take the simplest ratio<br/>&gt; that maps to the given number of scale steps.  Is that right?</p><p>It takes the smallest odd integer which maps to the given number of steps modulo octaves.</p><p>&gt; If the commas define the temperament, they must be unison vectors.</p><p>If you say so. To me, they are commas.</p><p>&gt; The next paragraph&apos;s so dense I&apos;m going to have to break it up.<br/>&gt; Nearly every sentence has something I don&apos;t understand.<br/>&gt;<br/>&gt; &gt; The standard Euclidean norm on weighted monzos provides a canonical Euclidean metric on interval space.<br/>&gt;<br/>&gt; With Tenney weighting, that&apos;ll give the scalar complexity of the<br/>&gt; temperament class defined by the monzo as a unison vector, won&apos;t it?</p><p>&quot;Scalar complexity&quot; sounds like gibberish to my mind, so I can&apos;t easily retain the definition. And no, I am not kidding nor trying to give you a hard time, this is really true of me. Assuming &quot;temperament class&quot; means the same as &quot;temperament&quot;, you may be asking if the norm of the monzo for a temperament defined by a single comma is the same as its complexity.<br/>It should be proportional, but I don&apos;t know why you think this is important here.</p><p>&gt; That looks straightforward.  Do we assume Tenney weighting?</p><p>Yes, if by that you mean multiplying the prime p coordinate by log2(p).</p><p>&gt; &gt; Projecting othogonally from a set of intervals consisting of the commas + 2 in this metric defines a canonical projection map from the p-limit to a lattice of interval classes.<br/>&gt;<br/>&gt; This is your square matrix, is it?  Taken from an intermediate<br/>&gt; calculation in the least squares optimization.  Is it weighted?</p><p>Its an orthogonal projection, which like any projection can be given by an idempotent (P = P^2) square matrix P. I don&apos;t know what you mean by the weighting question, but we are working in weighted coordinates, and would need to transform the matrix to get the corresponding matrix in unweighted coordinates, which can be useful. In that case, the matrix is no longer symmetric, since the norm is no longer given by the dot product, but it projects unweighted monzos directly without first needing to weight them.</p><p>&gt; Where does +2 come from?</p><p>I mean the octave, 2, is added to the list of commas.</p><p>&gt; Why interval classes?  I thought they were octave equivalent.  If so,<br/>&gt; what did you do with the octaves?  And what&apos;s the norm?</p><p>They are octave equivalent only since 2 is added to the commas. The norm (really, seminorm if we are not looking at equivalence classes) is the ordinary dot product norm on the projected monzos.</p><p>&gt; &gt; Given a val v tempering out the commas c, we choose the smallest lattice element q (ie, the one nearest the origin) for each i, 0 &lt;= i &lt; v[1] such that v(q) mod v[1] = i.<br/>&gt;<br/>&gt; Element of what lattice?  The octave equivalent projection above, with<br/>&gt; the undefined norm?  And this v(q) comes up again.</p><p>I defined the norm. The lattice is the lattice of projected monzos in the subspace, and the norm is the dot product norm.</p><p>&gt; &gt; This assumes q is expressed in terms of rational numbers, but since v tempers out the commas and we plan to temper the result that result is independent of the particular choice of q.<br/>&gt;<br/>&gt; How can it be expressed in terms of rationals if it&apos;s a lattice<br/>&gt; element?  Lattice elements are expressed in terms of integers.<br/>&gt; Otherwise, what makes it a lattice element?</p><p>It&apos;s a lattice element since given a q, there is one and only one lattice point associated to it.</p><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, &quot;genewardsmith&quot; &lt;genewardsmith@...&gt; wrote:</p><p>&gt; All three of us could take a specific small but interesting example, such as constructing an 11-note scale for starling using the starling val &lt;11 18 26 31|, and explaining things as best as possible.</p><p>Consider the Hermite normal form mapping/ikon for starling. This gives (tempered) 2, 3, and 5 as generators for the intervals of the temperament. In this subgroup, the &lt;11 18 26 31| val becomes &lt;11 18 26|. A basis for the commas is 16/15 and 3125/2916.</p><p>/*<br/>starling = [27, 43, 63, 76; 19, 30, 44, 53; 12, 19, 28, 34]~;<br/>? rowhnf(starling~)</p><p>[1 0 0 -1]</p><p>[0 1 0 -2]</p><p>[0 0 1 3]</p><p>? g11 5 = [11,18,26]~;<br/>? basis = [4,-1,-1;-2,-6,5];<br/>? get ratios(basis)<br/>[16/15, 3125/2916]<br/>? basis * g11 5<br/>[0, 0]~<br/>*/</p><p>Now form a projection matrix by the following proceedure:</p><p>(1) Weight the monzos for 2, 16/15 and 3125/2916 by &lt;1 log2(3) log2(5)|; call these u1, u2, and u3.</p><p>/*<br/>? u1 = [1,0,0]<br/>[1, 0, 0]<br/>? u2 = weight intervals(basis)[1,]<br/>[4.000000000000000000000000000, -1.584962500721156181453738944, -2.321928094887362347870319429]<br/>? u3 = weight intervals(basis)[2,]<br/>[-2.000000000000000000000000000, -9.509775004326937088722433663, 11.60964047443681173935159715]<br/>*/</p><p>(2) Take the matrix M whose rows are these weighted monzos, and find<br/>Q = M&grave;M, where M&grave; is the pseudoinverse. The projection matrix is now P = I - Q, where I is the identity matrix.<br/>/*</p><p>? monzos = [1, 0, 0; 4, -1, -1; -2, -6, 5];<br/>? M = weight intervals(monzos)</p><p>[1.000000000000000000000000000 0 0]</p><p>[4.000000000000000000000000000 -1.584962500721156181453738944 -2.321928094887362347870319429]</p><p>[-2.000000000000000000000000000 -9.509775004326937088722433663 11.60964047443681173935159715]</p><p>? pseudo inverse(X) = X~ * matadjoint(X*X~) / matdet(X*X~)<br/>? Mp = pseudo inverse(M)</p><p>[0.9999999999999999999999999999 -4.653197630 E-28 -1.183016346 E-28]</p><p>[1.032430505844203078890135278 -0.2867862516233897441361486880 -0.05735725032467794882722973816]</p><p>[1.017962773628019937947524617 -0.2349144862218507549109672192 0.03915241437030845915182787051]</p><p>? M*Mp</p><p>[0.9999999999999999999999999999 -4.653197630 E-28 -1.183016346 E-28]</p><p>[-5.048709794 E-28 0.9999999999999999999999999974 -1.121760207 E-27]</p><p>[4.038967835 E-28 -1.161203252 E-27 1.000000000000000000000000012]</p><p>? Q = Mp*M</p><p>[0.9999999999999999999999999982 1.862536304 E-27 -2.930004151 E-28]</p><p>[2.360271828 E-27 1.000000000000000000000000004 -6.52545741 E-27]</p><p>[-7.888609052 E-28 -6.033208204 E-27 1.000000000000000000000000007]</p><p>? P = matid(3) - Q</p><p>[1.754426653 E-27 -1.862536304 E-27 2.930004151 E-28]</p><p>[-2.360271828 E-27 -4.139942031 E-27 6.52545741 E-27]</p><p>[7.888609052 E-28 6.033208204 E-27 -6.91673241 E-27]</p><p>*/</p><p>(3) Project u2 and u3 (u1 projects to zero) by v2 = u2.P, v3 = u3.P.</p><p>/* continue with 126/125 (see below)</p><p>? u1 = [1,0,0,0]<br/>[1, 0, 0, 0]<br/>? u2 = weight intervals(monzos)[2,]<br/>[4.000000000000000000000000000, -1.584962500721156181453738944, -2.321928094887362347870319429, 0]<br/>? u3 = weight intervals(monzos)[3,]<br/>[1.000000000000000000000000000, 3.169925001442312362907477888, -6.965784284662087043610958289, 2.807354922057604107441969317]</p><p>? u1*P<br/>[1.539856487 E-27, -9.83683891 E-28, 9.35760271 E-30, -3.507315730 E-28]<br/>? u2*P<br/>[6.59436940 E-27, -7.75608042 E-27, 6.362952062 E-27, -4.285092438 E-27]<br/>? u3*P<br/>[-1.070580382 E-26, -1.688793426 E-26, 4.412572360 E-26, -1.661025522 E-26]</p><p>*/</p><p>(4) v2 and v3 span a subspace of R^4, the 4-dimensional real Euclidean space with dot product norm, and define a lattice on this subspace. Find the Minkowski basis for this subspace, which consists of the projections of 16/15 and 15625/15552.</p><p>/*</p><p>Mapping that includes 11:</p><p>starling11 = [11, 18, 26, 31; 27, 43, 63, 76; 12, 19, 28, 34]~;</p><p>Definition of the subspace:</p><p>? subtransform = [0,1,0; 0,0,1]~</p><p>[0 0]</p><p>[1 0]</p><p>[0 1]</p><p>Find shortest vectors in the mapping lattice:</p><p>? maplll(starling11*subtransform)</p><p>[-4 1]</p><p>[9 -2]</p><p>M = weight mapping(starling11);<br/>? qfminim(subtransform~*M~*M*subtransform, 20, 10, 2)[3]</p><p>[-4 -8 -12 -16]</p><p>[9 18 27 36]</p><p>This isn&apos;t right. Equal temperaments:</p><p>? (starling11*subtransform*qfminim(subtransform~*M~*M*subtransform, 30, 20, 2)[3])[1,]<br/>[0, 0, 0, 0, 0]</p><p>Orthogonal complement:</p><p>? orthog(X, y) = X - X * y~*y * X / (y*X*y~)<br/>? (starling11*subtransform*qfminim(subtransform~*orthog(M~*M, [1,0,0])*subtransform, 0.06, 10, 2)[3])[1,]<br/>[-3, -18]</p><p>Makes more sense but still not right.</p><p>Try Cangwu badness:</p><p>? (starling11*subtransform*qfminim(subtransform~*starling11~*Cangwu metric(7, 1/12e2)*starling11*subtransform, 0.005, 10, 2)[3])[1,]<br/>[12, 27]<br/>? (starling11*subtransform*qfminim(subtransform~*starling11~*Cangwu metric(7, 1/12e2)*starling11*subtransform, 0.006, 10, 2)[3])[1,]<br/>[12, 27, 15]<br/>? (starling11*subtransform*qfminim(subtransform~*starling11~*Cangwu metric(7)*starling11*subtransform, 0.006, 10, 2)[3])[1,]<br/>[12, 27, 39, 15]<br/>? (starling11*subtransform*qfminim(subtransform~*starling11~*Cangwu metric(7,0.0085)*starling11*subtransform, 0.1, 5, 2)[3])[1,]<br/>[3, 6, 12, 15, 9]</p><p>Looks like Gene&apos;s 3&amp;15.  But 12 is still linearly independent and better.</p><p>Orthogonal Cangwu badness works:</p><p>? (starling11*subtransform*qfminim(subtransform~*orthog(starling11~*Cangwu metric(7, 0.0085)*starling11, [1,0,0])*subtransform, 0.008, 10, 2)[3])[1,]<br/>[-3, -15]</p><p>Find shortest vectors in the interval sublattice:</p><p>Ki = icmet(starling11);<br/>? qfminim(subtransform~ *Ki* subtransform, 10, 10, 2)[3]</p><p>[2 -3]</p><p>[1 -2]</p><p>These are Carl&apos;s unison vectors (below).</p><p>? qfminim(subtransform~ *Ki* subtransform, 13, 10, 2)[3]</p><p>[2 -3 -1]</p><p>[1 -2 -1]</p><p>[1,1] is what Gene uses.  So the reduced basis is [1,1;2,1] giving unison vectors of [0,1,1;0,2,1].</p><p>Confirm they match Gene&apos;s:</p><p>? genevec = [4,-1,-1,0;-6,-5,6,0];</p><p>? get ratios(genevec)<br/>[16/15, 15625/15552]<br/>? genevec*starling11</p><p>[0 2 1]</p><p>[0 1 1]</p><p>[3,2] -&gt; [0,3,2] is Carl&apos;s:</p><p>Simplest UVs of 11 note val:<br/>? uv11 = matkerint((starling11*[1;0;0])~)~;<br/>? get ratios(uvlll(uv11) * uv11)<br/>[15/16, 49/45, 189/200]<br/>? uvlll(uv11) * uv11 * starling11</p><p>[0 -2 -1]</p><p>[0 3 2]</p><p>[0 -2 -1]</p><p>? carlvec = [4,-1,-1,0;-2,-6,5,0;0,-2,-1,2];<br/>? get ratios(carlvec)<br/>[16/15, 3125/2916, 49/45]<br/>? carlvec*starling11</p><p>[0 2 1]</p><p>[0 3 2]</p><p>[0 3 2]</p><p>Carl got 49/45 from the TM-reduced kernel of the 11-equal mapping.<br/>Gene replaced it with 3125/2916.</p><p>Gene is looking for unison vectors orthogonal to 2:1, not the 11-equal mapping.</p><p>Carl&apos;s block definers:</p><p>? matdet([11,27,12;0,2,1;0,3,2])<br/>11<br/>? matadjoint([2,1;3,2])</p><p>[2 -1]</p><p>[-3 2]</p><p>? carlmap = starling11*[1,0,0;0,2,-1;0,-3,2]</p><p>[11 18 -3]</p><p>[18 29 -5]</p><p>[26 42 -7]</p><p>[31 50 -8]</p><p>? carlvec*carlmap</p><p>[0 1 0]</p><p>[0 0 1]</p><p>[0 0 1]</p><p>? matadjoint([11,27,12;0,2,1;0,3,2])</p><p>[1 -18 3]</p><p>[0 22 -11]</p><p>[0 -33 22]</p><p>Gene&apos;s:</p><p>? matdet([11,27,12;0,2,1;0,1,1])<br/>11<br/>? matadjoint([2,1;1,1])</p><p>[1 -1]</p><p>[-1 2]</p><p>? genemap = starling11 * [1,0,0;0,1,-1;0,-1,2]</p><p>[11 15 -3]</p><p>[18 24 -5]</p><p>[26 35 -7]</p><p>[31 42 -8]</p><p>? genevec*genemap</p><p>[0 1 0]</p><p>[0 0 1]</p><p>? matadjoint([11,27,12;0,2,1;0,1,1])</p><p>[1 -15 3]</p><p>[0 11 -11]</p><p>[0 -11 22]</p><p>*/</p><p>(5) If you take all 11 Fokker blocks for these commas, you find the transversal for the hobbit scale is one of them. But you don&apos;t need to worry about that; instead take just one such Fokker block, and for each scale step z, project z and find which of the nine choices z+-v2+-v3 is closest to the origin. Nine should be enough, but 25 would not unduly strain computing resources. The corresponding 5-limit interval is in the transversal for the hobbit.</p><p>Step five involves the problem of finding a lattice point closest to a given point, which in theory is NP-hard. In spite of your no doubt fervently held belief that P does not equal NP, we don&apos;t actually have a hard problem, since in rank three we are looking at a planar lattice, and we can&apos;t stack up very many commas without running over the boundries for a scale step.</p><p>By the way, the counterexample I thought I had to the claim that all hobbits come from a Minkowski basis in terms of the projection metric was a mistake, so I suppose I&apos;d better see if I can think of a proof.<br/>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, &quot;genewardsmith&quot; &lt;genewardsmith@...&gt; wrote:</p><p>&gt; (5) If you take all 11 Fokker blocks for these commas, you find the transversal for the hobbit scale is one of them. But you don&apos;t need to worry about that; instead take just one such Fokker block, and for each scale step z, project z and find which of the nine choices z+-v2+-v3 is closest to the origin. Nine should be enough, but 25 would not unduly strain computing resources. The corresponding 5-limit interval is in the transversal for the hobbit.</p><p>I was assuming we&apos;d switched basis to 16/15 15625/15552 for v2 and v3; if we don&apos;t, we&apos;d better go with the 25.</p><p>/*<br/>? factor(15625/15552)</p><p>[2 -6]</p><p>[3 -5]</p><p>[5 6]</p><p>? monzos = [1,0,0;4,-1,-1;-6,-5,6]</p><p>[1 0 0]</p><p>[4 -1 -1]</p><p>[-6 -5 6]</p><p>? get ratios(monzos)<br/>[2, 16/15, 15625/15552]<br/>? M = weight intervals(monzos)</p><p>[1.000000000000000000000000000 0 0]</p><p>[4.000000000000000000000000000 -1.584962500721156181453738944 -2.321928094887362347870319429]</p><p>[-6.000000000000000000000000000 -7.924812503605780907268694720 13.93156856932417408722191658]</p><p>? Mp = pseudo inverse(M)</p><p>[0.9999999999999999999999999997 -8.35998218 E-28 -2.523768207 E-27]</p><p>[1.032430505844203078890135278 -0.3441435019480676929633784244 -0.05735725032467794882722974046]</p><p>[1.017962773628019937947524617 -0.1957620718515422957591393503 0.03915241437030845915182787519]</p><p>? M*Mp</p><p>[0.9999999999999999999999999997 -8.35998218 E-28 -2.523768207 E-27]</p><p>[-1.009741958 E-27 0.9999999999999999999999999960 -1.798602864 E-26]</p><p>[-2.221432309 E-27 -1.923558431 E-26 1.000000000000000000000000111]</p><p>? Q = Mp*M;<br/>? P = matid(3) - Q</p><p>[-1.148581478 E-26 -2.132541567 E-26 3.321892208 E-26]</p><p>[-2.338183723 E-26 -1.958899400 E-26 4.268684131 E-26]</p><p>[3.532203590 E-26 4.074939893 E-26 -7.58063775 E-26]</p><p>*/</p><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, &quot;genewardsmith&quot; &lt;genewardsmith@...&gt; wrote:</p><p>&gt; Now form a projection matrix by the following proceedure:<br/>&gt;<br/>&gt; (1) Weight the monzos for 2, 16/15 and 3125/2916 by &lt;1 log2(3) log2(5)|; call these u1, u2, and u3.</p><p>Sorry, I mean weight the monzos for 2 and 126/125! The matrix M has rows which are the weighted monzos for 2 and 126/125.</p><p>/*</p><p>? factor(126/125)</p><p>[2 1]</p><p>[3 2]</p><p>[5 -3]</p><p>[7 1]</p><p>? monzos = [1,0,0,0;4,-1,-1,0;1,2,-3,1];<br/>? get ratios(monzos)<br/>[2, 16/15, 126/125]<br/>? M = weight intervals(monzos)</p><p>[1.000000000000000000000000000 0 0 0]</p><p>[4.000000000000000000000000000 -1.584962500721156181453738944 -2.321928094887362347870319429 0]</p><p>[1.000000000000000000000000000 3.169925001442312362907477888 -6.965784284662087043610958289 2.807354922057604107441969317]</p><p>? Mp = pseudo inverse(M)</p><p>[0.9999999999999999999999999998 -3.707692210 E-28 1.249331070 E-28]</p><p>[1.297010414729281449203816095 -0.3508973750862449556218754685 0.1065790856156983732836857806]</p><p>[0.8373588888865278630897888805 -0.1911518362106499953681258644 -0.07275154404392788161728542350]</p><p>[0.2569805628700864811485074050 -0.07808207388092430656903012342 0.05534773265361074512761308937]</p><p>? M*Mp</p><p>[0.9999999999999999999999999998 -3.707692210 E-28 1.249331070 E-28]</p><p>[-7.573064690 E-28 0.9999999999999999999999999982 1.527234712 E-27]</p><p>[-7.57306469 E-29 1.214845794 E-27 1.000000000000000000000000006]</p><p>? Q = Mp*M</p><p>[0.9999999999999999999999999985 9.83683891 E-28 -9.35760271 E-30 3.507315730 E-28]</p><p>[1.457814953 E-27 0.8940068892372473303163575160 0.07235155397949413003235751600 0.2992053205916296218042221140]</p><p>[-8.07793567 E-28 0.07235155397949413003235751659 0.9506123810729101665391023779 -0.2042394052590115104309951386]</p><p>[7.115525366 E-28 0.2992053205916296218042221139 -0.2042394052590115104309951388 0.1553807296898425031445401115]</p><p>? P = matid(3) - Q<br/>  ***   impossible addition t_MAT + t_MAT.<br/>? P = matid(4) - Q</p><p>[1.539856487 E-27 -9.83683891 E-28 9.35760271 E-30 -3.507315730 E-28]</p><p>[-1.457814953 E-27 0.1059931107627526696836424840 -0.07235155397949413003235751600 -0.2992053205916296218042221140]</p><p>[8.07793567 E-28 -0.07235155397949413003235751659 0.04938761892708983346089762206 0.2042394052590115104309951386]</p><p>[-7.115525366 E-28 -0.2992053205916296218042221139 0.2042394052590115104309951388 0.8446192703101574968554598885]</p><p>*/</p><p>Both &lt;11 17 25 30| and &lt;11 18 26 31| support starling, but the second one seems preferable in terms of tuning.</p><p>*<br/>* response<br/>*</p><p>&gt;&gt;&gt; starling = regular.Temperament(regular.limit7, 27, 19, 12)<br/>&gt;&gt;&gt; regutils.nameThatMapping(starling.melody)<br/>(&apos;Starling&apos;, 0)<br/>&gt;&gt;&gt; regutils.nameThatMapping(starling.melody+[[11,18,26,31]])<br/>(&apos;Starling&apos;, 0)<br/>&gt;&gt;&gt; regutils.nameThatMapping(starling.melody+[[11,17,25,30]])<br/>(&apos;Starling&apos;, 0)<br/>&gt;&gt;&gt; h11 = [11,17,25,30]<br/>&gt;&gt;&gt; g11 = [11,18,26,31]<br/>&gt;&gt;&gt; regutils.nameThatMapping(starling.melody+[h11])<br/>(&apos;Starling&apos;, 0)<br/>&gt;&gt;&gt; regutils.nameThatMapping(starling.melody+[g11])<br/>(&apos;Starling&apos;, 0)<br/>&gt;&gt;&gt; regutils.lattice_reduction(starling.melody + [g11])<br/>[[1, 0, 0, -1], [0, 1, 0, -2], [0, 0, 1, 3], [0, 0, 0, 0]]<br/>&gt;&gt;&gt; regutils.lattice_reduction(starling.melody + [h11])<br/>[[1, 0, 0, -1], [0, 1, 0, -2], [0, 0, 1, 3], [0, 0, 0, 0]]<br/>&gt;&gt;&gt; regutils.lattice_reduction(starling.melody[1:] + [h11])<br/>[[1, 0, 0, -1], [0, 1, 0, -2], [0, 0, 1, 3]]<br/>&gt;&gt;&gt; regutils.lattice_reduction(starling.melody[1:] + [g11])<br/>[[1, 0, 0, -1], [0, 1, 0, -2], [0, 0, 2, 6]]<br/>&gt;&gt;&gt; regutils.lattice_reduction(starling.melody[:-1] + [g11])<br/>[[1, 0, 0, -1], [0, 1, 1, 1], [0, 0, 2, 6]]<br/>&gt;&gt;&gt; regutils.lattice_reduction(starling.melody[:1] + starling.melody[-1:] + [g11])<br/>[[1, 0, 0, -1], [0, 1, 0, -2], [0, 0, 1, 3]]<br/>&gt;&gt;&gt; regutils.lattice_reduction(starling.melody)<br/>[[1, 0, 0, -1], [0, 1, 0, -2], [0, 0, 1, 3]]<br/>&gt;&gt;&gt; starlingene = [g11] + starling.melody[:1] + starling.melody[-1:]<br/>&gt;&gt;&gt; sgene = regular.RegularTemperament(regular.limit7, starlingene)<br/>&gt;&gt;&gt; sgene<br/>Starling<br/>&gt;&gt;&gt; print sgene<br/>Starling</p><p>mapping by steps:<br/>[&lt;11, 18, 26, 31],<br/> &lt;27, 43, 63, 76],<br/> &lt;12, 19, 28, 34]&gt;</p><p>step tunings:<br/>&lt;-29.704, 74.314, -39.995] cents</p><p>reduced mapping:<br/>[&lt;1, 0, 0, -1],<br/> &lt;0, 1, 0, -2],<br/> &lt;0, 0, 1, 3]&gt;</p><p>tuning map:<br/>[1199.795, 1900.927, 2789.622, 3367.214&gt; cents</p><p>scalar complexity: 0.099<br/>RMS weighted error: 0.840 cents/octave<br/>max weighted error: 1.425 cents/octave</p><p>&gt;&gt;&gt; &apos; &apos;.join([&apos;%.3f&apos;%x for x in sgene.tunedBlock()])<br/>&apos;113.248 192.177 345.420 424.349 577.593 656.522 809.765 888.694 1041.937 1120.866 1199.795&apos;<br/>&gt;&gt;&gt; set([int(interval*1000+0.5) for interval in regular.intervals(sgene.tunedBlock())])<br/>set([113248, 78929, 153243])<br/>&gt;&gt;&gt; regular.fokkerBlock(11,27,12)<br/>[(1, 3, 2), (2, 5, 3), (3, 8, 4), (4, 10, 5), (5, 13, 6), (6, 15, 7), (7, 18, 8), (8, 20, 9), (9, 23, 10), (10, 25, 11), (11, 27, 12)]</p><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:<br/>&gt;<br/>&gt; On 26 October 2010 23:07, genewardsmith &lt;genewardsmith@...&gt; wrote:<br/>&gt;<br/>&gt; &gt; Hobbits are constructed using notes of minimal complexity relative to the temperament and under the assumption we are constructing scales with octave repetition. How do you define &quot;minimal complexity&quot;?<br/>&gt;<br/>&gt; There&apos;s no obvious way of measuring the complexity of intervals in a<br/>&gt; higher-rank temperament.</p><p>Whether or not it&apos;s obvious, Euclidean distance on the subspace the TOP-RMS projection projects orthogonally onto is precisely a way of measuring complexity for higher-rank temperaments. In fact, it even works for rank one, where it gives something proportional to the count of scale steps. What&apos;s less obvious is whether it&apos;s legitimate to get rid of octaves by adding 2 to the commas, but it seems to work, so I think my characterization is accurate.</p><p>*<br/>* response<br/>*</p><p>inverse(x) = matadjoint(x)/matdet(x)</p><p>M = weight mapping(mapping) /* vals as columns */<br/>scalar complexity = sqrt(matdet(M~*M)/matsize(M)[1])<br/>P = M * inverse(M~*M) * M~<br/>{<br/>    M = weight intervals(uvs)<br/>    P = M~ * inverse(M*M~) * M<br/>}<br/>complexity = interval*P*interval~<br/>Tenney weighting(mapping) = {<br/>    size = matsize(mapping)[1];<br/>    matrix(size, size, i, j, (i==j) * log(2) / log(prime(i)))<br/>}<br/>W = Tenney weighting(mapping)<br/>P = W*mapping*inverse(mapping~*W*W*mapping)*mapping~*W<br/>JI: P = I<br/>for intervals in temperament:<br/>K = inverse(mapping~*W*W*mapping)<br/>comp(interval) = interval*K*interval~<br/>tempcomp(interval) = interval*mapping*K*mapping~*interval~</p><p>example session:</p><p>? mean5 = [31,12;49,19;72,28];<br/>? K = inverse(mean5~*W*W*mean5);<br/>? comp(interval) = interval*K*interval~<br/>? comp([31,12])<br/>0.74019667948570838578038457092870693813812152114868<br/>? tempcomp(interval) = interval*mean5*K*mean5~*interval~<br/>? tempcomp([1,0,0])<br/>0.74019667948570838578038457092870693813812152114868<br/>? tempcomp([-1,1,0])<br/>0.30746088901595324088268807370952846463394272923835<br/>? tempcomp([2,-1,0])<br/>1.2227439000359748292943830509315280776811108650325<br/>? tempcomp([-2,0,1])<br/>9.2808515944725910182950307134136245859679426695721<br/>? tempcomp([1,-1,1])<br/>2.7671480011435791679441926633857561817054845631452<br/>? sqrt(tempcomp([-2,0,1])/4)<br/>1.5232245069647966225810330927703830323631327757665<br/>? tempcomp([-3,2,0])<br/>2.3202128986181477545737576783534061464919856673930<br/>? qfminim(K, 3.0, 20, 2)[3]</p><p>[18 36 54 31 49 13 67 -5 85 80 62]</p><p>[7 14 21 12 19 5 26 -2 33 31 24]</p><p>? mystery = [29, 46, 67, 81, 100, 107; 58, 92, 135, 163, 201, 215]~;<br/>? qfminim(inverse(weight mapping(mystery)~ * weight mapping(mystery)), 0.01, 20, 2)[3]</p><p>[1 2 3 4]</p><p>[2 4 6 8]</p><p>alternative:</p><p>redmap = mapping * maplll(mapping) /* maybe Hermite or something */<br/>G = redmap~ * W*W * redmap<br/>comp(interval) = interval*G*interval~ /* vector in temperament */<br/>Gt = redmap~ * W /* transforms to a lattice with Euclidean norm */<br/>comp(interval) = interval*Gt*Gt~*interval~<br/>K = redmap * redmap~ * W*W * redmap * redmap~<br/>Kt = redmap * redmap~ * W<br/>tempcomp(interval) = interval*Kt*Kt~*interval~ /* vector in ratio space */<br/>X = maplll(mapping) /* unimodular transformation */<br/>Gt = X~ * mapping~ * W<br/>Kt = mapping * X*X~ * mapping~ * W</p><p>example session:</p><p>? mean5 = [31,12;49,19;72,28];<br/>? W = Tenney weighting(mean5);<br/>? X = maplll(mean5) /* each row is a generator/period ratio */</p><p>[7 -12]</p><p>[-18 31]</p><p>? inverse(X) /* rows define generators */</p><p>[31 12]</p><p>[18 7]</p><p>? bezout(31,12)<br/>[-5, 13, 1]<br/>? 12-5<br/>7<br/>? 31-13<br/>18<br/>? redmap = mean5*X</p><p>[1 0]</p><p>[1 1]</p><p>[0 4]</p><p>? [1,0,0]*redmap<br/>[1, 0]<br/>? [-1,1,0]*redmap<br/>[0, 1]<br/>? [-2,0,1]*redmap<br/>[-2, 4]<br/>? W = Tenney weighting(mean5)</p><p>[1.0000000000000000000000000000000000000000000000000 0 0]</p><p>[0 0.63092975357145743709952711434276085429958564013188 0]</p><p>[0 0 0.43067655807339305067010656876396563206979193207976]</p><p>? Kt = redmap * redmap~ * W</p><p>[1.0000000000000000000000000000000000000000000000000 0.63092975357145743709952711434276085429958564013188 0]</p><p>[1.0000000000000000000000000000000000000000000000000 1.2618595071429148741990542286855217085991712802638 1.7227062322935722026804262750558625282791677283190]</p><p>[0 2.5237190142858297483981084573710434171983425605275 6.8908249291742888107217051002234501131166709132762]</p><p>? tempcomp(interval) = interval*Kt*Kt~*interval~<br/>? tempcomp([1,0,0])<br/>1.3980723539417400086049989597545217146411588729548<br/>? tempcomp([-1,1,0])<br/>3.3657891167248551588902584948517200500413502223106<br/>? tempcomp([0,1,0])<br/>5.5600061785500751847052553741152851939648268411752<br/>? tempcomp([2,-1,0])<br/>3.9677167627831151502852595350971983354001913493558<br/>? tempcomp([-2,0,1])<br/>53.075757620296802438984148400573260224967697081512<br/>? tempcomp([1,1,-1])<br/>31.107523218989776361172334775629306733242881017157<br/>? sqrt(tempcomp([-2,0,1])/4)<br/>3.6426555430172368426362816254074846406837109449425<br/>? tempcomp([4,-1,-1])<br/>84.785208485344838791551484216448045243569419225714<br/>? tempcomp([-3,2,0])<br/>13.268939405074200609746037100143315056241924270378<br/>? tempcomp([1,-2,1])<br/>13.2689394050<br/>? qfminim(X*X~ * mean5~ * W*W * mean5 * X*X~, 20, 20, 2)[3]</p><p>[31 62 93 18 49 -13 80 -44 111 -75 5 36 -26 67]</p><p>[12 24 36 7 19 -5 31 -17 43 -29 2 14 -10 26]</p><p>? qflllgram(mean5~*W*W*mean5)==X<br/>1</p><p>                            Graham</p></div><h3>Carl Lumma &#x3C;carl@lumma.org&#x3E;</h3><span>6/25/2011 11:22:51 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Graham,</p><p>&gt;From what I remember, Gene was finding good unison vectors<br/>&gt;for the equal temperament (val) according to temperamental<br/>&gt;complexity defined for the rank 3 temperament.  I couldn&apos;t<br/>&gt;reproduce Gene&apos;s working.  Carl was finding simple unison<br/>&gt;vectors in full JI space, and whether or not that&apos;s how he<br/>&gt;did it, he agreed with TLLL-reduction.  Carl&apos;s method looks<br/>&gt;simple and good enough to implement but I didn&apos;t get<br/>&gt;further than this.</p><p>Thanks for digging this up.  I don&apos;t have time to study it<br/>now, but I can say two things:</p><p>* IIRC, Gene produced the scale with the lowest mean variety.</p><p>* My method is described at<br/><a href="http://tech.groups.yahoo.com/group/tuning-math/message/18305">http://tech.groups.yahoo.com/group/tuning-math/message/18305</a></p><p>-Carl</p></div>