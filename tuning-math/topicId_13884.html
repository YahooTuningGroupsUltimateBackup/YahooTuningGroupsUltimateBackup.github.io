<a href="/tuning-math">back to list</a><h1>Prime-based Rank 2 temperament search code</h1><h3><a id=13884 href="#13884">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>1/7/2006 12:39:18 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I&apos;ve got my latest code online.  It does the calculations you need to find rank 2 temperaments without worrying about tonality diamonds or general wedge products or any other cruft:</p><p><a href="http://www.microtonal.co.uk/temper/regular.py">http://www.microtonal.co.uk/temper/regular.py</a></p><p>It tests itself if you run it as a script -- churning out lots of unreadable generator mappings.  It&apos;s pretty fast, partly because I optimized the ET search code for the weighted RMS.  That means TOP looks unfairly slow, but it was still very slow to start with.  You need external libraries to do the TOP optimization.</p><p>Then this code uses Herman&apos;s simple wedgie function instead of inverse modulos and the like:</p><p><a href="http://www.microtonal.co.uk/temper/regular_wedgie.py">http://www.microtonal.co.uk/temper/regular_wedgie.py</a></p><p>It&apos;s a bit shorter than the other code, and also a bit slower.  A lot of the extra time is spent in the hcf routine, probably because it has to loop over the whole wedgie to check for contorsion, and the wedgies get quite big in the 31-limit.</p><p>                 Graham</p></div><h3><a id=13887 href="#13887">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@svpal.org&#x3E;</h3><span>1/7/2006 2:32:59 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@g...&gt; wrote:</p><p>&gt; Then this code uses Herman&apos;s simple wedgie function instead of inverse<br/>&gt; modulos and the like:</p><p>I used a triangular distance function, which should also be fast.<br/>You&apos;d have to take a look to see which is faster, but it looks like<br/>probably Herman has me beat, because I use a few multiplications. You<br/>put u[i]*v[j] - u[j]*v[i] for vals u and v in the kth position, where<br/>k = n*(i-1) - i*(i+1)/2 + j, with n the length of u and v.</p></div>