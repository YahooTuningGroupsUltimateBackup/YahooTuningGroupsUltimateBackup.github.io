<a href="/tuning-math">back to list</a><h1>Wedge products</h1><h3>genewardsmith@juno.com</h3><span>11/26/2001 8:49:04 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>The wedge product is associative and distributive, but the key thing<br/>to remember about it is that it is anticommunitive, which means that<br/>u^v = - v^u. This entails that u^u = 0. When we apply this to basis<br/>vectors, we see that if we start with four basis vectors {e2, e3, e5,<br/>e7} and take wedge products, we get six basis vectors for the vector<br/>space of the wedge product, ie {e2^e3, e2^e5, e2^e7, e3^e5, e3^e7,<br/>e5^e7}. Thus 4 choose 1 = four dimensions goes to 4 choose 2 = six<br/>dimensions. If we take a wedge product in this six-dimensional space<br/>with another 4-d vector, or in other words a triple wedge product, we<br/>get a basis {e3^e5^e7, e2^e5^e7, e2^e3^e7, e2^e3^e5} of 4 choose 3 =<br/>four dimensions. If we take a quadruple wedge product, we get a 4<br/>choose 4 = one-demensional space, with basis element {e2^e3^e5^e7};<br/>this can therefore be identified with a scalar, which makes the<br/>quadruple wedge product the determinant. The triple wedge product,<br/>being in effect a thing which takes an interval and sends it to an<br/>integer, can be identified with a val. The triple wedge product of<br/>three 7-limit intervals is the val we get by putting the three<br/>intervals in as rows of a 4x4 matrix and making the top row the four<br/>basis vectors.</p><p>This same game can, of course, be played in any number of dimensions,<br/>where we get a Pascal&apos;s triangle arrangement to the dimensions. In<br/>the 11-limit, with five dimensions, it goes 5 10 10 5 1 and we get up<br/>to quintuple wedge products. The wedge product of two intervals will<br/>be in a space of dimension n choose 2 = n(n-1)/2, and the length of<br/>the vector in the ordinary norm will be the area of the paralleogram<br/>defined by the two intervals, and the direction will be defined by<br/>the orientation of the paralleogram. In four dimensions, this *isn&apos;t*<br/>simply a vector, because a vector is perpendicular to *three*<br/>dimensions, not two. The double wedge product is therefore an<br/>oriented area, the triple wedge product an oriented volume (defined<br/>by three vectors) and so forth--down finally to the determinant.</p><p>The coefficients of the double wedge product can be thought of as the<br/>areas of the paralleogram of interval classes defined by taking only<br/>two of the four primes. If there is a common factor in each such<br/>reduction, it spells torsion. We may also see the torsion in<br/>comparing lenghts of wedge products, or their coefficients. We have</p><p>64/63^49/48 = [-14, 0, 8, 0, -5, 0] = u</p><p>u.u = 3*5*19</p><p>16807/15552^256/243 = [70, 0, -40, 0, 25, 0] = v</p><p>v = -5 u; and v.v = 3*5^3*19, showing it is 5 times longer.</p><p>If someone wants to program this, the following might help:</p><p>[u1, u2, u3, u4]^[v1, v2, v3, v4] = [u1*v2-v1*u2, u1*v3-v1*u3,<br/>u1*v4-v1*u4, u2*v3-v3*u2, u2*v4-v2*u4, u3*v4-v3*u4]</p></div><h3>graham@microtonal.co.uk</h3><span>11/27/2001 9:11:00 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>In-Reply-To: &lt;<a href="mailto:9tv600+a9o8@eGroups.com">9tv600+a9o8@eGroups.com</a>&gt;<br/>Gene wrote:</p><p>&gt; four dimensions. If we take a quadruple wedge product, we get a 4<br/>&gt; choose 4 = one-demensional space, with basis element {e2^e3^e5^e7};<br/>&gt; this can therefore be identified with a scalar, which makes the<br/>&gt; quadruple wedge product the determinant.</p><p>Okay, if you were to do that in octave-equivalent space, this would be the<br/>Fokker determinant.  In octave-equivalent 7-limit space, it&apos;s the scalar<br/>triple product, which Fokker would have recognised as being a kind of<br/>volume.</p><p>&gt; The triple wedge product,<br/>&gt; being in effect a thing which takes an interval and sends it to an<br/>&gt; integer, can be identified with a val. The triple wedge product of<br/>&gt; three 7-limit intervals is the val we get by putting the three<br/>&gt; intervals in as rows of a 4x4 matrix and making the top row the four<br/>&gt; basis vectors.</p><p>That&apos;s the same as what I&apos;m getting by taking the left hand column of the<br/>adjoint, with an arbitrary row to make up the numbers.  So with octave<br/>specific unison vectors, it describes the related equal temperament.  With<br/>octave equivalent vectors it gives you the mapping.  In three dimensions,<br/>it&apos;s the same as the vector product.</p><p>And all this has something to do with wedge products?</p><p>                 Graham</p></div><h3>graham@microtonal.co.uk</h3><span>12/6/2001 11:03:00 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Okay, let&apos;s go right back to the beginning.  I already have a tutorial<br/>online for matrix algebra.  See<br/>&lt;<a href="http://www.microtonal.co.uk/matritut.htm">http://www.microtonal.co.uk/matritut.htm</a>&gt;.  If you take the basic<br/>equivalence there, that</p><p>5x + 3y + z</p><p>is the same as</p><p>(5 3 1)(x)<br/>       (y)<br/>       (z)</p><p>you can similarly write any row vector (a b c) as</p><p>(a b c)(e1)<br/>       (e2)<br/>       (e3)</p><p>or</p><p>a*e1 + b*e2 + c*e3</p><p>where * is a normal multiplication and ei simply means the ith element of<br/>the basis.  You can then multiply two vectors (a b) and (c d) to get</p><p>(a*e1 + b*e2) * (c*e1 + d*e2)</p><p>which comes out as</p><p>a*c*e1*e1 + a*d*e1*e2 + b*c*e2*e1 + b*d*e2*e2</p><p>The music matrices I usually talk about have a basis H, where each entry<br/>is a number.  So a normal multiplication really does work</p><p>(a b)H * (c d)H</p><p> = (a*log(2) + b*log(3)) * (c*log(2) + d*log(3))</p><p> = a*c*log(2)*log(2) + a*d*log(2)*log(3)<br/>   + b*c*log(3)*log(2) + b*d*log(3)*log(3)</p><p> = a*c*log(2)**2 + (a*d + b*c)*log(2)*log(3) + b*d*log(3)**2</p><p>But in general you can&apos;t do that, because there isn&apos;t a rule for<br/>multiplying elements of a basis.  The wedge product is a specific rule<br/>for multipying bases.  NOW PAY ATTENTION!</p><p>ei^ej = - ej^ei</p><p>According to Gene, that&apos;s the full definition of a wedge product.  So, as<br/>long as you paid attention when I told you you can ignore the rest.  You<br/>know what a wedge product is.  It follows that</p><p>ei^ei = -ei^ei</p><p>ei^ei + ei^ei = 0</p><p>2*(ei^ei) = 0</p><p>ei^ei = 0</p><p>So the wedge product of (a b) and (c d) is</p><p>(a b)^(c d)<br/>= (a*e1 + b*e2) ^ (c*e1 + d*e2)<br/>= a*c*e1^e1 + a*d*e1^e2 + b*c*e2^e1 + b*d*e2^e2<br/>= a*d*e1^e2 - b*c*e2^e1<br/>= (a*d - b*c)</p><p>the same as the determinant</p><p>|a b|<br/>|c d|</p><p>It gets more complicated in three dimensions</p><p>A^B<br/>= (a1*e1 + a2*e2 + a3*e3)^(b1*e1 + b2*e2 + b3*e3)<br/>= a1*b1*e1^e1 + a1*b2*e1^e2 + a1*b3*e1^e3<br/>  + a2*b1*e2^e1 + a2*b2*e2^e2 + a2*b3*e2^e3<br/>  + a3*b1*e3^e1 + a3*b2*e3^e2 + a3*b3*e3^e3</p><p>= a1*b2*e1^e2 + a1*b3*e1^e3<br/>  - a2*b1*e1^e2 + a2*b3*e2^e3<br/>  - a3*b1*e1^e3 - a3*b2*e2^e3</p><p>= (a1*b2 - a2*b1)*e1^e2 + (a1*b3 - a3*b1)*e1^e3<br/>  + (a2*b3 - a3*b2)*e2^e3</p><p>which is the same as the determinant</p><p>|e2^e3 e3^e1 e1^e2|<br/>|  a1   a2    a3  |<br/>|  b1   b2    b3  |</p><p>That&apos;s analogous to the cross product of vectors, where AxB is</p><p>|x  y   z|<br/>|a1 a2 a3|<br/>|b1 b2 b3|</p><p>and, if A and B are octave-specific 5-limit unison vectors, it happens<br/>that AxB gives the number of steps to each prime consonance.  Or, if A and<br/>B are octave-equivalent 7-limit commatic unison vectors, AxB is the<br/>generator mapping.</p><p>I can&apos;t be bothered to work out the triple wedge product, but you&apos;ll find<br/>it&apos;s all in terms of e1^e2^e3.  So it&apos;s something like the determinant</p><p>|a1 a2 a3|<br/>|b1 b2 b3|<br/>|c1 c2 c3|</p><p>And the right number of wedge products in the right number of dimensions<br/>will always give a determinant.</p><p>As determinants and cross products are already useful in dealing with<br/>unison vectors, it shouldn&apos;t be such a surprise that wedge products in<br/>general are also useful.  I still don&apos;t know how they&apos;re useful, but Gene<br/>assures us that they are.</p><p>What is this &quot;wedge invariant&quot; he keeps using, and how do you go from it<br/>to get a list of unison vectors?</p><p>I&apos;m not sure how to implement these things in Python.  I could implement<br/>vectors like dictionaries, so</p><p>A = {e1:a1, e2:a2, e3:a3}<br/>B = {e1:b1, e2:b2, e3:b3}</p><p>then (A^B)[ei^ej] = A[ei]*B[ej] - A[ej]*B[ei]</p><p>so the next problem is what data type ei and ej should be.  Probably<br/>something like tuples:</p><p>A = {(1,):a1, (2,):a2, (3,):a3}<br/>B = {(1,):b1, (2,):b2, (3,):b3}</p><p>that makes them look a bit like lists, so instead of A[1]=a1, we have<br/>A[1,]=a1.  Then, (A^B)[1, 2] = A[1,]*B[2,] + A[2,]*B[1,].</p><p>So this is making some sense, but I still haven&apos;t worked out all the<br/>details needed to write the code.</p><p>                    Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@juno.com&#x3E;</h3><span>12/6/2001 4:01:24 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:</p><p>&gt; What is this &quot;wedge invariant&quot; he keeps using, and how do you go<br/>from it<br/>&gt; to get a list of unison vectors?</p><p>First you order the basis so that a wedge product taken from two ets<br/>or two unison vectors will correspond:</p><p><a href="http://groups.yahoo.com/group/tuning-math/message/1553">http://groups.yahoo.com/group/tuning-math/message/1553</a></p><p>Then you put the wedge product into a standard form, by</p><p>(1) Dividing through by the gcd of the coefficients, and</p><p>(2) Changing sign if need be, so that the 5-limit comma (or unison)<br/>2^w[6] * 3^(-w[2])*5^w[1] where w is the wedgie, is greater than 1.<br/>If it equals 1, go on to the next invariant comma, which leaves out<br/>5, and if that is 1 also to the one which leaves out 3. See</p><p><a href="http://groups.yahoo.com/group/tuning-math/message/1555">http://groups.yahoo.com/group/tuning-math/message/1555</a></p><p>for the invariant commas. The result of this standardization is the<br/>wedge invariant, or wedgie, which uniquely determins the temperament.</p><p>&gt; I&apos;m not sure how to impleme<br/>nt these things in Python.</p><p>The above should do for the 7-limit; in general is another matter.</p></div><h3>graham@microtonal.co.uk</h3><span>12/7/2001 1:14:00 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p><a href="mailto:genewardsmith@juno.com">genewardsmith@juno.com</a> (genewardsmith) wrote:</p><p>&gt; First you order the basis so that a wedge product taken from two ets<br/>&gt; or two unison vectors will correspond:<br/>&gt;<br/>&gt; <a href="http://groups.yahoo.com/group/tuning-math/message/1553">http://groups.yahoo.com/group/tuning-math/message/1553</a></p><p>I think I&apos;ve done that.  All comes down to bubblesort -- one in the eye<br/>for those who say it&apos;s of no practical use!</p><p>&gt; Then you put the wedge product into a standard form, by<br/>&gt;<br/>&gt; (1) Dividing through by the gcd of the coefficients, and</p><p>Okay, that&apos;s easy enough.</p><p>&gt; (2) Changing sign if need be, so that the 5-limit comma (or unison)<br/>&gt; 2^w[6] * 3^(-w[2])*5^w[1] where w is the wedgie, is greater than 1.<br/>&gt; If it equals 1, go on to the next invariant comma, which leaves out<br/>&gt; 5, and if that is 1 also to the one which leaves out 3. See<br/>&gt;<br/>&gt; <a href="http://groups.yahoo.com/group/tuning-math/message/1555">http://groups.yahoo.com/group/tuning-math/message/1555</a><br/>&gt;<br/>&gt; for the invariant commas. The result of this standardization is the<br/>&gt; wedge invariant, or wedgie, which uniquely determins the temperament.</p><p>I&apos;ll need to study that a bit more.</p><p>&gt; &gt; I&apos;m not sure how to impleme<br/>&gt; nt these things in Python.<br/>&gt;<br/>&gt; The above should do for the 7-limit; in general is another matter.</p><p>Oh, it needs to be done in general.  And it&apos;s almost working now.  I still<br/>need to get my wedge invariants to look like yours.  Also to divide<br/>through by common factors, but I&apos;ve done that before.</p><p>To check:</p><p>&gt;&gt;&gt; wedge.wedgeProduct(h12,h22)<br/>{(2, 3): 2, (0, 1): 2, (1, 3): -12, (0, 3): -4, (0, 2): -4, (1, 2): -11}</p><p>That&apos;s numbering from 0 as the 2-direction, 1 as the 5-direction, etc.<br/>Then for the commas</p><p>&gt;&gt;&gt; for i in range(4):<br/>&#x9;print wedge.interval(<br/>&#x9;    reduce(<br/>&#x9;        wedge.wedgeProduct,<br/>&#x9;        ((zeros[:i]+(1,)+zeros[i+1:]), h12, h22)))<br/>&#x9;<br/>&#x9;<br/>[0, -2, -12, 11]<br/>[2, 0, 4, -4]<br/>[12, -4, 0, -2]<br/>[-11, 4, 2, 0]</p><p>which looks right.  I&apos;ll look at it some more tomorrow.  I&apos;m still don&apos;t<br/>know how to do the generator mapping.</p><p>Here&apos;s the library code:</p><p>def wedgeProduct(a, b):<br/>    result = {}<br/>    for base1, value1 in makewedgable(a).items():<br/>        for base2, value2 in makewedgable(b).items():<br/>            value = value1*value2<br/>            for element in base1:<br/>                if element in base2:<br/>                    break<br/>            else:<br/>                base, value = wedgeEquivalent(base1+base2, value)<br/>                result[base] = result.get(base, 0)+value<br/>    return result</p><p>def interval(wedgie):<br/>    result = []<br/>    bases = wedgie.keys()<br/>    for i in range(len(wedgie)):<br/>        for base in bases:<br/>            if i not in base:<br/>                if i%2:<br/>                    result.append(-wedgie[base])<br/>                else:<br/>                    result.append(wedgie[base])<br/>    return result</p><p>def wedgeEquivalent(base, value):<br/>    workingBase = list(base)<br/>    for i in range(len(base)):<br/>        for j in range(i,0,-1):<br/>            if workingBase[j]&lt;workingBase[j-1]:<br/>                workingBase[j-1:j+1] = [<br/>                    workingBase[j],<br/>                    workingBase[j-1]]<br/>                value = -value<br/>    return tuple(workingBase), value</p><p>def addWedges(a, b):<br/>    x = makewedgable(a)<br/>    y = makewedgable(b)<br/>    result = {}<br/>    for element in x.keys()+y.keys():<br/>        result[element]=0<br/>    for key in x.keys():<br/>        result[key] = result[key] + x[key]<br/>    for key in y.keys():<br/>        result[key] = result[key] + y[key]<br/>    return result</p><p>def makewedgable(thing):<br/>    if isinstance(thing, type({})):<br/>        return thing<br/>    else:<br/>        result = {}<br/>        for i in range(len(thing)):<br/>            result[i,]=thing[i]<br/>        return result</p></div><h3>graham@microtonal.co.uk</h3><span>12/8/2001 1:32:00 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Update!</p><p>The code at &lt;<a href="http://www.microtonal.co.uk/temper.py">http://www.microtonal.co.uk/temper.py</a>&gt; has been updated to do<br/>most of the stuff I used to use matrices and Numeric for, but with wedge<br/>products and standard Python 1.5.2.  It&apos;s passed all the tests I&apos;ve tried<br/>so far, still some cleaning up to do.</p><p>My wedge invariants can&apos;t be made unique and invariant in all cases, but<br/>they work most of the time.  I could have a method for declaring of two<br/>wedgable objects are equivalent.  Also, my invariant is very different to<br/>Gene&apos;s.</p><p>I still don&apos;t get the process for calculating unison vectors with wedge<br/>products, especially in the general case.</p><p>One good thing is that the generator mapping (ignoring the period mapping)<br/>which I&apos;m using as my invariant key, is simply the octave-equivalent part<br/>of the wedge product of the commatic unison vectors!</p><p>Example:</p><p>&gt;&gt;&gt; h31 = temper.PrimeET(31, temper.primes[:4])<br/>&gt;&gt;&gt; h41 = temper.PrimeET(41, temper.primes[:4])<br/>&gt;&gt;&gt; h31^h41<br/>{(2, 3): 15, (0, 4): 15, (1, 4): 3, (1, 2): -25, (0, 3): -2, (2, 4): 59,<br/>(0, 2): -7, (3, 4): 49, (1, 3): -20, (0, 1): 6}<br/>&gt;&gt;&gt; (h31^h41).invariant()<br/>(6, -7, -2, 15, -25, -20, 3, 15, 59, 49)</p><p>Gene:<br/>&gt; First you order the basis so that a wedge product taken from two ets<br/>&gt; or two unison vectors will correspond:<br/>&gt;<br/>&gt; <a href="http://groups.yahoo.com/group/tuning-math/message/1553">http://groups.yahoo.com/group/tuning-math/message/1553</a></p><p>I&apos;ve got mine ordered, but it looks like a different order to yours.</p><p>&gt; Then you put the wedge product into a standard form, by<br/>&gt;<br/>&gt; (1) Dividing through by the gcd of the coefficients, and</p><p>Okay, done that</p><p>&gt; (2) Changing sign if need be, so that the 5-limit comma (or unison)<br/>&gt; 2^w[6] * 3^(-w[2])*5^w[1] where w is the wedgie, is greater than 1.<br/>&gt; If it equals 1, go on to the next invariant comma, which leaves out<br/>&gt; 5, and if that is 1 also to the one which leaves out 3. See<br/>&gt;<br/>&gt; <a href="http://groups.yahoo.com/group/tuning-math/message/1555">http://groups.yahoo.com/group/tuning-math/message/1555</a><br/>&gt;<br/>&gt; for the invariant commas. The result of this standardization is the<br/>&gt; wedge invariant, or wedgie, which uniquely determins the temperament.</p><p>Done something like this.</p><p>The problem is with zeroes.  As it stands, the 5-limit interval 5:4 is the<br/>same as the 7-limit interval 5:4 as far as the wedge products are<br/>concerned.  But some zero elements aren&apos;t always present.  Either I can<br/>get rid of them, which might mean that different products have the same<br/>invariant, or enumerate the missing bases when I calculate the invariant.</p><p>The latter problem is the same as the one I&apos;m trying to solve to get all<br/>combinations of a list of unison vectors.</p><p>Another thing would be to ignore the invariants, and add a weak comparison<br/>function.</p><p>As to the unison vectors, in the 7-limit I seem to be getting 4 when I<br/>only wanted 2, so how can I be sure they&apos;re linearly independent?</p><p>             Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@juno.com&#x3E;</h3><span>12/8/2001 1:55:49 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:</p><p>&gt; The code at &lt;<a href="http://www.microtonal.co.uk/temper.py">http://www.microtonal.co.uk/temper.py</a>&gt; has been<br/>updated to do<br/>&gt; most of the stuff I used to use matrices and Numeric for, but with<br/>wedge<br/>&gt; products and standard Python 1.5.2.  It&apos;s passed all the tests I&apos;ve<br/>tried<br/>&gt; so far, still some cleaning up to do.</p><p>What&apos;s the best version of Python for Win98, do you know? In<br/>particular, what is the deal with the &quot;stackless&quot; version?</p><p>&gt; My wedge invariants can&apos;t be made unique and invariant in all<br/>cases, but<br/>&gt; they work most of the time.  I could have a method for declaring of<br/>two<br/>&gt; wedgable objects are equivalent.</p><p>You don&apos;t need to use my system; you could make the first non-zero<br/>coefficient in the basis ordering you use positive.</p><p>Also, my invariant is very different to<br/>&gt; Gene&apos;s.</p><p>It should differ only in the sign or order of basis elements.</p><p>&gt; I still don&apos;t get the process for calculating unison vectors with<br/>wedge<br/>&gt; products, especially in the general case.</p><p>One way to think of the general case is to get the associated matrix<br/>of what I call &quot;vals&quot;, reduce by dividing out by gcds, and solve the<br/>resultant system of linear Diophantine equations, which set each of<br/>the val maps to zero.</p><p>&gt; One good thing is that the generator mapping (ignoring the period<br/>mapping)<br/>&gt; which I&apos;m using as my invariant key, is simply the octave-<br/>equivalent part<br/>&gt; of the wedge product of the commatic unison vectors!</p><p>Or of the wedge product of two ets.</p><p>&gt; I&apos;ve got mine ordered, but it looks like a different order to yours.</p><p>That&apos;s not surprising; the order is not determined by the definition<br/>of wedge product, and I chose mine in a way I thought made sense from<br/>the point of view of usability for music theory.</p><p>&gt; Done something like this.<br/>&gt;<br/>&gt;<br/>&gt; The problem is with zeroes.  As it stands, the 5-limit interval 5:4<br/>is the<br/>&gt; same as the 7-limit interval 5:4 as far as the wedge products are<br/>&gt; concerned.</p><p>This has me confused, because it&apos;s the same as far as I&apos;m concerned<br/>too, unless you mean its vector representation.</p><p> But some zero elements aren&apos;t always present.  Either I can<br/>&gt; get rid of them, which might mean that different products have the<br/>same<br/>&gt; invariant, or enumerate the missing bases when I calculate the<br/>invariant.</p><p>I don&apos;t know what is going on here.</p><p>&gt; As to the unison vectors, in the 7-limit I seem to be getting 4<br/>when I<br/>&gt; only wanted 2, so how can I be sure they&apos;re linearly independent?</p><p>They are never linearly independent. Why do they need to be?</p></div><h3>genewardsmith &#x3C;genewardsmith@juno.com&#x3E;</h3><span>12/8/2001 11:40:08 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:</p><p>&gt; (6, -7, -2, 15, -25, -20, 3, 15, 59, 49)</p><p>&gt; I&apos;ve got mine ordered, but it looks like a different order to yours.</p><p>I don&apos;t think I talked about an 11-limit order. I have a program<br/>which orders the above [6,-7,-2,15,20,-25,15,3,59,49] but I&apos;m hardly<br/>fixated on that ordering.</p><p>One thing which works well for wedge products of a pair of vectors<br/>but which doesn&apos;t work so well for more is the skew-symmetric matrix<br/>form. You take the outer product of the two vectors, and its<br/>transpose, and subtract. It has some redundancy but it&apos;s pretty nice;<br/>however for three vectors you get a cubical array and more<br/>redundancy, and so forth.</p></div><h3>genewardsmith &#x3C;genewardsmith@juno.com&#x3E;</h3><span>12/9/2001 12:26:50 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., &quot;genewardsmith&quot; &lt;genewardsmith@j...&gt; wrote:<br/>&gt; --- In tuning-math@y..., graham@m... wrote:<br/>&gt;<br/>&gt; &gt; (6, -7, -2, 15, -25, -20, 3, 15, 59, 49)<br/>&gt;<br/>&gt; &gt; I&apos;ve got mine ordered, but it looks like a different order to<br/>yours.<br/>&gt;<br/>&gt; I don&apos;t think I talked about an 11-limit order. I have a program<br/>&gt; which orders the above [6,-7,-2,15,20,-25,15,3,59,49] but I&apos;m<br/>hardly<br/>&gt; fixated on that ordering.</p><p>Here&apos;s the matrix form:</p><p>[ 0   6  -7  -2 15]<br/>[-6   0 -25 -20  3]<br/>[ 7  25   0  15 59]<br/>[ 2  20 -15   0 49]<br/>[-15 -3 -59 -49  0]</p><p>One nice thing about this form is that the previous prime limits are<br/>included as the principal minors.</p></div><h3>graham@microtonal.co.uk</h3><span>12/9/2001 8:02:00 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Gene wrote:</p><p>&gt; What&apos;s the best version of Python for Win98, do you know? In<br/>&gt; particular, what is the deal with the &quot;stackless&quot; version?</p><p>Usually the latest stable ActiveState release, so long as you don&apos;t<br/>quibble with the license.</p><p>Stackless is an experimental implementation that has continuations, and<br/>doesn&apos;t need the Global Interpreter Lock.</p><p>&gt; &gt; My wedge invariants can&apos;t be made unique and invariant in all<br/>&gt; cases, but<br/>&gt; &gt; they work most of the time.  I could have a method for declaring of<br/>&gt; two<br/>&gt; &gt; wedgable objects are equivalent.<br/>&gt;<br/>&gt; You don&apos;t need to use my system; you could make the first non-zero<br/>&gt; coefficient in the basis ordering you use positive.</p><p>Yes, that&apos;s what I do.</p><p>&gt; Also, my invariant is very different to<br/>&gt; &gt; Gene&apos;s.<br/>&gt;<br/>&gt; It should differ only in the sign or order of basis elements.</p><p>Looks like it, except for the zeros.</p><p>&gt; &gt; I still don&apos;t get the process for calculating unison vectors with<br/>&gt; wedge<br/>&gt; &gt; products, especially in the general case.<br/>&gt;<br/>&gt; One way to think of the general case is to get the associated matrix<br/>&gt; of what I call &quot;vals&quot;, reduce by dividing out by gcds, and solve the<br/>&gt; resultant system of linear Diophantine equations, which set each of<br/>&gt; the val maps to zero.</p><p>Is your matrix of vals my mapping by steps?  [(41, 31), (65, 49), (95,<br/>72), (115, 87), (142, 107)] for Miracle.  If so, I&apos;m with you until you<br/>get to the Diophantine equations.  I think it&apos;s solving systems of linear<br/>Diophantine equations that I need to know how to do.</p><p>&gt; &gt; One good thing is that the generator mapping (ignoring the period<br/>&gt; mapping)<br/>&gt; &gt; which I&apos;m using as my invariant key, is simply the octave-<br/>&gt; equivalent part<br/>&gt; &gt; of the wedge product of the commatic unison vectors!<br/>&gt;<br/>&gt; Or of the wedge product of two ets.</p><p>Ah, no, not quite.  This works:</p><p>&gt;&gt;&gt; wedgie = reduce(temper.wedgeProduct,<br/>    map(temper.WedgableRatio,<br/>    [(225,224),(385,384),(243,242)]))</p><p>&gt;&gt;&gt; wedgie.octaveEquivalent().flatten()<br/>(0, -6, 7, 2, -15)</p><p>but with the wedge of the temperaments</p><p>&gt;&gt;&gt; (h31^h41).octaveEquivalent().flatten()<br/>(-25, -20, 3, 15, 59, 49)</p><p>so what I have to do is</p><p>&gt;&gt;&gt; (h31^h41).complement().octaveEquivalent().flatten()<br/>(0, -6, 7, 2, -15)</p><p>The complement() method is something like a transpose.  Would that be a<br/>better name for it?  Anyway, my invariant usually works so that wedge<br/>products related in this way compare the same, but not always.</p><p>&gt; &gt; I&apos;ve got mine ordered, but it looks like a different order to yours.<br/>&gt;<br/>&gt; That&apos;s not surprising; the order is not determined by the definition<br/>&gt; of wedge product, and I chose mine in a way I thought made sense from<br/>&gt; the point of view of usability for music theory.</p><p>Oh, well, mine&apos;s numerical order.</p><p>&gt; &gt; The problem is with zeroes.  As it stands, the 5-limit interval 5:4<br/>&gt; is the<br/>&gt; &gt; same as the 7-limit interval 5:4 as far as the wedge products are<br/>&gt; &gt; concerned.<br/>&gt;<br/>&gt; This has me confused, because it&apos;s the same as far as I&apos;m concerned<br/>&gt; too, unless you mean its vector representation.</p><p>Yes, for matrices you need to have consistent dimensions, but you can get<br/>away without them for wedge products.  At least the way I&apos;ve implemented<br/>them.</p><p>&gt;  But some zero elements aren&apos;t always present.  Either I can<br/>&gt; &gt; get rid of them, which might mean that different products have the<br/>&gt; same<br/>&gt; &gt; invariant, or enumerate the missing bases when I calculate the<br/>&gt; invariant.<br/>&gt;<br/>&gt; I don&apos;t know what is going on here.</p><p>Take the multiple-29 wedgie:</p><p>&gt;&gt;&gt; h29 = temper.PrimeET(29,temper.primes[:5])<br/>&gt;&gt;&gt; h58 = temper.PrimeET(58,temper.primes[:5])<br/>&gt;&gt;&gt; (h29^h58).invariant()<br/>(0, 29, 29, 29, 29, 46, 46, 46, 46, -14, -33, -40, -19, -26, -7)</p><p>Note it starts with a zero, which corresponds to the (0,1) element.  But,<br/>if you build it up from the right set of unison vectors,</p><p>&gt;&gt;&gt; wedgie = reduce(temper.wedgeProduct, (<br/>    (46, -29),<br/>    (-14, 0, -29, 29),<br/>    (33, 0, 29, 0, -29),<br/>    (7, 0, 0, 0, 29, -29)))</p><p>&gt;&gt;&gt; wedgie.simplify()<br/>&gt;&gt;&gt; wedgie.complement()<br/>{(0, 5): 29, (0, 4): 29, (1, 4): 46, (1, 5): 46, (1, 2): 46, (1, 3): 46,<br/>(2, 5): -40, (2, 4): -33, (2, 3): -14, (3, 4): -19, (3, 5): -26, (0, 2):<br/>29, (4, 5): -7, (0, 3): 29}</p><p>The (0,1) element isn&apos;t there.  That means it&apos;s also missing from the<br/>invariant</p><p>&gt;&gt;&gt; wedgie.invariant()<br/>(29, 29, 29, 29, 46, 46, 46, 46, -14, -33, -40, -19, -26, -7)</p><p>If I could enumerate over all pairs, I could fix that.  But that still<br/>leave the general problem of all combinations of N items taken from a set.<br/> I&apos;d prefer to get rid of zero elements altogether.</p><p>&gt; &gt; As to the unison vectors, in the 7-limit I seem to be getting 4<br/>&gt; when I<br/>&gt; &gt; only wanted 2, so how can I be sure they&apos;re linearly independent?<br/>&gt;<br/>&gt; They are never linearly independent. Why do they need to be?</p><p>I need a pair of unison vectors to define a 7-limit linear temperament.<br/>Right?  Some pairs have torsion as well:</p><p>&gt;&gt;&gt; for i in range(4):<br/>&#x9;for j in range(3):<br/>&#x9;&#x9;print temper.wedgeProduct(vectors[i],<br/>vectors[j]).torsion(),<br/>&#x9;&#x9;<br/>&#x9;&#x9;<br/>0 2 12 2 0 4 12 4 0 11 4 2</p><p>The aim is to get a pair without torsion.  And then generalize the process<br/>for any number of dimensions.</p><p>              Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@juno.com&#x3E;</h3><span>12/9/2001 3:26:16 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:</p><p>&gt; Is your matrix of vals my mapping by steps?  [(41, 31), (65, 49),<br/>(95,<br/>&gt; 72), (115, 87), (142, 107)] for Miracle.  If so, I&apos;m with you until<br/>you<br/>&gt; get to the Diophantine equations.  I think it&apos;s solving systems of<br/>linear<br/>&gt; Diophantine equations that I need to know how to do.</p><p>No, but if you have an easy way to get your two vals, and if they<br/>produce the correct wedgie, then they will work also.</p><p>&gt; &gt;&gt;&gt; wedgie = reduce(temper.wedgeProduct,<br/>&gt;     map(temper.WedgableRatio,<br/>&gt;     [(225,224),(385,384),(243,242)]))</p><p>I get 225/224^385/384^243^242 = h31^h41 =<br/>[6,-7,-2,15,-25,-20,3,15,59,49] in the ordering I&apos;m using now; this<br/>has the correct number of dimensions, ten. If you want to mess around<br/>with wedging equivalence classes (but what&apos;s the point?) then they<br/>should come out in six dimensions. The equivalence class wedgies are<br/>just subsets of the full wedgie, but they don&apos;t correspond any more,<br/>and don&apos;t get rid of torsion, and so don&apos;t seem very useful.</p><p>&gt; &gt;&gt;&gt; wedgie.octaveEquivalent().flatten()<br/>&gt; (0, -6, 7, 2, -15)<br/>&gt;<br/>&gt; but with the wedge of the temperaments<br/>&gt;<br/>&gt; &gt;&gt;&gt; (h31^h41).octaveEquivalent().flatten()<br/>&gt; (-25, -20, 3, 15, 59, 49)</p><p>Both of these are only part of the correct wedgie, so naturally they<br/>are not in correspondence.</p><p>&gt; Yes, for matrices you need to have consistent dimensions, but you<br/>can get<br/>&gt; away without them for wedge products.  At least the way I&apos;ve<br/>implemented<br/>&gt; them.</p><p>That may be your problem. You could do this by assuming infinite<br/>dimensions, and ignoring things after the dimension becomes larger<br/>than your inputs, where all coefficients become zero, but the normal<br/>way is to stick with a certain number of dimensions.</p><p>&gt;<br/>&gt; &gt;  But some zero elements aren&apos;t always present.  Either I can<br/>&gt; &gt; &gt; get rid of them, which might mean that different products have<br/>the<br/>&gt; &gt; same<br/>&gt; &gt; &gt; invariant, or enumerate the missing bases when I calculate the<br/>&gt; &gt; invariant.</p><p>You&apos;d certainly can&apos;t ignore a basis element with a coefficient of<br/>zero unless it is beyond the range of dimensions you are working in.</p><p>&gt; Take the multiple-29 wedgie:<br/>&gt;<br/>&gt; &gt;&gt;&gt; h29 = temper.PrimeET(29,temper.primes[:5])<br/>&gt; &gt;&gt;&gt; h58 = temper.PrimeET(58,temper.primes[:5])<br/>&gt; &gt;&gt;&gt; (h29^h58).invariant()<br/>&gt; (0, 29, 29, 29, 29, 46, 46, 46, 46, -14, -33, -40, -19, -26, -7)</p><p>There are fifteen of these, so presumably it is 13-limit, but you<br/>don&apos;t say. For a 13-limit wedgie of these two, I get your result, so<br/>that seems to be what it is.</p><p>&gt; &gt;&gt;&gt; wedgie.invariant()<br/>&gt; (29, 29, 29, 29, 46, 46, 46, 46, -14, -33, -40, -19, -26, -7)</p><p>This has dimension 14, which is wrong, and there is your missing zero.</p><p>&gt; If I could enumerate over all pairs, I could fix that.  But that<br/>still<br/>&gt; leave the general problem of all combinations of N items taken from<br/>a set.<br/>&gt;  I&apos;d prefer to get rid of zero elements altogether.</p><p>For programming purposes? I think the program should follow the math,<br/>and not vice-versa; otherwise you are asking for trouble.</p><p>&gt; Right?  Some pairs have torsion as well:</p><p>My algorithm gets rid of the torsion, that&apos;s really the point of it<br/>all.</p></div><h3>graham@microtonal.co.uk</h3><span>12/10/2001 5:06:00 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>In-Reply-To: &lt;<a href="mailto:9v0ruo+hdll@eGroups.com">9v0ruo+hdll@eGroups.com</a>&gt;<br/>Me:</p><p>&gt; &gt; Is your matrix of vals my mapping by steps?  [(41, 31), (65, 49),<br/>&gt; (95,<br/>&gt; &gt; 72), (115, 87), (142, 107)] for Miracle.  If so, I&apos;m with you until<br/>&gt; you<br/>&gt; &gt; get to the Diophantine equations.  I think it&apos;s solving systems of<br/>&gt; linear<br/>&gt; &gt; Diophantine equations that I need to know how to do.</p><p>Gene:<br/>&gt; No, but if you have an easy way to get your two vals, and if they<br/>&gt; produce the correct wedgie, then they will work also.</p><p>Yes, I can get the wedgie no problem.  It&apos;s going from that to the<br/>simplest set of unison vectors that&apos;s the problem.  It now looks like it&apos;s<br/>systems of Diophantine equations I need to look at, and wedge products are<br/>incidental.</p><p>&gt; &gt; &gt;&gt;&gt; wedgie = reduce(temper.wedgeProduct,<br/>&gt; &gt;     map(temper.WedgableRatio,<br/>&gt; &gt;     [(225,224),(385,384),(243,242)]))<br/>&gt;<br/>&gt; I get 225/224^385/384^243^242 = h31^h41 =<br/>&gt; [6,-7,-2,15,-25,-20,3,15,59,49] in the ordering I&apos;m using now; this<br/>&gt; has the correct number of dimensions, ten. If you want to mess around<br/>&gt; with wedging equivalence classes (but what&apos;s the point?) then they<br/>&gt; should come out in six dimensions. The equivalence class wedgies are<br/>&gt; just subsets of the full wedgie, but they don&apos;t correspond any more,<br/>&gt; and don&apos;t get rid of torsion, and so don&apos;t seem very useful.</p><p>What?  The octave-equivalent part of the unison-vector wedgie is the<br/>mapping by generators.  It uniquely defines the temperament, and is the<br/>most important thing we&apos;re trying to find.  The other equivalence class<br/>wedgies give us an ET mapping, if sometimes a silly one.  These are the<br/>two pieces of information we need to construct the temperament.  So they<br/>look like the most useful things the wedgie gives us.</p><p>&gt; &gt; &gt;&gt;&gt; wedgie.octaveEquivalent().flatten()<br/>&gt; &gt; (0, -6, 7, 2, -15)<br/>&gt; &gt;<br/>&gt; &gt; but with the wedge of the temperaments<br/>&gt; &gt;<br/>&gt; &gt; &gt;&gt;&gt; (h31^h41).octaveEquivalent().flatten()<br/>&gt; &gt; (-25, -20, 3, 15, 59, 49)<br/>&gt;<br/>&gt; Both of these are only part of the correct wedgie, so naturally they<br/>&gt; are not in correspondence.</p><p>Yes, but in the bit you cut off</p><p>Me:<br/>&gt; &gt; One good thing is that the generator mapping (ignoring the period<br/>&gt; mapping)<br/>&gt; &gt; which I&apos;m using as my invariant key, is simply the octave-<br/>&gt; equivalent part<br/>&gt; &gt; of the wedge product of the commatic unison vectors!</p><p>Gene:<br/>&gt; Or of the wedge product of two ets.</p><p>So it isn&apos;t the octave-equivalent part of the wedge product of the two ETs<br/>at all.  But you&apos;ve been ignoring this distinction.  Do you get it to work<br/>in the 5-limit?</p><p>&gt; &gt; Yes, for matrices you need to have consistent dimensions, but you<br/>&gt; can get<br/>&gt; &gt; away without them for wedge products.  At least the way I&apos;ve<br/>&gt; implemented<br/>&gt; &gt; them.<br/>&gt;<br/>&gt; That may be your problem. You could do this by assuming infinite<br/>&gt; dimensions, and ignoring things after the dimension becomes larger<br/>&gt; than your inputs, where all coefficients become zero, but the normal<br/>&gt; way is to stick with a certain number of dimensions.</p><p>Yes, but then 5:4 can&apos;t be both a 5-limit and 7-limit interval at the same<br/>time.  I&apos;m okay until we get to the flattening, which doesn&apos;t seem to be<br/>important.</p><p>&gt; &gt; &gt;  But some zero elements aren&apos;t always present.  Either I can<br/>&gt; &gt; &gt; &gt; get rid of them, which might mean that different products have<br/>&gt; the<br/>&gt; &gt; &gt; same<br/>&gt; &gt; &gt; &gt; invariant, or enumerate the missing bases when I calculate the<br/>&gt; &gt; &gt; invariant.<br/>&gt;<br/>&gt; You&apos;d certainly can&apos;t ignore a basis element with a coefficient of<br/>&gt; zero unless it is beyond the range of dimensions you are working in.</p><p>But before you said the definition of wedge products was</p><p>ei^ej = -ej^ei</p><p>nothing about keeping zero elements.  And it doesn&apos;t make any difference<br/>so far.  (May sometimes make the complements wrong.)</p><p>&gt; &gt; Take the multiple-29 wedgie:<br/>&gt; &gt;<br/>&gt; &gt; &gt;&gt;&gt; h29 = temper.PrimeET(29,temper.primes[:5])<br/>&gt; &gt; &gt;&gt;&gt; h58 = temper.PrimeET(58,temper.primes[:5])<br/>&gt; &gt; &gt;&gt;&gt; (h29^h58).invariant()<br/>&gt; &gt; (0, 29, 29, 29, 29, 46, 46, 46, 46, -14, -33, -40, -19, -26, -7)<br/>&gt;<br/>&gt; There are fifteen of these, so presumably it is 13-limit, but you<br/>&gt; don&apos;t say. For a 13-limit wedgie of these two, I get your result, so<br/>&gt; that seems to be what it is.</p><p>I do say.</p><p>&gt; &gt; &gt;&gt;&gt; h29 = temper.PrimeET(29,temper.primes[:5])<br/>                                               ^</p><p>5 octave-equivalent dimensions, so 13-limit.</p><p>&gt; &gt; &gt;&gt;&gt; wedgie.invariant()<br/>&gt; &gt; (29, 29, 29, 29, 46, 46, 46, 46, -14, -33, -40, -19, -26, -7)<br/>&gt;<br/>&gt; This has dimension 14, which is wrong, and there is your missing zero.</p><p>I know there&apos;s a missing zero.  I was showing you why it went missing.</p><p>&gt; &gt; If I could enumerate over all pairs, I could fix that.  But that<br/>&gt; still<br/>&gt; &gt; leave the general problem of all combinations of N items taken from<br/>&gt; a set.<br/>&gt; &gt;  I&apos;d prefer to get rid of zero elements altogether.<br/>&gt;<br/>&gt; For programming purposes? I think the program should follow the math,<br/>&gt; and not vice-versa; otherwise you are asking for trouble.</p><p>Either way, the program&apos;s following the math you originally gave.</p><p>&gt; &gt; Right?  Some pairs have torsion as well:<br/>&gt;<br/>&gt; My algorithm gets rid of the torsion, that&apos;s really the point of it<br/>&gt; all.</p><p>That&apos;s the thing with isolve?</p><p>                            Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@juno.com&#x3E;</h3><span>12/10/2001 12:40:43 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In tuning-math@y..., graham@m... wrote:<br/>&gt; In-Reply-To: &lt;9v0ruo+hdll@e...&gt;</p><p>&gt; So it isn&apos;t the octave-equivalent part of the wedge product of the<br/>two ETs<br/>&gt; at all.  But you&apos;ve been ignoring this distinction.  Do you get it<br/>to work<br/>&gt; in the 5-limit?</p><p>The 5-limit wedge product of two ets is the corresponding comma, and<br/>of two commas the corresponding et. We&apos;ve been doing this all along;<br/>you can consider it to be a cross-product, or a matrix determinant.<br/>The wedgie of a 5-limit linear temperament would reduce the cross-<br/>product until it was not a power (getting rid of any torsion) and<br/>standardize it to be greater than one.</p><p>&gt; &gt; You&apos;d certainly can&apos;t ignore a basis element with a coefficient<br/>of<br/>&gt; &gt; zero unless it is beyond the range of dimensions you are working<br/>in.<br/>&gt;<br/>&gt; But before you said the definition of wedge products was<br/>&gt;<br/>&gt; ei^ej = -ej^ei<br/>&gt;<br/>&gt; nothing about keeping zero elements.</p><p>That&apos;s the defintion, but it&apos;s an element in a vector space. You<br/>can&apos;t wish way a basis element ei^ej simply because it has a<br/>coefficient of zero, that isn&apos;t the way linear algebra works. A zero<br/>vector is not the same as the number zero.</p><p>&gt; &gt; &gt; If I could enumerate over all pairs, I could fix that.  But<br/>that<br/>&gt; &gt; still<br/>&gt; &gt; &gt; leave the general problem of all combinations of N items taken<br/>from<br/>&gt; &gt; a set.<br/>&gt; &gt; &gt;  I&apos;d prefer to get rid of zero elements altogether.</p><p>Why not simply order a list of size n choose m, and if one entry has<br/>the value zero, so be it? A function which goes from combinations of<br/>the first n integers, takrn m at a time, to unique integers in the<br/>range from 1 to n choose m might help.</p></div><h3>graham@microtonal.co.uk</h3><span>12/11/2001 4:55:00 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>In-Reply-To: &lt;<a href="mailto:9v36kb+mvhf@eGroups.com">9v36kb+mvhf@eGroups.com</a>&gt;<br/>gene wrote:</p><p>&gt; The 5-limit wedge product of two ets is the corresponding comma, and<br/>&gt; of two commas the corresponding et. We&apos;ve been doing this all along;<br/>&gt; you can consider it to be a cross-product, or a matrix determinant.<br/>&gt; The wedgie of a 5-limit linear temperament would reduce the cross-<br/>&gt; product until it was not a power (getting rid of any torsion) and<br/>&gt; standardize it to be greater than one.</p><p>The thing about the 5-limit is that the complements can have the same<br/>dimensions.  Here&apos;s where the problem arises:</p><p>&gt;&gt;&gt; comma = temper.WedgableRatio(81,80)<br/>&gt;&gt;&gt; comma.octaveEquivalent()<br/>{(2,): -1, (1,): 4}<br/>&gt;&gt;&gt; comma.octaveEquivalent().complement()<br/>{(2,): 4, (1,): 1}</p><p>That shows the octave equivalent part of the syntonic comma is not the<br/>meantone mapping.  You need to take the complement.  But in your system,<br/>which ignores this distinction, how to you know that the vector as it<br/>stands isn&apos;t right?  You don&apos;t get any clues from the dimensions, because<br/>they&apos;re the same.  Do you have an algorithm that would give (0 4 1) as the<br/>invariant of (-4 4 -1) wedged with (1 0 0)?  I don&apos;t, so I explicitly take<br/>the complement in the code.</p><p>Me:<br/>&gt; &gt; But before you said the definition of wedge products was<br/>&gt; &gt;<br/>&gt; &gt; ei^ej = -ej^ei<br/>&gt; &gt;<br/>&gt; &gt; nothing about keeping zero elements.</p><p>Gene:<br/>&gt; That&apos;s the defintion, but it&apos;s an element in a vector space. You<br/>&gt; can&apos;t wish way a basis element ei^ej simply because it has a<br/>&gt; coefficient of zero, that isn&apos;t the way linear algebra works. A zero<br/>&gt; vector is not the same as the number zero.</p><p>So how about ei^ei, can I wish that away?</p><p>Seriously, until we get to complements and listifying, it doesn&apos;t make any<br/>difference of those dimensions go.  At least, not the way I wrote the code<br/>it doesn&apos;t.  I can always listify the generator and ET mappings.  The only<br/>problem would be if a temperament-defining wedgie didn&apos;t depend on a<br/>particular prime interval, in which case I don&apos;t think it would define an<br/>n-limit temperament.</p><p>&gt; &gt; &gt; &gt; If I could enumerate over all pairs, I could fix that.  But<br/>&gt; that<br/>&gt; &gt; &gt; still<br/>&gt; &gt; &gt; &gt; leave the general problem of all combinations of N items taken<br/>&gt; from<br/>&gt; &gt; &gt; a set.<br/>&gt; &gt; &gt; &gt;  I&apos;d prefer to get rid of zero elements altogether.<br/>&gt;<br/>&gt; Why not simply order a list of size n choose m, and if one entry has<br/>&gt; the value zero, so be it? A function which goes from combinations of<br/>&gt; the first n integers, takrn m at a time, to unique integers in the<br/>&gt; range from 1 to n choose m might help.</p><p>Yes, it&apos;s getting the combinations of the first n integers that&apos;s the<br/>problem.  But I&apos;m sure I can solve it if I sit down and think about it.</p><p>To make you happy, I&apos;ll do that.</p><p>&gt;&gt;&gt; def combinations(number, input):<br/>...   if number==1:<br/>...     return [[x] for x in input]<br/>...   output = []<br/>...   for i in range(len(input)-number+1):<br/>...     for element in combinations(number-1, input[i+1:]):<br/>...       output.append([input[i]]+element)<br/>...   return output</p><p>(Hopefully the indentation will be okay on that, at least in View Source)</p><p>Inexistent entries are already the same as entries with the value zero in<br/>that w[1,2] will be zero if w doesn&apos;t have an element (1,2).  For example</p><p>&gt;&gt;&gt; comma[0,]<br/>-4<br/>&gt;&gt;&gt; comma[1,]<br/>4<br/>&gt;&gt;&gt; comma[2,]<br/>-1<br/>&gt;&gt;&gt; comma[3,]<br/>0</p><p>So the 5-limit comma I used above is already a 7-limit interval.  What I&apos;d<br/>like to change is for w[1,2]=0 to remove the element (1,2) instead of<br/>assigning zero to it.</p><p>                  Graham</p></div>