<a href="/tuning-math">back to list</a><h1>How to eliminate torsion</h1><h3>genewardsmith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>7/13/2010 12:50:10 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I asked on sci.math.research, and got an answer which works and is easy if you have a Smith Normal Form function available. The packages SAGE and gp mentioned below are freeware, and SAGE is in Python, which I wish I had known or I would have mentioned it before.</p><p>Victor S. Miller</p><p>Suppose that we&apos;re working in Z^n, and that we have an m-dimensional<br/>lattice.  Form the m x n integer matrix m whose rows are a basis of<br/>your lattice, and call it H.  The Smith normal form of H is an n x n<br/>diagonal integer matrix D, whose top m entries are positive (and the<br/>others are zero) and each such entry is an integer multiple of the one<br/>below it and to the right.  Furthermore there are matrices U in<br/>SL(m,Z) and V in SL(n,Z) such that</p><p>H = U D V</p><p>Your lattice will be gcd-reduced if and only if all the non-zero<br/>elements of D are 1.  To form the saturation of your lattice (that&apos;s<br/>what I think the standard terminology is) calculate</p><p>H&apos; = U D&apos; V</p><p>where D&apos; is the matrix obtained from D by replacing all of its<br/>non-zero entries by 1.</p><p>Most computer algebra packages have a function for Smith normal form<br/>(such as maple, SAGE, Magma, gp, etc.).</p><p>Victor</p><p>The only caveat is that you need to clean up the result with something like LLL or Hermite.</p></div><h3>genewardsmith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>7/13/2010 2:22:04 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, &quot;genewardsmith&quot; &lt;genewardsmith@...&gt; wrote:</p><p>&gt; H&apos; = U D&apos; V<br/>&gt;<br/>&gt; where D&apos; is the matrix obtained from D by replacing all of its<br/>&gt; non-zero entries by 1.</p><p>Using Victor&apos;s method, I wrote code to pass from a list of vals to a corresponding list of monzos or vice-versa by the P --&gt; I-P interchange method. It all works like a charm. By using Graham&apos;s Cangwu-style matrix definitions and the pseudoinverse defined projection map P, it looks like wedge products could be avoided if one wanted. P could be used internally as a way of uniquely characterizing a temperament, though it&apos;s not going to work for human consumption.</p></div><h3>Carl Lumma &#x3C;carl@lumma.org&#x3E;</h3><span>7/13/2010 4:34:49 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Great work Gene!  -Carl</p><p>At 12:50 PM 7/13/2010, you wrote:<br/>&gt;I asked on sci.math.research, and got an answer which works and is<br/>&gt;easy if you have a Smith Normal Form function available. The packages<br/>&gt;SAGE and gp mentioned below are freeware, and SAGE is in Python, which<br/>&gt;I wish I had known or I would have mentioned it before.<br/>&gt;&#x9;&#x9;<br/>&gt;Victor S. Miller<br/>&gt;<br/>&gt;Suppose that we&apos;re working in Z^n, and that we have an m-dimensional<br/>&gt;lattice.  Form the m x n integer matrix m whose rows are a basis of<br/>&gt;your lattice, and call it H.  The Smith normal form of H is an n x n<br/>&gt;diagonal integer matrix D, whose top m entries are positive (and the<br/>&gt;others are zero) and each such entry is an integer multiple of the one<br/>&gt;below it and to the right.  Furthermore there are matrices U in<br/>&gt;SL(m,Z) and V in SL(n,Z) such that<br/>&gt;<br/>&gt;H = U D V<br/>&gt;<br/>&gt;Your lattice will be gcd-reduced if and only if all the non-zero<br/>&gt;elements of D are 1.  To form the saturation of your lattice (that&apos;s<br/>&gt;what I think the standard terminology is) calculate<br/>&gt;<br/>&gt;H&apos; = U D&apos; V<br/>&gt;<br/>&gt;where D&apos; is the matrix obtained from D by replacing all of its<br/>&gt;non-zero entries by 1.<br/>&gt;<br/>&gt;Most computer algebra packages have a function for Smith normal form<br/>&gt;(such as maple, SAGE, Magma, gp, etc.).<br/>&gt;<br/>&gt;Victor<br/>&gt;<br/>&gt;The only caveat is that you need to clean up the result with something<br/>&gt;like LLL or Hermite.<br/>&gt;</p></div><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/14/2010 1:35:30 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 13 July 2010 20:50, genewardsmith &lt;<a href="mailto:genewardsmith@sbcglobal.net">genewardsmith@sbcglobal.net</a>&gt; wrote:<br/>&gt; I asked on sci.math.research, and got an answer which works and is easy if you have a Smith Normal Form function available. The packages SAGE and gp mentioned below are freeware, and SAGE is in Python, which I wish I had known or I would have mentioned it before.</p><p>Sage is a big bag of everything knitted together with Python, so<br/>there&apos;s no telling if the function we want is in Python and I can move<br/>it to my website.  Anyway, I&apos;ve got it installed and I&apos;m going through<br/>the tutorial now.</p><p>                     Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>7/14/2010 3:15:10 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, &quot;genewardsmith&quot; &lt;genewardsmith@...&gt; wrote:</p><p>Some email:</p><p>After thinking about it I realized that the<br/>answer is even slightly simpler.  If d is the dimension of your<br/>lattice, then a basis of the saturation is formed by first d rows of<br/>the matrix V (which is n x n).  You are right that some reduction<br/>(probably LLL) might be advisable.</p><p>Victor</p><p>&gt; Victor S. Miller<br/>&gt;<br/>&gt; Suppose that we&apos;re working in Z^n, and that we have an m-dimensional<br/>&gt; lattice.  Form the m x n integer matrix m whose rows are a basis of<br/>&gt; your lattice, and call it H.  The Smith normal form of H is an n x n<br/>&gt; diagonal integer matrix D, whose top m entries are positive (and the<br/>&gt; others are zero) and each such entry is an integer multiple of the one<br/>&gt; below it and to the right.  Furthermore there are matrices U in<br/>&gt; SL(m,Z) and V in SL(n,Z) such that<br/>&gt;<br/>&gt; H = U D V<br/>&gt;<br/>&gt; Your lattice will be gcd-reduced if and only if all the non-zero<br/>&gt; elements of D are 1.  To form the saturation of your lattice (that&apos;s<br/>&gt; what I think the standard terminology is) calculate<br/>&gt;<br/>&gt; H&apos; = U D&apos; V<br/>&gt;<br/>&gt; where D&apos; is the matrix obtained from D by replacing all of its<br/>&gt; non-zero entries by 1.<br/>&gt;<br/>&gt; Most computer algebra packages have a function for Smith normal form<br/>&gt; (such as maple, SAGE, Magma, gp, etc.).<br/>&gt;<br/>&gt; Victor<br/>&gt;<br/>&gt; The only caveat is that you need to clean up the result with something like LLL or Hermite.<br/>&gt;</p></div><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/14/2010 5:20:52 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 14 July 2010 23:15, genewardsmith &gt; Some email:<br/>&gt;<br/>&gt; After thinking about it I realized that the<br/>&gt; answer is even slightly simpler. &nbsp;If d is the dimension of your<br/>&gt; lattice, then a basis of the saturation is formed by first d rows of<br/>&gt; the matrix V (which is n x n). &nbsp;You are right that some reduction<br/>&gt; (probably LLL) might be advisable.<br/>&gt;<br/>&gt; Victor</p><p>Currently, with Sage, it&apos;s looking even simpler than that.  For a<br/>matrix M, with each row a val, some unison vectors come out from</p><p>kernel(transpose(M)).basis()</p><p>I haven&apos;t tested to see if they ever have spurious torsion, but they<br/>certainly shouldn&apos;t.  They&apos;re given in something that looks like my<br/>version of Hermite normal form, which isn&apos;t appropriate for unison<br/>vectors, but that can be fixed.</p><p>              Graham</p></div><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/17/2010 3:32:37 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 13 July 2010 22:22, genewardsmith &lt;<a href="mailto:genewardsmith@sbcglobal.net">genewardsmith@sbcglobal.net</a>&gt; wrote:</p><p>&gt; Using Victor&apos;s method, I wrote code to pass from<br/>&gt; a list of vals to a corresponding list of monzos<br/>&gt; or vice-versa by the P --&gt; I-P interchange method.<br/>&gt; It all works like a charm. By using Graham&apos;s<br/>&gt; Cangwu-style matrix definitions and the<br/>&gt; pseudoinverse defined projection map P, it<br/>&gt; looks like wedge products could be avoided if<br/>&gt; one wanted. P could be used internally as a way<br/>&gt; of uniquely characterizing a temperament, though<br/>&gt; it&apos;s not going to work for human consumption.</p><p>I don&apos;t see why we need P either.  The Hermite normal form of the<br/>mapping works fine as a unique key.</p><p>I&apos;m getting further with torsion now.  This paper, which is related to<br/>the Sage documentation, has the clue:</p><p><a href="http://www.wstein.org/papers/hnf/pernet-stein-fast_computation_of_hnf_of_random_integer_matrices.pdf">http://www.wstein.org/papers/hnf/pernet-stein-fast_computation_of_hnf_of_random_integer_matrices.pdf</a></p><p>&quot;If A is a basis matrix for M , and H is the Hermite form of the<br/>transpose of A with any 0 rows at the bottom deleted (so H is square),<br/>then H^&minus;1 A is a matrix whose rows are a basis for the saturation of<br/>M.&quot;</p><p>That actually doesn&apos;t work.  That&apos;s what you get for reading<br/>pre-prints.  But it does seem to work if A is also in Hermite normal<br/>form, which is easy enough to arrange as you need that algorithm<br/>anyway.  I can&apos;t say if this is simpler than Smith normal form or not<br/>because I still don&apos;t understand the latter.  But I seem to already<br/>have Hermite normal form (even if I don&apos;t trust it where there are<br/>zero rows) and inverses for rank 2 and 3 cases, even without a<br/>third-party library.</p><p>What also seems to follow is that the determinant of this square<br/>matrix H gives the torsion.  I&apos;m crunching through hours of CPU time<br/>to verify it against Sage&apos;s index_in_saturation.  And for rank&gt;2 it<br/>looks like a simpler way of checking for contorsion than wedge<br/>products.</p><p>For the rank 2 case, wedgies are pretty simple.  You can generate them<br/>easily and once you have a GCD of 1 (as you will most of the time) you<br/>can stop the calculation.</p><p>                Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>7/17/2010 7:25:50 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:</p><p>&gt; I don&apos;t see why we need P either.  The Hermite normal form of the<br/>&gt; mapping works fine as a unique key.</p><p>Agreed.</p><p>&gt; For the rank 2 case, wedgies are pretty simple.  You can generate them<br/>&gt; easily and once you have a GCD of 1 (as you will most of the time) you<br/>&gt; can stop the calculation.</p><p>It seems to me that they are also pretty simple for rank 3 or 4. It does get harder because of the rth order (rank = r) polynomial growth in terms of the dimension of the vals, but that&apos;s not too terrible.</p></div><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/18/2010 12:08:48 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 18 July 2010 03:25, genewardsmith &lt;<a href="mailto:genewardsmith@sbcglobal.net">genewardsmith@sbcglobal.net</a>&gt; wrote:<br/>&gt;<br/>&gt; --- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:<br/>&gt;<br/>&gt;&gt; For the rank 2 case, wedgies are pretty simple. &nbsp;You can generate them<br/>&gt;&gt; easily and once you have a GCD of 1 (as you will most of the time) you<br/>&gt;&gt; can stop the calculation.<br/>&gt;<br/>&gt; It seems to me that they are also pretty simple<br/>&gt; for rank 3 or 4. It does get harder because of the<br/>&lt; rth order (rank = r) polynomial growth in terms of<br/>&gt; the dimension of the vals, but that&apos;s not too terrible.</p><p>If they&apos;re are simple formulas, let&apos;s see them.  I don&apos;t have any beyond rank 2.</p><p>The size of the vals doesn&apos;t matter if you don&apos;t have to generate the<br/>whole thing, as I said above.</p><p>                  Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>7/18/2010 7:31:29 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:</p><p>&gt; &gt; It seems to me that they are also pretty simple<br/>&gt; &gt; for rank 3 or 4. It does get harder because of the<br/>&gt; &lt; rth order (rank = r) polynomial growth in terms of<br/>&gt; &gt; the dimension of the vals, but that&apos;s not too terrible.<br/>&gt;<br/>&gt; If they&apos;re are simple formulas, let&apos;s see them.  I don&apos;t have any beyond rank 2.</p><p>Herman&apos;s method makes it pretty easy. For rank 3, for instance, you have three vals, call them a, b, and c. Take three nested do loops,  i from 1 to n-2, j from i+1 to n-1, and k from j+1 to n. Inside the loops you first increment the indexing number telling you how far up the wedge product you&apos;ve gotten, and then sum over the six products you get times the parity, and that is the trival coefficent for that index. In other words, take a[i]b[j]c[k] + a[j]b[k]c[i] + a[k]b[i]c[j]<br/>- a[j]b[i]c[k] - a[k]b[j]c[i] - a[i]b[k]c[j]. With added effort you can covert this idea into a more general program good for any list of vals of the same size.</p></div><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/18/2010 12:25:00 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 18 July 2010 15:31, genewardsmith &lt;<a href="mailto:genewardsmith@sbcglobal.net">genewardsmith@sbcglobal.net</a>&gt; wrote:</p><p>&gt; Herman&apos;s method makes it pretty easy. For rank 3,<br/>&gt; for instance, you have three vals, call them<br/>&gt; a, b, and c. Take three nested do loops, &nbsp;i from<br/>&gt; 1 to n-2, j from i+1 to n-1, and k from j+1 to n.<br/>&gt; Inside the loops you first increment the indexing<br/>&gt; number telling you how far up the wedge product<br/>&gt; you&apos;ve gotten, and then sum over the six products<br/>&gt; you get times the parity, and that is the trival<br/>&gt; coefficent for that index. In other words, take<br/>&gt; a[i]b[j]c[k] + a[j]b[k]c[i] + a[k]b[i]c[j]<br/>&gt; - a[j]b[i]c[k] - a[k]b[j]c[i] - a[i]b[k]c[j]. With added<br/>&gt; effort you can covert this idea into a more general<br/>&gt; program good for any list of vals of the same size.</p><p>That&apos;s good, so rank 3&apos;s fairly easy, but not as simple as rank 2.  I<br/>still don&apos;t know how to make it more general, except by the old method<br/>of implementing all the wedge products with a multivector object.<br/>Whereas the Hermite normal form code is ugly, but the principle behind<br/>it&apos;s simple enough, and it&apos;s used for other things.  So there&apos;s not<br/>much point adding these wedgies as well.</p><p>                  Graham</p></div><h3>genewardsmith &#x3C;genewardsmith@sbcglobal.net&#x3E;</h3><span>7/19/2010 9:27:51 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@...&gt; wrote:</p><p>&gt; That&apos;s good, so rank 3&apos;s fairly easy, but not as simple as rank 2.  I<br/>&gt; still don&apos;t know how to make it more general, except by the old method<br/>&gt; of implementing all the wedge products with a multivector object.</p><p>You can write a routine incrementing monotone increasing lists of integers 1&lt;= i &lt;= n. Then you do things in the same way, taking a sum over n! things times the parity of the permutation.</p></div><h3>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>7/20/2010 2:23:19 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 19 July 2010 17:27, genewardsmith &lt;<a href="mailto:genewardsmith@sbcglobal.net">genewardsmith@sbcglobal.net</a>&gt; wrote:</p><p>&gt; You can write a routine incrementing monotone<br/>&gt; increasing lists of integers 1&lt;= i &lt;= n. Then you<br/>&gt; do things in the same way, taking a sum over<br/>&gt; n! things times the parity of the permutation.</p><p>Maybe a simple function could be written, but I don&apos;t know how to<br/>write it.  And I&apos;m not really interested in putting a lot of energy<br/>into this.  I know how to find contorsion without wedge products, and<br/>I know of a good library for integer matrices, so I have made<br/>progress.</p><p>The code for dealing with multivectors isn&apos;t that complicated, but<br/>looks more so than the Hermite normal form code.  The advantage is<br/>that you can use it to do a load of different calculations, including<br/>finding mappings from unison vectors and returning the error and<br/>complexity.  It compares favorably with writing my own matrix code.<br/>But I don&apos;t know how to calculate the TOP-RMS tuning or the Cangwu<br/>badness without matrices, and I do have a pure Python library that<br/>does these well enough, so wedgies are the more complicated option.</p><p>In terms of efficiency, this code will always lose.  It&apos;s written in<br/>Python and I haven&apos;t moved it to any other languages because it uses<br/>Python&apos;s syntactic support for dictionaries.  I could re-write it in<br/>C, but I&apos;d depend on a hash table library, and that would make the<br/>code more complicated.  It also wouldn&apos;t buy a huge efficiency gain<br/>because it would spend most of its time dealing with the hash tables.<br/>Python&apos;s dictionaries are already implemented using efficient hash<br/>tables coded in c.  The wedgies end up as quite large objects for<br/>higher prime limits and that slows things down.  If there are<br/>efficient libraries for exterior algebra I don&apos;t know of them.  So<br/>wedgies generally don&apos;t look like the pragmatic option.</p><p>Wedgies are still useful for finding the contorsion of a rank 2<br/>temperament (or something that would be a temperament if it didn&apos;t<br/>have contorsion).  All you need to do is generate the wedgie as a lazy<br/>list.  The function&apos;s so simple that you don&apos;t need to understand<br/>exterior algebra to justify it, and other approaches are likely to<br/>give the same result.  It&apos;s efficient because it&apos;s lazy and it should<br/>translate easily to more efficient languages.</p><p>The algorithm you gave for rank 3 is something I could implement.  If<br/>you&apos;re interested in rank 3 but no higher, it&apos;s an option.  But, given<br/>that I already have to find the Hermite normal form(HNF), using that<br/>looks easier.</p><p>The HNF code has to be there because it&apos;s used to give a unique key to<br/>each temperament class.  It really is better than wedgies for this.<br/>Wedgies are bigger.  Some elements are redundant, but I don&apos;t know<br/>which ones in the general case, and reconstructing them adds<br/>complexity.  Different things like temperaments but with contorsion<br/>have the same wedgie but different HNFs.  And the HNF is close to the<br/>generator/period mapping.  So HNFs are clearly earning their keep.</p><p>I surely don&apos;t have the most efficient HNF algorithm.  The difficult<br/>part is the Gaussian elimination to get an echelon matrix.  But it can<br/>also be used in a lot of different places.  The determinants used for<br/>scalar complexity and badness are easy to calculate for an echelon<br/>matrix.  Solving the least squares problem to get the optimal tuning<br/>isn&apos;t that difficult once you have an echelon matrix.  The simplest<br/>algorithm for finding the kernel uses echelon form.  The HNF can be<br/>used not only for detecting torsion but reliably removing it.</p><p>It happens that I need different functions for Gaussian elimination of<br/>real and integer matrices.  Maybe I could fix that but it doesn&apos;t<br/>matter because I&apos;m moving to a third party library for the weighted<br/>calculations.  (I still don&apos;t know how to get PARI working on my<br/>website, and it&apos;s probably not worth the hassle given I&apos;ll have to<br/>work it all out again if I move hosts.  Note, Carl, this is also why I<br/>keep using cgi-bin.)  The same multivector code does work for either<br/>integers or floating point, as it happens.</p><p>For the rank 2 case, if you have a library to deal with floating point<br/>matrices, the easiest thing to uniquely identify a temperament class<br/>by is the octave-equivalent generator, which is the same as the<br/>octave-equivalent part of the wedgie, and is easiest to calculate.<br/>There are problems with this but it basically works.  So for rank 2<br/>temperaments (which are an important special case) you don&apos;t need HNF<br/>and the easiest way to detect torsion is to use wedgies.</p><p>The simplest way of dealing with contorsion is to ignore it, which is<br/>what my website currently does.  Next is to detect but not remove it,<br/>where wedgies are useful.  To detect and remove contorsion, beyond<br/>rank 2, I still need HNF or a third party library.</p><p>So that&apos;s it, a long answer to a simple question.  If you want to show<br/>how simple general wedgie code could be, go ahead an implement it.<br/>It&apos;s not something I have a need for.</p><p>                 Graham</p></div>