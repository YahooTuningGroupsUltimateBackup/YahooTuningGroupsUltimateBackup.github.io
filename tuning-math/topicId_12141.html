<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math Worst equal temperaments</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>Worst equal temperaments</h1><h3><a id=12141 href="#12141">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>5/13/2005 1:24:13 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Following a discussion on MakeMicroMusic, I&apos;ve been looking for equal<br/>temperaments with poor approximations to just intonation.  There are<br/>two details that might not be obvious:</p><p>1)  You have to ignore consistency.  We aren&apos;t interested in chords,<br/>but that no intervals sound familiar.  So you always take the nearest,<br/>even when looking for the RMS.</p><p>2)  The maximin search has very small peaks.  So, my original method<br/>of using a spreadsheet is inadequate because it&apos;s likely to miss<br/>peaks, or get unmanageably large.</p><p>Here are the worst 20 results for some 5-limit ratios, along with 9:8<br/>and octave equivalents.  The first column is the number of steps to a<br/>2:1 octave, the second the step size in cents, and the last column the<br/>smallest weighted error.</p><p> 8.39 143.0  3.3<br/>10.03 119.7  2.9<br/> 8.02 149.6  2.8<br/>10.70 112.2  2.7<br/>13.96  85.9  2.6<br/> 8.25 145.4  2.6<br/>12.97  92.5  2.5<br/> 8.64 138.8  2.5<br/> 9.97 120.3  2.5<br/> 9.02 133.0  2.4<br/>13.03  92.1  2.4<br/> 8.69 138.1  2.4<br/>14.03  85.5  2.2<br/>10.52 114.0  2.2<br/>15.97  75.2  2.0<br/>10.97 109.4  2.0<br/>10.48 114.5  1.9<br/>16.47  72.9  1.9<br/> 8.98 133.6  1.9<br/>10.75 111.7  1.9</p><p>Here are the results with 7:4 and octave equivalents added</p><p> 8.39 143.0  3.3<br/> 8.02 149.6  2.8<br/>13.96  85.9  2.6<br/> 8.25 145.4  2.6<br/>12.97  92.5  2.5<br/> 9.02 133.0  2.4<br/>13.03  92.1  2.4<br/>14.03  85.5  2.2<br/>10.04 119.6  2.1<br/>10.97 109.4  2.0<br/>16.47  72.9  1.9<br/> 8.98 133.6  1.9<br/>10.75 111.7  1.9<br/>16.53  72.6  1.9<br/>10.71 112.1  1.8<br/>11.02 108.9  1.8<br/>10.17 117.9  1.8<br/>10.47 114.6  1.8<br/>10.08 119.1  1.8<br/> 9.12 131.6  1.7</p><p>Finally, here&apos;s the Python code I used, with comments so that you<br/>should be able to reconstruct the indentation if it gets corrupted.<br/>Usually &quot;View Source&quot; gets round this.</p><p>import math</p><p>def prodpeaks(ratios, min, max, step=0.001):<br/>    weighted = prodweight(ratios)<br/>    def errorfn(x):<br/>        return besterror(x, weighted)<br/>    return peaks(errorfn, min, max, step)</p><p>def peaks(fn, min, max, inc):<br/>    prev = fn(min-inc)<br/>    curr = fn(min)<br/>    result = []<br/>    x = min<br/>    while x &lt;= max:<br/>        next = fn(x+inc)<br/>        if curr&gt;prev and curr&gt;next:<br/>            result.append((fn(x), x))<br/>        #endif<br/>        x += inc<br/>        prev = curr<br/>        curr = next<br/>    #endloop<br/>    result.sort()<br/>    result.reverse()<br/>    return result</p><p>def besterror(edo, ratios):<br/>    return min([<br/>        errorweight(ratio, weight, edo)<br/>        for (ratio, weight) in ratios])</p><p>def errorweight(ratio, weight, edo):<br/>    nearest = math.floor(edo*ratio+0.5)<br/>    error = math.fabs(nearest/edo - ratio)<br/>    return error/weight</p><p>def prodweight(ratiolist):<br/>    result = []<br/>    log2 = math.log(2)<br/>    for n, d in ratiolist:<br/>        nlog = math.log(n)/log2<br/>        dlog = math.log(d)/log2<br/>        result.append((nlog-dlog, nlog+dlog))<br/>    #endloop<br/>    return result</p><p>if __name__==&apos;__main__&apos;:<br/>    ratios = [(9,8), (3, 2), (4,3), (5,4), (8,5), (6,5), (5,3),<br/>      (2,1), (9,4), (5,2), (8,3), (3,1), (4,1),<br/>      (9,2), (5,1), (6,1), (8,1), (9,1)]<br/>    #7-limit bonus<br/>    ratios += [(7,4), (7,2), (7,1)]<br/>    for error, edo in prodpeaks(ratios, 8, 19)[:20]:<br/>        print &quot;%5.2f %5.1f  %3.1f&quot; % (edo, 12e2/edo, error*1000)</p></div><h3><a id=12142 href="#12142">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>5/13/2005 2:51:07 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;Following a discussion on MakeMicroMusic, I&apos;ve been looking<br/>&gt;for equal temperaments with poor approximations to just<br/>&gt;intonation.</p><p>If we want to make it so things stay bad despite modulation,<br/>equal-step does seem to be the way to go (also it presumably<br/>makes guitar fretting easier, and the original thread<br/>pertained to guitar).</p><p>Next I thought one ought to weight the errors according to<br/>which consonances they miss -- bad octaves should be more<br/>important than bad fifths, for example.  I&apos;m not sure how<br/>you selected your targets, Graham, but using a filter that<br/>assumes octave equivalence (like odd- or prime-limit) seems<br/>like a mistake.</p><p>The obvious way to get the weightings and the right targets<br/>at the same time seems to be to use harmonic entropy.  Choose<br/>s and an region of the log-frequency line instead of an<br/>odd- or prime-limit.</p><p>Represent equal-step scales as comb filters taking one<br/>parameter, A, the step size.  Then, for all A 10 &lt; A &lt; 200,<br/>plot the intergral of each scale over the harmonic entropy<br/>curve.  Start with A to the nearest half-cent, maybe, and<br/>zoom in on the peaks if necessary.</p><p>-Carl</p></div><h3><a id=12145 href="#12145">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>5/15/2005 2:40:02 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; If we want to make it so things stay bad despite modulation,<br/>&gt; equal-step does seem to be the way to go (also it presumably<br/>&gt; makes guitar fretting easier, and the original thread<br/>&gt; pertained to guitar).</p><p>Equal temperaments are the easiest scales to do the calculations for.<br/>They also have the smallest number of distinct intervals for a given<br/>number of notes, which makes it less likely that they hit a &quot;good&quot;<br/>interval.</p><p>&gt; Next I thought one ought to weight the errors according to<br/>&gt; which consonances they miss -- bad octaves should be more<br/>&gt; important than bad fifths, for example.  I&apos;m not sure how<br/>&gt; you selected your targets, Graham, but using a filter that<br/>&gt; assumes octave equivalence (like odd- or prime-limit) seems<br/>&gt; like a mistake.</p><p>Yes, I weight them, which I suppose makes sense.  The idea is to avoid<br/>familiar consonances, and so if the listener is familiar with the<br/>5-limit, let&apos;s avoid the 5-limit.  You can easily plug in different<br/>intervals if you prefer.</p><p>&gt; The obvious way to get the weightings and the right targets<br/>&gt; at the same time seems to be to use harmonic entropy.  Choose<br/>&gt; s and an region of the log-frequency line instead of an<br/>&gt; odd- or prime-limit.</p><p>That sounds like a lot of trouble for an obscure problem with little<br/>psychoacoustic backing.</p><p>                    Graham</p></div><h3><a id=12146 href="#12146">ðŸ”—</a>Carl Lumma &#x3C;ekin@lumma.org&#x3E;</h3><span>5/15/2005 5:39:27 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt; If we want to make it so things stay bad despite modulation,<br/>&gt;&gt; equal-step does seem to be the way to go (also it presumably<br/>&gt;&gt; makes guitar fretting easier, and the original thread<br/>&gt;&gt; pertained to guitar).<br/>//<br/>They also have the smallest number of distinct intervals for a given<br/>&gt;number of notes, which makes it less likely that they hit a &quot;good&quot;<br/>&gt;interval.</p><p>Yes, that&apos;s what I mean by &quot;stay bad despite modulation&quot;.</p><p>&gt;&gt; Next I thought one ought to weight the errors according to<br/>&gt;&gt; which consonances they miss -- bad octaves should be more<br/>&gt;&gt; important than bad fifths, for example.  I&apos;m not sure how<br/>&gt;&gt; you selected your targets, Graham, but using a filter that<br/>&gt;&gt; assumes octave equivalence (like odd- or prime-limit) seems<br/>&gt;&gt; like a mistake.<br/>&gt;<br/>&gt;Yes, I weight them, which I suppose makes sense.  The idea is to avoid<br/>&gt;familiar consonances, and so if the listener is familiar with the<br/>&gt;5-limit, let&apos;s avoid the 5-limit.  You can easily plug in different<br/>&gt;intervals if you prefer.<br/>&gt;<br/>&gt;&gt; The obvious way to get the weightings and the right targets<br/>&gt;&gt; at the same time seems to be to use harmonic entropy.  Choose<br/>&gt;&gt; s and an region of the log-frequency line instead of an<br/>&gt;&gt; odd- or prime-limit.<br/>&gt;<br/>&gt;That sounds like a lot of trouble for an obscure problem with little<br/>&gt;psychoacoustic backing.</p><p>No trouble at all, if you already have the stuff to calculate<br/>harmonic entropy.  I think it&apos;s an interesting problem, and some<br/>interesting scales could result.  Certainly plenty of effort has<br/>been spent writing atonal/dissonant music.</p><p>-Carl</p></div><h3><a id=12148 href="#12148">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@svpal.org&#x3E;</h3><span>5/15/2005 12:47:21 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning-math@yahoogroups.com">tuning-math@yahoogroups.com</a>, Graham Breed &lt;gbreed@g...&gt; wrote:</p><p>&gt; That sounds like a lot of trouble for an obscure problem with little<br/>&gt; psychoacoustic backing.</p><p>I was thinking of suggesting zeros of the Riemann zeta function<br/>exhibiting Lehmer&apos;s phenomenon, meaning finding a pair (they come in<br/>pairs) where the derivatives were also small. How&apos;s that for going to<br/>a lot of trouble for an obscure problem with little psychoacoustic<br/>backing?</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            