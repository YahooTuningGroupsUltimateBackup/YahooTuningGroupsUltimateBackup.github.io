<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning-math Latest code and profiling</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning-math">back to list</a><h1>Latest code and profiling</h1><h3><a id=14055 href="#14055">ðŸ”—</a>Graham Breed &#x3C;gbreed@gmail.com&#x3E;</h3><span>1/18/2006 1:22:36 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>If I remember I&apos;ll copy my main source code in Python, Pyrex, C and Ocaml to <a href="http://x31eq.com/temper/regular.zip">http://x31eq.com/temper/regular.zip</a></p><p>The Pyrex is new, and the fastest.</p><p>To give you an idea of how fast each part of the search is, here&apos;s some profile output:</p><p>temper python regular_profile.py big | tail -n 23 | head -n 21<br/>   ncalls  tottime  cumtime filename:lineno(function)<br/>...<br/>       27   82.340  396.800  <a href="http://regular.py:309">regular.py:309</a>(getLinearTemperaments)<br/>  1210950  119.250  160.490  <a href="http://regular.py:362">regular.py:362</a>(__init__)<br/>   611514   22.480   68.970  <a href="http://regular.py:417">regular.py:417</a>(optimalRMSError)<br/>  1210950   51.590   51.590  <a href="http://regular.py:404">regular.py:404</a>(complexity)<br/>   611514   46.490   46.490  <a href="http://regular.py:428">regular.py:428</a>(magicSums)<br/>  1210950   41.240   41.240  <a href="http://regular.py:589">regular.py:589</a>(extendedEuclid)<br/>       27    0.860   34.030  <a href="http://regular.py:106">regular.py:106</a>(getEqualTemperaments)<br/>231270/13947  13.160  32.150 <a href="http://regular.py:189">regular.py:189</a>(limitedSupersets)<br/>   390398   12.570   25.350  <a href="http://regular.py:549">regular.py:549</a>(add)<br/>   217323    5.240   14.650  <a href="http://regular.py:179">regular.py:179</a>(addEntry)<br/>   393080   12.860   12.860  <a href="http://regular.py:392">regular.py:392</a>(invariant)<br/>   231270    7.170    9.940  <a href="http://regular.py:168">regular.py:168</a>(__init__)<br/>   390398    4.870    4.870  <a href="http://regular.py:303">regular.py:303</a>(defaultBadness)<br/>   231270    3.330    3.330  <a href="http://regular.py:230">regular.py:230</a>(value)<br/>       27    2.900    2.900  <a href="http://regular.py:556">regular.py:556</a>(retrieve)<br/>   231270    2.770    2.770  <a href="http://regular.py:224">regular.py:224</a>(setData)</p><p>This is for a searches over 300 equal temperaments.  The time taken to find the equal temperaments is only 34 seconds out of the total 396 seconds run time.  With simpler calculations it&apos;s more significant.  It would be a lot higher if I used the old algorithm of rounding every prime up and down, and filtering the results by their error.  That produces 2**(n-1) mappings for n primes and gets out of hand as n gets large.</p><p>The largest part of the rest of the time is spent initializing the rank 2 temperaments.  That includes setting the period and generator.  41 out of 160 seconds are in extendedEuclid: used to get the generators from the numbers of notes to the octave.  It doesn&apos;t take any longer for higher primes, except that the numbers tend to be larger.</p><p>The next largest amount of time is spent calculating the error.  It doesn&apos;t take much longer than the complexity, but the complexity threshold&apos;s first and so the error is calculated less often. Interestingly, the pure Python error optimization is faster than one using Numeric Python, although the latter used native code routines. The &quot;magicSums&quot; function is part of the error calculation.</p><p>The &quot;add&quot; method is for adding a temperament to the set for eventally sorting by badness.  It includes the overhead for calculating the hash code, looking it up, and so on.  About half the time is spent calculating the invariant -- here the octave-equivalent mapping without the 0 at the start and multiplied by the number of periods to an octave.</p><p>Originally, it spent a lot of time checking that the temperament didn&apos;t have contorsion.  So I moved that to the end and got it to only check temperaments that it would otherwise have returned.  Because it only returns a small fraction of the temperaments it looks at, you don&apos;t even see the contorsion in this list.  With smaller searches it is still there.</p><p>That covers all the parts that take a significant amount of time.  Here, for comparison, is some code that uses wedgies instead of the period and generator.</p><p>   ncalls  tottime  cumtime  filename:lineno(function)<br/>...<br/>       27   73.750  468.040  regular_wedgie.py:309(getLinearTemperaments)<br/>  1210950   92.120  247.920  regular_wedgie.py:362(__init__)<br/>  1210950  155.800  155.800  regular_wedgie.py:673(wedgie)<br/>   611514   23.020   81.910  regular_wedgie.py:390(optimalRMSError)<br/>   611514   58.890   58.890  regular_wedgie.py:400(magicSums)<br/>  1210950   47.200   47.200  regular_wedgie.py:383(complexity)<br/>       27    0.920   33.710  regular_wedgie.py:105(getEqualTemperaments)<br/>231270/13947 12.760  31.770  regular_wedgie.py:189(limitedSupersets)<br/>   217323    5.200   14.650  regular_wedgie.py:179(addEntry)<br/>   231270    6.960    9.920  regular_wedgie.py:167(__init__)<br/>   390398    9.150    9.150  regular_wedgie.py:505(add)<br/>   390398    5.020    5.020  regular_wedgie.py:303(defaultBadness)<br/>   231270    3.380    3.380  regular_wedgie.py:230(value)<br/>   231270    2.960    2.960  regular_wedgie.py:224(setData)<br/>       27    2.840    2.840  regular_wedgie.py:512(retrieve)<br/>    70297    0.980    0.980  regular_wedgie.py:702(nint)</p><p>This is old code from before I used general wedgies and Numeric Python to get higher ranks to work.  It takes about a minute of profiler-seconds longer than the other version.  More than two minutes are spent calculating wedgies.  Finding one wedgie is much slower than the weighted, prime RMS error.  Eventually I changed the code so that it only calculates the wedgie after it&apos;s decided the error is okay.  That&apos;s especially important with the new code where the wedgie calculations takek much longer.</p><p>                  Graham</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            