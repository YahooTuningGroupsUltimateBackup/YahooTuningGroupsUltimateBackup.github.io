<a href="/tuning">back to list</a><h1>(no subject)</h1><h3><a id=2590 href="#2590">ðŸ”—</a>Mckyyy@xxx.xxx</h3><span>4/26/1999 7:34:53 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>The tuning list has discussed various types of temperaments, and complex JI.<br/>Euclid&apos;s algorithm and the multiplication inverse might be helpful in<br/>understanding these systems of tuning.</p><p>When two tones are sounded simultaneously, they heterodyne.  It is possible<br/>to present what happens in a heterodyne chart.  Below is a heterodyne chart<br/>for 11/17.  The heterodyne chart will be as long as the LCM of the two<br/>numbers.</p><p>0 11<br/>5 16<br/>10<br/>4 15<br/>9<br/>3 14<br/>8<br/>2 13<br/>7<br/>1 12<br/>6</p><p>The chart describes the phase relationship between the period 11 signal and<br/>the period 17 signal.  Each line describes the start of new period 11 cycles<br/>within a period 17 cycle.</p><p>BTW, I &quot;invented&quot; the heterodyne chart.  Usually this subject is described as<br/>the theory of rings.  The principles are the same, of course, but I find the<br/>heterodyne chart a little easier to understand.  In this context, we will<br/>assume that the two numbers used to make the chart are mutually prime.</p><p>Notice the following characteristics of the chart.  Each of the numbers from<br/>0 to 16 occurs in the chart only once.  This means that the numbers one and<br/>16 can only appear in the chart once.  In this chart the one occurs at<br/>location 14, and the 16 occurs at location 3.  The location of the one is<br/>called the positive multiplication inverse.  14*11=1 mod 17.  The location of<br/>the 16 is called the least negative multiplication inverse.  In the context<br/>of a 0-16 numbering, 16 can be viewed as -1.  The positive and negative<br/>multiplication inverses are complimentary with respect to the larger of the<br/>two numbers used to make the chart.  That is, 14+3=17.</p><p>The inverses can be used to find a best case approximation to the fraction<br/>from which the chart was made.  11/17*14=9.058824 which tells us that 9/14 is<br/>a pretty good approximation for 11/17.<br/>The same can be done for the negative inverse telling us the 2/3 is also a<br/>decent approximation for 11/17, but not quite as good as 9/14,</p><p>We can analyze musical intervals by iterating this procedure.  Here are the<br/>results for 12et done by starting with an approximation based on 5 decimal<br/>digits.  In each row, the first two numbers separated by a slash are the<br/>interval.  The third number is the LCM of the interval, and the third number<br/>is a decimal representation of the interval.  Subsequent lines are<br/>successively less accurate approximations using smaller numbers.</p><p>B<br/>18877/10000 188770000 1.887700<br/>353/187 66011 1.887701<br/>168/89 14952 1.887640<br/>17/9 153 1.888889</p><p>A#<br/>17818/10000 178180000 1.781800<br/>3544/1989 7049016 1.781800<br/>1723/967 1666141 1.781799<br/>98/55 5390 1.781818<br/>41/23 943 1.782609<br/>16/9 144 1.777778<br/>7/4 28 1.750000</p><p>A<br/>16818/10000 168180000 1.681800<br/>4186/2489 10418954 1.681800<br/>37/22 814 1.681818<br/>5/3 15 1.666667</p><p>G#<br/>15874/10000 158740000 1.587400<br/>1789/1127 2016203 1.587400<br/>781/492 384252 1.587398<br/>227/143 32461 1.587413<br/>100/63 6300 1.587302<br/>27/17 459 1.588235<br/>8/5 40 1.600000</p><p>G<br/>14983/10000 149830000 1.498300<br/>3966/2647 10498002 1.498300<br/>881/588 518028 1.498299<br/>439/293 128627 1.498294<br/>3/2 6 1.500000</p><p>F#<br/>14142/10000 141420000 1.414200<br/>239/169 40391 1.414201<br/>99/70 6930 1.414286<br/>41/29 1189 1.413793<br/>17/12 204 1.416667<br/>7/5 35 1.400000</p><p>F<br/>13348/10000 133480000 1.334800<br/>303/227 68781 1.334802<br/>4/3 12 1.333333</p><p>E<br/>12599/10000 125990000 1.259900<br/>3277/2601 8523477 1.259900<br/>509/404 205636 1.259901<br/>223/177 39471 1.259887<br/>63/50 3150 1.260000<br/>29/23 667 1.260870<br/>5/4 20 1.250000</p><p>D#<br/>11892/10000 118920000 1.189200<br/>44/37 1628 1.189189<br/>19/16 304 1.187500<br/>6/5 30 1.200000</p><p>D<br/>11225/10000 112250000 1.122500<br/>55/49 2695 1.122449<br/>9/8 72 1.125000</p><p>C#<br/>10595/10000 105950000 1.059500<br/>552/521 287592 1.059501<br/>89/84 7476 1.059524<br/>18/17 306 1.058824</p><p>There are at least two possible versions of this series, the long version,<br/>and the short version.  I have shown the short version here.  I believe that<br/>is most appropriate, but I am not sure.  I can change from the long version<br/>to the short version by changing a &gt; to a &lt; in the line of code, where the<br/>comment says, &quot;make sure we have the smallest inverse&quot; in the source given<br/>below.  Here is the long version for F#.</p><p>14142/10000 141420000 1.414200<br/>13903/9831 136680393 1.414200<br/>7071/5000 35355000 1.414200<br/>6832/4831 33005392 1.414200<br/>6593/4662 30736566 1.414200<br/>6354/4493 28548522 1.414200<br/>6115/4324 26441260 1.414200<br/>5876/4155 24414780 1.414200<br/>5637/3986 22469082 1.414200<br/>5398/3817 20604166 1.414200<br/>5159/3648 18820032 1.414200<br/>4920/3479 17116680 1.414199<br/>4681/3310 15494110 1.414199<br/>4442/3141 13952322 1.414199<br/>4203/2972 12491316 1.414199<br/>3964/2803 11111092 1.414199<br/>3725/2634 9811650 1.414199<br/>3486/2465 8592990 1.414199<br/>3247/2296 7455112 1.414199<br/>3008/2127 6398016 1.414198<br/>2769/1958 5421702 1.414198<br/>2530/1789 4526170 1.414198<br/>2291/1620 3711420 1.414198<br/>2052/1451 2977452 1.414197<br/>1813/1282 2324266 1.414197<br/>1574/1113 1751862 1.414196<br/>1335/944 1260240 1.414195<br/>1096/775 849400 1.414194<br/>857/606 519342 1.414191<br/>618/437 270066 1.414188<br/>379/268 101572 1.414179<br/>239/169 40391 1.414201<br/>140/99 13860 1.414141<br/>99/70 6930 1.414286<br/>58/41 2378 1.414634<br/>41/29 1189 1.413793<br/>24/17 408 1.411765<br/>17/12 204 1.416667<br/>10/7 70 1.428571<br/>7/5 35 1.400000</p><p>I am uncertain which is the best representation for tuning purposes.  There<br/>appears to be some interaction with the other arbitrary decision I had to<br/>make when writing this code, the error limit.  I chose to abandon the loop<br/>when the error of approximation becomes too great.  I chose an arbitrary<br/>limit of 2.5%, the &quot;unit of perception&quot; from psychology, which is the amount<br/>of difference in most physical quantities it takes for a human two be able to<br/>tell a difference.  Others might choose a different threshold, or a different<br/>way of measuring the error.  Anyway, when I used the long series for the 12et<br/>G, the loop dropped out before it got to 3/2, meaning the long series<br/>meanders a bit from the straight and narrow, in some sense.</p><p>Certainly the larger LCM components of this series are not relevant from a<br/>harmonic point of view as any interval with an LMC of greater than 1,000,000<br/>will take longer than 2000 seconds to repeat at 440hz.</p><p>Can we hear these hidden simpler intervals within the more complex intervals.<br/> Certainly we can in some cases, as the example 30001/20001 shows.  Do we<br/>hear the long series, or the short series?  How much does the error<br/>difference between the actual frequency being played and the approximate<br/>interval matter?  Is this whole line of inquiry useful?</p><p>Below is the source for the program I used to get the numbers listed above.<br/>It is a console app written in Microsoft C++ 6.0.  To keep the program short<br/>I left out bells and whistles.  For example, it will probably crash if the<br/>input numbers are not mutually prime.</p><p>Marion</p><p>#include &lt;stdio.h&gt;<br/>#include &lt;math.h&gt;<br/>#include &lt;stdlib.h&gt;</p><p>#define&#x9;MAXERROR&#x9;0.025<br/>#define&#x9;MAXLCM&#x9;&#x9;1000</p><p>//find multiplication inverse<br/>//function expects mutually prime positive integer arguments<br/>double inv(double arg1,double arg2){</p><p>&#x9;double&#x9;&#x9;sav[40];<br/>&#x9;int&#x9;&#x9;&#x9;pSav=0;<br/>&#x9;double&#x9;&#x9;tmp,acc,prev;</p><p>&#x9;//euclid&apos;s algorithm, saving products<br/>&#x9;while(arg2){<br/>&#x9;&#x9;<br/>&#x9;&#x9;tmp=fmod(arg1,arg2);<br/>&#x9;&#x9;arg1-=tmp;<br/>&#x9;&#x9;sav[pSav++]=arg1/arg2;<br/>&#x9;&#x9;arg1=arg2;<br/>&#x9;&#x9;arg2=tmp;<br/>&#x9;}<br/>&#x9;//use products to compute multiplication inverse<br/>&#x9;acc=1;prev=0;<br/>&#x9;for(pSav-=2;pSav&gt;=0;pSav--){</p><p>&#x9;&#x9;tmp=acc;<br/>&#x9;&#x9;acc=sav[pSav]*acc+prev;<br/>&#x9;&#x9;prev=tmp;<br/>&#x9;}<br/>&#x9;return acc;<br/>}</p><p>double fint(double dat){</p><p>&#x9;_asm{</p><p>&#x9;&#x9;&#x9;fld&#x9;&#x9;dat<br/>&#x9;&#x9;&#x9;frndint<br/>&#x9;}<br/>#pragma warning(disable:4035;once:)<br/>}</p><p>int main(int argc,char *argv[],char *envp[]){</p><p>&#x9;double arg1,arg2,rat;<br/>&#x9;double tmp0;</p><p>&#x9;if(argc&gt;2){</p><p>&#x9;&#x9;arg1=atoi(argv[1]);<br/>&#x9;&#x9;arg2=atoi(argv[2]);<br/>&#x9;&#x9;if(arg1&lt;arg2){<br/>&#x9;<br/>&#x9;&#x9;&#x9;tmp0=arg1;<br/>&#x9;&#x9;&#x9;arg1=arg2;<br/>&#x9;&#x9;&#x9;arg2=tmp0;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;rat=arg2/arg1;<br/>&#x9;&#x9;while(arg2&gt;1&amp;&amp;fabs(1-(rat/arg2*arg1))&lt;MAXERROR){</p><p>&#x9;&#x9;&#x9;printf(&quot;%.0f/%.0f %.0f<br/>%f\n&quot;,arg1,arg2,arg1*arg2,arg1/arg2);<br/>&#x9;&#x9;&#x9;tmp0=inv(arg1,arg2);<br/>&#x9;&#x9;&#x9;//make sure we have the smallest inverse<br/>&#x9;&#x9;&#x9;if(tmp0&gt;arg1/2)<br/>&#x9;&#x9;&#x9;&#x9;tmp0=arg1-tmp0;<br/>&#x9;&#x9;&#x9;arg2=fint(tmp0*arg2/arg1);<br/>&#x9;&#x9;&#x9;arg1=tmp0;<br/>&#x9;&#x9;}<br/>&#x9;&#x9;printf(&quot;\n&quot;);<br/>&#x9;}<br/>&#x9;else<br/>&#x9;&#x9;printf(&quot;Usage: aprx &lt;number&gt; &lt;number&gt;\n&quot;<br/>&#x9;&#x9;&#x9;   &quot;Finds approximations to fractions\n&quot;<br/>&#x9;&#x9;&#x9;   &quot;Marion McCoskey, <a href="http://www.mckyyy@aol.com">http://www.mckyyy@aol.com</a>\n&quot;);<br/>&#x9;return 0;<br/>}</p></div>