<a href="/tuning">back to list</a><h1>MOS software challenge</h1><h3>Carl Lumma &#x3C;clumma@xxx.xxxx&#x3E;</h3><span>3/9/1999 8:23:25 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>To identify an MOS, you need...</p><p>1. Generator<br/>2. Interval of equivalence<br/>3. Number of elements in chain</p><p>...can you imagine a little program that takes any two as input and turns<br/>out a range for the third?</p><p>Carl</p></div><h3>manuel.op.de.coul@xxx.xx</h3><span>4/2/1999 5:00:21 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Carl Lumma wrote 10-03-99:<br/>&gt; To identify an MOS, you need...<br/>&gt;<br/>&gt; 1. Generator<br/>&gt; 2. Interval of equivalence<br/>&gt; 3. Number of elements in chain</p><p>&gt; ...can you imagine a little program that takes any two as input and turns<br/>&gt; out a range for the third?</p><p>You didn&apos;t specify what property or constraint on the MOS you want to<br/>accomplish.<br/>I once wrote a routine that takes 2. and 3. and gives a range for the<br/>generator for the scale to be monotonic, preserving Myhill&apos;s property.<br/>It also needs to know the pitch class of the generator. Obviously if the<br/>generator is degree 1 in a chain of twelve, there is a different range than<br/>when it&apos;s degree 7. Here&apos;s the code, I don&apos;t now if this is what you had in<br/>mind. I suppose it might be modified to take 1. and 3. and produce 2.<br/>although I haven&apos;t thought about this.</p><p>   procedure Pythagorean_Fifth_Limits (Scale_Size   : in  Positive;<br/>                                       Octave       : in  Long_Float;<br/>                                       Fifth_Degree : in  Positive;<br/>                                       Lower_Limit  : out Long_Float;<br/>                                       Upper_Limit  : out Long_Float) is<br/>      Mlt     : Positive := 1;<br/>      Log_Oct : constant Long_Float := Log2(Octave);<br/>      Eqf     : constant Long_Float :=<br/>        Log_Oct * Long_Float(Fifth_Degree) / Long_Float(Scale_Size);<br/>   begin<br/>      if Fifth_Degree &gt;= Scale_Size or else<br/>        Octave &lt;= 0.0 or else<br/>        Scale_Size = 1 or else<br/>        Greatest_Common_Divisor(Fifth_Degree, Scale_Size) /= 1 then<br/>         raise Argument_Error;<br/>      end if;<br/>      while (Mlt * Fifth_Degree) mod Scale_Size /= 1 loop<br/>         Mlt := Mlt + 1;<br/>      end loop;<br/>      Lower_Limit := Eqf - (Log_Oct / Long_Float(Scale_Size * Mlt));<br/>      Upper_Limit := Eqf + (Log_Oct / Long_Float(Scale_Size *<br/>        (Scale_Size - Mlt)));<br/>   end Pythagorean_Fifth_Limits;</p><p>Manuel Op de Coul    <a href="mailto:coul@ezh.nl">coul@ezh.nl</a></p></div>