<a href="/tuning">back to list</a><h1>a combinational problem involving neo-gothic cadences in a serial context</h1><h3><a id=38943 href="#38943">ðŸ”—</a>Christopher Bailey &#x3C;cb202@columbia.edu&#x3E;</h3><span>9/7/2002 7:43:02 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I am working with some 17-tet materials,  and looking into a combinational<br/>problem.  (Actually, the problem is not really specific to 17-tet, it<br/>could refer to any et.)</p><p>Let&apos;s say we have three serial rows, X, Y, and Z in going at once,<br/>in counterpoint,  like yay:</p><p>X&lt;. . . . . . . . . &gt;<br/>Y&lt;. . . . . . . . .&gt;<br/>Z&lt;. . . . . . . . .&gt;</p><p>and let&apos;s say that we might happen to notice in the midst of this, a set<br/>of notes like yay:</p><p>&lt; . . . . . . .  E D F  . . . . . .&gt;<br/>&lt; . . . . . . .  B C  . . . . . .&gt;<br/>&lt; . . . . . . . G F  . . . . . .&gt;</p><p>Well, now, isn&apos;t that nice,  we can compose out those notes into a nice<br/>little neo-gothic cadence.</p><p>E - D - F<br/>B ----- C<br/>G ----- F</p><p>If these rows are scored for 3 instruments, one on each row, (and the<br/>register in which each instrument plays a given note is free), then the<br/>following group of row subsets:</p><p>oboe:     &lt; . . . . . . .  G D F  . . . . . .&gt;<br/>clarinet: &lt; . . . . . . .  B F  . . . . . .&gt;<br/>bassoon:  &lt; . . . . . . . E C  . . . . . .&gt;</p><p>can also still be composed out into a properly registrated neo-gothic<br/>cadence,  using some  &quot;instrument crossing&quot;  (which will make for<br/>timbrally interesting-sounding result):</p><p>E (bsn)     D (oboe)    F (clarinet)<br/>B (clar)                C (bassoon)<br/>G (oboe)                F (oboe)</p><p>Let&apos;s call the fact of this neo-gothically-compose-out-able bunch of<br/>notes, occuring in the midst of this  serial counterpoint,<br/>&quot;EUREKA&quot;.   EUREKA could be the above cadence, at any transposition level.<br/>The notes of EUREKA could be distributed in any fashion as long as they<br/>can be squeezed into the right ordering.  Thus the following are all valid<br/>&quot;finds&quot; of EUREKA:</p><p>&lt; . . . . . . .  Gb Bb Db Fb  . . . . . .&gt;<br/>&lt; . . . . . . .  Eb Fb        . . . . . .&gt;<br/>&lt; . . . . . . . Eb Cb         . . . . . .&gt;</p><p>composed out into a neo-gothic cadence:</p><p>Eb  -   Db  -  Fb<br/>Bb  -   -   -  Cb<br/>Gb  -   -   -  Fb</p><p>&lt; . . . . . . .  G# B A   . . . . . .&gt;<br/>&lt; . . . . . . .  D# F# E  . . . . . .&gt;<br/>&lt; . . . . . . .  B A      . . . . . .&gt;</p><p>composed out:</p><p>G# - F# - A<br/>D# - - -  E<br/>B  - - -  A</p><p>and so on for these examples:</p><p>&lt; . . . . . . .  E A G   . . . . . .&gt;<br/>&lt; . . . . . . .  F# G    . . . . . .&gt;<br/>&lt; . . . . . . .  C# D    . . . . . .&gt;</p><p>&lt; . . . . . . .  A G C  . . . . . .&gt;<br/>&lt; . . . . . . .  E Bb F C . . . . . .&gt;<br/>&lt; . . . . . . . . . . . . . . . .&gt;</p><p>and so on. . . . . . . . . . .</p><p>  What I am looking to do is find a row(s) (in a given et) that, in some<br/>combination(s) of 3 versions of itself (ie.,  inversions, retrogrades,<br/>retrograde inversions or transpositions),   will yield as many instances<br/>of &quot;EUREKA&quot; as possible.</p><p>I am trying to write a computer program, that I can give it a row,<br/>and it will try all the possible combinations of 3 versions of the row,<br/>and &quot;look around for&quot;  EUREKA in each combination.   It would tally up the<br/>number of EUREKAs it finds in each combo, and print out the highest<br/>scoring combos.</p><p>So it might output the following &quot;If you put the row,  plus itself<br/>transposed up 6 steps,  plus an inversion transposed 3 steps, then<br/>you can find 6 EUREKAs.  That&apos;s the best you can do with this row.&quot;</p><p>So. . . . . I know how to get a program to try all the different<br/>combinations of different row forms, that&apos;s not too much of a problem.</p><p>The problem is to get it to scan through a given combination of rows,  and<br/>look around in all sorts of ways,  trying to find EUREKA.  The problem<br/>is that EUREKA might happen in all sorts of ways.  The ways it could<br/>happen, distribution between voices, etc. seem limitless.   What&apos;s an<br/>efficient way of defining EUREKA and how to &quot;look around for it&quot;? Is there<br/>an efficient way to describe how to   scan through a row combination<br/>looking for EUREKA?  A way efficient and  tidy enough to be made into a<br/>computable algorithm?</p><p>The only progress I&apos;ve made so far is that EUREKA can be described as two<br/>pitch-class sets, in order.  In 12-tone equal they would be:</p><p>2 6 9 11 / 0 7 (0)            (i.e.  D F# A B / C G)</p><p>or any transposition thereof.</p><p>So, to generalize, I&apos;m looking for an algorithm to scan through a<br/>contrapuntal combination of  rows (or any ordered segments) looking for a<br/>set (or in this case, 2 sets)  somehow distributed  amongst adjacent<br/>pitch-classes in the rows, or among the rows.</p><p>How can we teach a computer to do this? Can it be done combinationally, or<br/>does this look like a problem that should be solved entirely in a<br/>different way, like with neural nets or genetic algorithms?</p><p>Any ideas?</p><p>c bailey</p></div>