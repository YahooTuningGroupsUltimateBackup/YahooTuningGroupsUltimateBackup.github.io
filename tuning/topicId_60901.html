<a href="/tuning">back to list</a><h1>thinking out loud about a 22-tet adaptive algorithm</h1><h3>Aaron Krister Johnson &#x3C;aaron@akjmusic.com&#x3E;</h3><span>10/1/2005 11:53:05 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>...would any one have any ideas about/like to collaborate on a 22-tet adaptive<br/>tuning script in python? my thought would be a simple curses or text based<br/>interface, like a MOD tracker, where one could alter manually any pitches<br/>that the algorithm missed, or ones that one wanted to be deliberately<br/>dissonant, etc.</p><p>i know that there are adaptive algorithms out there (like DeLaubenfel&apos;s) but<br/>my objections are:</p><p>1) they are not open source<br/>2) they are not availble for me on linux, or not available.<br/>3) they are ji centric, and for my purposes, i think it would be easier and<br/>perhaps more desirable to have a 31-equal or 22-equal or 19-equal algorithm.<br/>it would be easier to program for sure, i would think.</p><p>i want to be able to have a more productive tool than hand-coding in ASCII<br/>like my existing custom tool, et_compose. i think it would be fun to be able<br/>to improvise something and let an algorithm do most of the work of detuning,<br/>then i could hand prune things.</p><p>i would want to start with 22-tet because i want to do weirder more<br/>surprisingly non-typical western sounding stuff first right now.</p><p>that&apos;s my vision anyway.</p><p>-aaron.</p></div><h3>Carl Lumma &#x3C;clumma@yahoo.com&#x3E;</h3><span>10/2/2005 11:19:03 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; ...would any one have any ideas about/like to collaborate on<br/>&gt; a 22-tet adaptive tuning script in python?</p><p>I would.</p><p>&gt; 3) they are ji centric, and for my purposes, i think it would<br/>&gt; be easier and perhaps more desirable to have a 31-equal or<br/>&gt; 22-equal or 19-equal algorithm.</p><p>Why?</p><p>&gt; it would be easier to program for sure, i would think.</p><p>Why?</p><p>&gt; i would want to start with 22-tet because i want to do weirder<br/>&gt; more surprisingly non-typical western sounding stuff first right<br/>&gt; now.</p><p>Maybe we should start by answering the question: What&apos;s the<br/>difference between a key-guessing algorithm and an adaptive<br/>tuning algorithm?</p></div><h3>Aaron Krister Johnson &#x3C;aaron@akjmusic.com&#x3E;</h3><span>10/2/2005 1:16:12 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On Sunday 02 October 2005 1:19 pm, Carl Lumma wrote:<br/>&gt; &gt; ...would any one have any ideas about/like to collaborate on<br/>&gt; &gt; a 22-tet adaptive tuning script in python?<br/>&gt;<br/>&gt; I would.</p><p>excellent!</p><p>&gt; &gt; 3) they are ji centric, and for my purposes, i think it would<br/>&gt; &gt; be easier and perhaps more desirable to have a 31-equal or<br/>&gt; &gt; 22-equal or 19-equal algorithm.<br/>&gt;<br/>&gt; Why?</p><p>I would think that reducing the potential pitch space to a handful of discreet<br/>equal steps would reduce the drift.</p><p>I could be wrong, though.</p><p>Anyway, I am also sonically personally more drawn to solving the 22-equal<br/>example; if get JI out of it with minor modifications, that&apos;s ok too.</p><p>&gt;<br/>&gt; &gt; it would be easier to program for sure, i would think.<br/>&gt;<br/>&gt; Why?<br/>&gt;<br/>&gt; &gt; i would want to start with 22-tet because i want to do weirder<br/>&gt; &gt; more surprisingly non-typical western sounding stuff first right<br/>&gt; &gt; now.<br/>&gt;<br/>&gt; Maybe we should start by answering the question: What&apos;s the<br/>&gt; difference between a key-guessing algorithm and an adaptive<br/>&gt; tuning algorithm?</p><p>I think that would depend on the type of adaptive algorithm....I would first<br/>want to start simple, perhaps by declaring a scale to the algorithm if it<br/>helps, and maybe just start by feeding it chords, and having it guess the<br/>roots.</p><p>My model would be to have two arrays, a &apos;current&apos; and a &apos;past&apos; array. The<br/>&apos;current&apos; would contain all the current &apos;note-on&apos; pitches from analysis of<br/>12-equal MIDI file at a given timestamp, and try to calculate the maximally<br/>consonant interpretation of the simultaneous pitches in the given pitch<br/>space. As a rule, I would like to try not allowing the bending of any pitches<br/>that enter after previous sounding pitches, but instead find the maximully<br/>consonant new note to complement the already sounding notes.</p><p>The purpose of the &apos;past&apos; array would be to hold the last chord or note as a<br/>reference, for comparison, to avoid melodic drift.</p><p>It&apos;s all just ideas right now, but I&apos;m glad you want to help.</p><p>-Aaron.</p></div><h3>Carl Lumma &#x3C;clumma@yahoo.com&#x3E;</h3><span>10/3/2005 10:33:22 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt;&gt; 3) they are ji centric, and for my purposes, i think it<br/>&gt;&gt;&gt; would be easier and perhaps more desirable to have a<br/>&gt;&gt;&gt; 31-equal or 22-equal or 19-equal algorithm.<br/>&gt;&gt;<br/>&gt;&gt; Why?<br/>&gt;<br/>&gt; I would think that reducing the potential pitch space to a<br/>&gt; handful of discreet equal steps would reduce the drift.</p><p>It depends on what kind of progressions you want to play.<br/>In 22-tET the syntonic comma is actually larger than in JI,<br/>so the shift/drift is worse.</p><p>&gt; Anyway, I am also sonically personally more drawn to solving<br/>&gt; the 22-equal example; if get JI out of it with minor<br/>&gt; modifications, that&apos;s ok too.</p><p>I love 22 and would be happy to work on 22-specific solution.<br/>But then, numbers are just numbers to a computer.  I feel<br/>like if we formulate the problem correctly, the system would<br/>work for a wide variety of tunings.  I could be wrong, though.</p><p>&gt;&gt; Maybe we should start by answering the question: What&apos;s the<br/>&gt;&gt; difference between a key-guessing algorithm and an adaptive<br/>&gt;&gt; tuning algorithm?<br/>&gt;<br/>&gt; I think that would depend on the type of adaptive algorithm....<br/>&gt; I would first want to start simple, perhaps by declaring a<br/>&gt; scale to the algorithm if it helps, and maybe just start by<br/>&gt; feeding it chords, and having it guess the roots.</p><p>That sounds like key-guessing.  It lets you squeeze &gt; 12<br/>tones/octave out of a 12-tone instrument, but it won&apos;t<br/>address shift/drift as Vicentino&apos;s method does.</p><p>&gt; My model would be to have two arrays, a &apos;current&apos; and a<br/>&gt; &apos;past&apos; array. The &apos;current&apos; would contain all the current<br/>&gt; &apos;note-on&apos; pitches from analysis of 12-equal MIDI file at<br/>&gt; a given timestamp, and try to calculate the maximally<br/>&gt; consonant interpretation of the simultaneous pitches in<br/>&gt; the given pitch space. As a rule, I would like to try not<br/>&gt; allowing the bending of any pitches that enter after<br/>&gt; previous sounding pitches, but instead find the maximully<br/>&gt; consonant new note to complement the already sounding notes.</p><p>Have you seen...</p><p><a href="http://lumma.org/music/theory/Adaptive.txt">http://lumma.org/music/theory/Adaptive.txt</a></p><p>?</p><p>-Carl</p></div><h3>George D. Secor &#x3C;gdsecor@yahoo.com&#x3E;</h3><span>10/3/2005 11:52:14 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Aaron Krister Johnson &lt;aaron@a...&gt;<br/>wrote:<br/>&gt;<br/>&gt; ...would any one have any ideas about/like to collaborate on a 22-<br/>tet adaptive<br/>&gt; tuning script in python? my thought would be a simple curses</p><p>Hey, man, I&apos;d be careful with my language if I were you, even if this<br/>is only a computer processor you&apos;re talking to.  Cyberbeasts could<br/>get nasty if you set them a bad example.  ;-)</p><p>&gt; or text based<br/>&gt; interface, like a MOD tracker, where one could alter manually any<br/>pitches<br/>&gt; that the algorithm missed, or ones that one wanted to be<br/>deliberately<br/>&gt; dissonant, etc.</p><p>Only a couple of thoughts (see below).</p><p>&gt; i know that there are adaptive algorithms out there (like<br/>DeLaubenfel&apos;s) but<br/>&gt; my objections are:<br/>&gt;<br/>&gt; 1) they are not open source<br/>&gt; 2) they are not availble for me on linux, or not available.<br/>&gt; 3) they are ji centric, and for my purposes, i think it would be<br/>easier and<br/>&gt; perhaps more desirable to have a 31-equal or 22-equal or 19-equal<br/>algorithm.<br/>&gt; it would be easier to program for sure, i would think.<br/>&gt;<br/>&gt; i want to be able to have a more productive tool than hand-coding<br/>in ASCII<br/>&gt; like my existing custom tool, et_compose. i think it would be fun<br/>to be able<br/>&gt; to improvise something and let an algorithm do most of the work of<br/>detuning,<br/>&gt; then i could hand prune things.<br/>&gt;<br/>&gt; i would want to start with 22-tet because i want to do weirder more<br/>&gt; surprisingly non-typical western sounding stuff first right now.<br/>&gt;<br/>&gt; that&apos;s my vision anyway.<br/>&gt;<br/>&gt; -aaron.</p><p>You&apos;ll probably want to adjust your pitches in increments of a single<br/>small interval, and that would probably be a single degree of an ET<br/>that&apos;s a multiple of 22.  The lowest multiple of 22 that&apos;s 11-limit<br/>consistent is 176; it gets all the 11-limit consonances within 3<br/>cents (and you have to go considerably higher before you find<br/>anything that&apos;s clearly better -- such as 836, with 0.236c max<br/>error).  One problem with 176 is that it would overcorrect 4:5, so<br/>836 might indeed be better -- note that it&apos;s also a multiple of 19.</p><p>19 or 31 are more friendly to adaptive JI, since (unlike 22) each one<br/>already contains at least one consonant interval with no more than a<br/>couple of cents error (which would simplify the algorithm<br/>considerably).</p><p>--George</p></div><h3>wallyesterpaulrus &#x3C;wallyesterpaulrus@yahoo.com&#x3E;</h3><span>10/3/2005 4:15:50 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Aaron Krister Johnson &lt;aaron@a...&gt; wrote:<br/>&gt;<br/>&gt; ...would any one have any ideas about/like to collaborate on a 22-tet adaptive<br/>&gt; tuning script in python? my thought would be a simple curses or text based<br/>&gt; interface, like a MOD tracker, where one could alter manually any pitches<br/>&gt; that the algorithm missed, or ones that one wanted to be deliberately<br/>&gt; dissonant, etc.<br/>&gt;<br/>&gt; i know that there are adaptive algorithms out there (like DeLaubenfel&apos;s) but<br/>&gt; my objections are:<br/>&gt;<br/>&gt; 3) they are ji centric, and for my purposes, i think it would be easier and<br/>&gt; perhaps more desirable to have a 31-equal or 22-equal or 19-equal algorithm.<br/>&gt; it would be easier to program for sure, i would think.</p><p>I don&apos;t get it. You want to write music in, say, 22-equal, and you&apos;d like to have a program<br/>adaptively retune the chords to . . . 22-equal?</p><p>&gt; i would want to start with 22-tet because i want to do weirder more<br/>&gt; surprisingly non-typical western sounding stuff first right now.<br/>&gt;<br/>&gt; that&apos;s my vision anyway.</p><p>I probably need to catch up on the rest of the posts here before I have a clue . . . so sorry!</p></div><h3>Carl Lumma &#x3C;clumma@yahoo.com&#x3E;</h3><span>10/3/2005 4:35:59 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; &gt; I would think that reducing the potential pitch space to a<br/>&gt; &gt; handful of discreet equal steps would reduce the drift.<br/>&gt;<br/>&gt; It depends on what kind of progressions you want to play.<br/>&gt; In 22-tET the syntonic comma is actually larger than in JI,<br/>&gt; so the shift/drift is worse.</p><p>On the other hand, it could be used in a Vicentino-like<br/>solution to render decatonic music in JI with minimal<br/>shift/drift.</p><p>-Carl</p></div><h3>wallyesterpaulrus &#x3C;wallyesterpaulrus@yahoo.com&#x3E;</h3><span>10/3/2005 4:54:37 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Aaron Krister Johnson &lt;aaron@a...&gt; wrote:<br/>&gt; On Sunday 02 October 2005 1:19 pm, Carl Lumma wrote:<br/>&gt; &gt; &gt; ...would any one have any ideas about/like to collaborate on<br/>&gt; &gt; &gt; a 22-tet adaptive tuning script in python?<br/>&gt; &gt;<br/>&gt; &gt; I would.<br/>&gt;<br/>&gt; excellent!<br/>&gt;<br/>&gt; &gt; &gt; 3) they are ji centric, and for my purposes, i think it would<br/>&gt; &gt; &gt; be easier and perhaps more desirable to have a 31-equal or<br/>&gt; &gt; &gt; 22-equal or 19-equal algorithm.<br/>&gt; &gt;<br/>&gt; &gt; Why?<br/>&gt;<br/>&gt; I would think that reducing the potential pitch space to a handful of discreet<br/>&gt; equal steps would reduce the drift.<br/>&gt;<br/>&gt; I could be wrong, though.</p><p>This sounds like the kind of thing I&apos;d be interested in . . . I still don&apos;t know quite what you<br/>mean, but I&apos;m still reading.</p><p>&gt; Anyway, I am also sonically personally more drawn to solving the 22-equal<br/>&gt; example; if get JI out of it with minor modifications, that&apos;s ok too.<br/>&gt;<br/>&gt; &gt;<br/>&gt; &gt; &gt; it would be easier to program for sure, i would think.<br/>&gt; &gt;<br/>&gt; &gt; Why?<br/>&gt; &gt;<br/>&gt; &gt; &gt; i would want to start with 22-tet because i want to do weirder<br/>&gt; &gt; &gt; more surprisingly non-typical western sounding stuff first right<br/>&gt; &gt; &gt; now.<br/>&gt; &gt;<br/>&gt; &gt; Maybe we should start by answering the question: What&apos;s the<br/>&gt; &gt; difference between a key-guessing algorithm and an adaptive<br/>&gt; &gt; tuning algorithm?<br/>&gt;<br/>&gt; I think that would depend on the type of adaptive algorithm....I would first<br/>&gt; want to start simple, perhaps by declaring a scale to the algorithm if it<br/>&gt; helps, and maybe just start by feeding it chords, and having it guess the<br/>&gt; roots.<br/>&gt;<br/>&gt; My model would be to have two arrays, a &apos;current&apos; and a &apos;past&apos; array. The<br/>&gt; &apos;current&apos; would contain all the current &apos;note-on&apos; pitches from analysis of<br/>&gt; 12-equal MIDI file at a given timestamp, and try to calculate the maximally<br/>&gt; consonant interpretation of the simultaneous pitches in the given pitch<br/>&gt; space. As a rule, I would like to try not allowing the bending of any pitches<br/>&gt; that enter after previous sounding pitches, but instead find the maximully<br/>&gt; consonant new note to complement the already sounding notes.<br/>&gt;<br/>&gt; The purpose of the &apos;past&apos; array would be to hold the last chord or note as a<br/>&gt; reference, for comparison, to avoid melodic drift.<br/>&gt;<br/>&gt; It&apos;s all just ideas right now, but I&apos;m glad you want to help.<br/>&gt;<br/>&gt; -Aaron.</p><p>Hmm . . . I think I&apos;m getting the picture. So if the MIDI file contains a I-vi-IV-ii-V-I<br/>progression, and you put it through this 22-equal adaptive tuning, it will drift by 55 cents.<br/>At what point does the &quot;&apos;past&apos; array&quot; come into play to prevent the drift, and how does it<br/>do so? Or perhaps it doesn&apos;t?</p></div><h3>Aaron Krister Johnson &#x3C;aaron@akjmusic.com&#x3E;</h3><span>10/4/2005 12:28:41 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On Monday 03 October 2005 6:54 pm, wallyesterpaulrus wrote:<br/>&gt; Hmm . . . I think I&apos;m getting the picture. So if the MIDI file contains a<br/>&gt; I-vi-IV-ii-V-I progression, and you put it through this 22-equal adaptive<br/>&gt; tuning, it will drift by 55 cents. At what point does the &quot;&apos;past&apos; array&quot;<br/>&gt; come into play to prevent the drift, and how does it do so? Or perhaps it<br/>&gt; doesn&apos;t?</p><p>Good point, to which I would say we can have several options available to the<br/>users of the Python script:</p><p>1) drift mode, where chords with held common tones are *allowed* to drift.<br/>2) fixed mode, where all chords are based on a predefined 12-note fixed<br/>baseline scale (ala vicentino)<br/>3) manual mode, where the user can perform surgury on the scripts results,<br/>post-facto, and tweak things to their liking by means of a &apos;transpose&apos;<br/>feature.</p><p>I think there are legitimte reasons to want drift sometimes, and other times<br/>not. The slipperyness of drift is one of the surrealistically appealing<br/>spects of any alternate tuning, in my book.</p><p>Fixed mode would also still give some surprising slipperyness for something<br/>like a 22-equal adaptive algorithm. I&apos;m really into playing around in<br/>12-of-22-equal (pythagorean), and I like the unexpected planar shift of<br/>pitch! It would be nice to have more vertical consonant sonorities available,<br/>even if not real-time, and I think a simple fixed algorithm would be a good<br/>start. I realize that there would be weird audible comma shifts, but no one<br/>writes in 22-equal to sound normal! If I wanted to use 1/4-comma Vicentino I<br/>would. I would be going for the wild and wacky ear-candy sound of 22-equal<br/>here on purpose, comma shifts, drifts and all.</p><p>My purpose would of course be to be more prolific; hnd coding these things in<br/>&quot;et_compose&quot; is a chore.</p><p>What say you?</p><p>Best,<br/>Aaron</p></div><h3>wallyesterpaulrus &#x3C;wallyesterpaulrus@yahoo.com&#x3E;</h3><span>10/4/2005 2:55:44 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Aaron Krister Johnson &lt;aaron@a...&gt;<br/>wrote:<br/>&gt; On Monday 03 October 2005 6:54 pm, wallyesterpaulrus wrote:<br/>&gt; &gt; Hmm . . . I think I&apos;m getting the picture. So if the MIDI file<br/>contains a<br/>&gt; &gt; I-vi-IV-ii-V-I progression, and you put it through this 22-equal<br/>adaptive<br/>&gt; &gt; tuning, it will drift by 55 cents. At what point does the &quot;&apos;past&apos;<br/>array&quot;<br/>&gt; &gt; come into play to prevent the drift, and how does it do so? Or<br/>perhaps it<br/>&gt; &gt; doesn&apos;t?<br/>&gt;<br/>&gt;<br/>&gt; Good point, to which I would say we can have several options<br/>available to the<br/>&gt; users of the Python script:<br/>&gt;<br/>&gt; 1) drift mode, where chords with held common tones are *allowed* to<br/>drift.<br/>&gt; 2) fixed mode, where all chords are based on a predefined 12-note<br/>fixed<br/>&gt; baseline scale (ala vicentino)</p><p>I don&apos;t see how that&apos;s ala vicentino, nor how this could work here.<br/>What did you have in mind?</p><p>&gt; 3) manual mode, where the user can perform surgury on the scripts<br/>results,<br/>&gt; post-facto, and tweak things to their liking by means of<br/>a &apos;transpose&apos;<br/>&gt; feature.<br/>&gt;<br/>&gt; I think there are legitimte reasons to want drift sometimes, and<br/>other times<br/>&gt; not. The slipperyness of drift is one of the surrealistically<br/>appealing<br/>&gt; spects of any alternate tuning, in my book.<br/>&gt;<br/>&gt; Fixed mode would also still give some surprising slipperyness for<br/>something<br/>&gt; like a 22-equal adaptive algorithm. I&apos;m really into playing around<br/>in<br/>&gt; 12-of-22-equal (pythagorean), and I like the unexpected planar<br/>shift of<br/>&gt; pitch! It would be nice to have more vertical consonant sonorities<br/>available,<br/>&gt; even if not real-time, and I think a simple fixed algorithm would<br/>be a good<br/>&gt; start. I realize that there would be weird audible comma shifts,<br/>but no one<br/>&gt; writes in 22-equal to sound normal!</p><p>I think decatonic music in 22-equal sounds normal, but diatonic music<br/>doesn&apos;t.</p><p>&gt; My purpose would of course be to be more prolific; hnd coding these<br/>things in<br/>&gt; &quot;et_compose&quot; is a chore.<br/>&gt;<br/>&gt; What say you?</p><p>My inclination is to say to you, &quot;get set up on a full 22-note<br/>tuning&quot;! It&apos;s not that hard, and I believe the compositional rewards<br/>will be immense, and you won&apos;t need any software. If nothing else<br/>works, you could spend a couple hundred on an old Ensoniq. Otherwise,<br/>I&apos;d surely still like to help you on this idea of yours, but I think<br/>we&apos;ll have to open lots of cans of worms.</p></div><h3>Aaron Krister Johnson &#x3C;aaron@akjmusic.com&#x3E;</h3><span>10/4/2005 9:39:20 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On Tuesday 04 October 2005 4:55 pm, wallyesterpaulrus wrote:<br/>&gt; --- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Aaron Krister Johnson &lt;aaron@a...&gt;<br/>&gt;<br/>&gt; wrote:<br/>&gt; &gt; On Monday 03 October 2005 6:54 pm, wallyesterpaulrus wrote:<br/>&gt; &gt; &gt; Hmm . . . I think I&apos;m getting the picture. So if the MIDI file<br/>&gt;<br/>&gt; contains a<br/>&gt;<br/>&gt; &gt; &gt; I-vi-IV-ii-V-I progression, and you put it through this 22-equal<br/>&gt;<br/>&gt; adaptive<br/>&gt;<br/>&gt; &gt; &gt; tuning, it will drift by 55 cents. At what point does the &quot;&apos;past&apos;<br/>&gt;<br/>&gt; array&quot;<br/>&gt;<br/>&gt; &gt; &gt; come into play to prevent the drift, and how does it do so? Or<br/>&gt;<br/>&gt; perhaps it<br/>&gt;<br/>&gt; &gt; &gt; doesn&apos;t?<br/>&gt; &gt;<br/>&gt; &gt; Good point, to which I would say we can have several options<br/>&gt;<br/>&gt; available to the<br/>&gt;<br/>&gt; &gt; users of the Python script:<br/>&gt; &gt;<br/>&gt; &gt; 1) drift mode, where chords with held common tones are *allowed* to<br/>&gt;<br/>&gt; drift.<br/>&gt;<br/>&gt; &gt; 2) fixed mode, where all chords are based on a predefined 12-note<br/>&gt;<br/>&gt; fixed<br/>&gt;<br/>&gt; &gt; baseline scale (ala vicentino)<br/>&gt;<br/>&gt; I don&apos;t see how that&apos;s ala vicentino, nor how this could work here.<br/>&gt; What did you have in mind?</p><p>By analogy to Vicentino&apos;s algorithm, not literally... a fixed scale (say, 12<br/>of 22). adaptive algorithm correcting vertical sonorities... not a hard<br/>concept, really.</p><p>How am I not being clear? Sometimes I think you are trying hard to say you<br/>don&apos;t understand when you really do....</p><p>&gt; &gt; 3) manual mode, where the user can perform surgury on the scripts<br/>&gt;<br/>&gt; results,<br/>&gt;<br/>&gt; &gt; post-facto, and tweak things to their liking by means of<br/>&gt;<br/>&gt; a &apos;transpose&apos;<br/>&gt;<br/>&gt; &gt; feature.<br/>&gt; &gt;<br/>&gt; &gt; I think there are legitimte reasons to want drift sometimes, and<br/>&gt;<br/>&gt; other times<br/>&gt;<br/>&gt; &gt; not. The slipperyness of drift is one of the surrealistically<br/>&gt;<br/>&gt; appealing<br/>&gt;<br/>&gt; &gt; spects of any alternate tuning, in my book.<br/>&gt; &gt;<br/>&gt; &gt; Fixed mode would also still give some surprising slipperyness for<br/>&gt;<br/>&gt; something<br/>&gt;<br/>&gt; &gt; like a 22-equal adaptive algorithm. I&apos;m really into playing around<br/>&gt;<br/>&gt; in<br/>&gt;<br/>&gt; &gt; 12-of-22-equal (pythagorean), and I like the unexpected planar<br/>&gt;<br/>&gt; shift of<br/>&gt;<br/>&gt; &gt; pitch! It would be nice to have more vertical consonant sonorities<br/>&gt;<br/>&gt; available,<br/>&gt;<br/>&gt; &gt; even if not real-time, and I think a simple fixed algorithm would<br/>&gt;<br/>&gt; be a good<br/>&gt;<br/>&gt; &gt; start. I realize that there would be weird audible comma shifts,<br/>&gt;<br/>&gt; but no one<br/>&gt;<br/>&gt; &gt; writes in 22-equal to sound normal!<br/>&gt;<br/>&gt; I think decatonic music in 22-equal sounds normal, but diatonic music<br/>&gt; doesn&apos;t.</p><p>right.....so? I&apos;m missing your point here.</p><p>&gt; &gt; My purpose would of course be to be more prolific; hnd coding these<br/>&gt;<br/>&gt; things in<br/>&gt;<br/>&gt; &gt; &quot;et_compose&quot; is a chore.<br/>&gt; &gt;<br/>&gt; &gt; What say you?<br/>&gt;<br/>&gt; My inclination is to say to you, &quot;get set up on a full 22-note<br/>&gt; tuning&quot;! It&apos;s not that hard, and I believe the compositional rewards<br/>&gt; will be immense, and you won&apos;t need any software. If nothing else<br/>&gt; works, you could spend a couple hundred on an old Ensoniq. Otherwise,<br/>&gt; I&apos;d surely still like to help you on this idea of yours, but I think<br/>&gt; we&apos;ll have to open lots of cans of worms.</p><p>I don&apos;t relish the idea of having to play with 2 hands what I could play with<br/>one, nor having a reduced octave range.</p><p>Let&apos;s open the can of worms.</p><p>Aaron.</p></div><h3>wallyesterpaulrus &#x3C;wallyesterpaulrus@yahoo.com&#x3E;</h3><span>10/6/2005 2:35:56 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Aaron Krister Johnson &lt;aaron@a...&gt;<br/>wrote:<br/>&gt; On Tuesday 04 October 2005 4:55 pm, wallyesterpaulrus wrote:<br/>&gt; &gt; --- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Aaron Krister Johnson &lt;aaron@a...&gt;<br/>&gt; &gt;<br/>&gt; &gt; wrote:<br/>&gt; &gt; &gt; On Monday 03 October 2005 6:54 pm, wallyesterpaulrus wrote:<br/>&gt; &gt; &gt; &gt; Hmm . . . I think I&apos;m getting the picture. So if the MIDI file<br/>&gt; &gt;<br/>&gt; &gt; contains a<br/>&gt; &gt;<br/>&gt; &gt; &gt; &gt; I-vi-IV-ii-V-I progression, and you put it through this 22-<br/>equal<br/>&gt; &gt;<br/>&gt; &gt; adaptive<br/>&gt; &gt;<br/>&gt; &gt; &gt; &gt; tuning, it will drift by 55 cents. At what point does<br/>the &quot;&apos;past&apos;<br/>&gt; &gt;<br/>&gt; &gt; array&quot;<br/>&gt; &gt;<br/>&gt; &gt; &gt; &gt; come into play to prevent the drift, and how does it do so? Or<br/>&gt; &gt;<br/>&gt; &gt; perhaps it<br/>&gt; &gt;<br/>&gt; &gt; &gt; &gt; doesn&apos;t?<br/>&gt; &gt; &gt;<br/>&gt; &gt; &gt; Good point, to which I would say we can have several options<br/>&gt; &gt;<br/>&gt; &gt; available to the<br/>&gt; &gt;<br/>&gt; &gt; &gt; users of the Python script:<br/>&gt; &gt; &gt;<br/>&gt; &gt; &gt; 1) drift mode, where chords with held common tones are<br/>*allowed* to<br/>&gt; &gt;<br/>&gt; &gt; drift.<br/>&gt; &gt;<br/>&gt; &gt; &gt; 2) fixed mode, where all chords are based on a predefined 12-<br/>note<br/>&gt; &gt;<br/>&gt; &gt; fixed<br/>&gt; &gt;<br/>&gt; &gt; &gt; baseline scale (ala vicentino)<br/>&gt; &gt;<br/>&gt; &gt; I don&apos;t see how that&apos;s ala vicentino, nor how this could work<br/>here.<br/>&gt; &gt; What did you have in mind?<br/>&gt;<br/>&gt; By analogy to Vicentino&apos;s algorithm, not literally... a fixed scale<br/>(say, 12<br/>&gt; of 22). adaptive algorithm correcting vertical sonorities... not a<br/>hard<br/>&gt; concept, really.</p><p>&gt; How am I not being clear? Sometimes I think you are trying hard to<br/>say you<br/>&gt; don&apos;t understand when you really do....</p><p>Sorry, Aaron, I think I understand what you&apos;re saying but it sounds a<br/>lot like something else (for example Hermode or Justonic), not at all<br/>like Vicentino. I like to make sure there&apos;s clarity both in<br/>communication and on peripheral issues when posting on this list. I<br/>understand that can be annoying sometimes, but I only have the<br/>interest of mutual edification in mind.</p><p>Anyway, if we&apos;re going to start with a fixed 12 of 22 (not that we&apos;ve<br/>resolved all the issues that this would bring up), how about a choice<br/>which contains a wealth of good harmonies already? In my paper on 22,<br/>I mention a hexachordal dodecatonic scale, which happens to conform<br/>to the geometry of the keyboard well. Allow E-F and B-C to be 1 step<br/>of 22-equal, and all the other keyboard semitones to be 2 steps of 22-<br/>equal. Now all the &quot;ratios of 3&quot; and &quot;7:4&quot; and &quot;7:6&quot; intervals will<br/>appear on keys of the same color (white or black), while ratios of 5<br/>will occur on pairs of keys of opposite color. This makes it easy to<br/>see the consonant chords right on the keyboard. Of course, this<br/>doesn&apos;t help you get past the fact that 22-equal is incompatible with<br/>common-practice harmony/tonality, but perhaps this is a starting<br/>point you can work from?</p></div>