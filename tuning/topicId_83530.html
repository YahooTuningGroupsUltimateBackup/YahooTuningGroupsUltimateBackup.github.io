<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning frequency shifting; was: Yaphi spectrum and tuning</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning">back to list</a><h1>frequency shifting; was: Yaphi spectrum and tuning</h1><h3><a id=83530 href="#83530">ðŸ”—</a>Kees van Prooijen &#x3C;keesvp@...&#x3E;</h3><span>5/9/2009 3:05:05 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On Sat, May 9, 2009 at 1:47 PM, Cameron Bobro &lt;misterbobro@...&gt; wrote:</p><p>&gt; The Bode frequency shifter from the mid-late 60s shifts the partials by a<br/>constant Hz amount,<br/>&gt; and that&apos;s the one Daniel is thinking of.</p><p>Thanks for that info Cameron! I must confess, I had never heard of it.<br/>From this site:</p><p><a href="http://www.till.com/articles/moog/patents.html#US03800088">http://www.till.com/articles/moog/patents.html#US03800088</a></p><p>it appears to do (almost) exactly the same thing I&apos;m doing, but then with<br/>analog circuitry.<br/>Amazing!</p><p>-----------------------------------------<br/>The basic idea is an implementation of the trigonometric identity for the<br/>cosine of the sum of two angles to shift the frequency up:</p><p>cos(x + y) = cos(x) cos(y) - sin(x) sin(y)</p><p>(Remember this from high school math?)  And this variation will shift the<br/>frequency down:</p><p>cos(x - y) = cos(x) cos(y) + sin(x) sin(y)</p><p>Bode&apos;s approach uses:</p><p>   - a &quot;Dome Filter&quot;, two all-pass networks tuned 90-degrees apart.  The<br/>   input signal goes through these in parallel, effectively providing<br/>cos*x*and sin<br/>   *x* signals (relatively).<br/>   - two multipliers.<br/>   - a quadrature variable frequency oscillator</p><p> The latter item, the quadrature variable frequency oscillator, is tricky.<br/>Bode uses a fixed-frequency quadrature sine wave oscillator running at<br/>20kHz, a voltage controlled oscillator with a range of 15kHz to 25KHz, and<br/>with two multipliers beats the oscillators to get a range of -5kHz to<br/>+5kHz.  It sounds like a lot of work to go through for a local oscillator,<br/>but it does get you quadrature sine waves, over a wide range, and<br/>through-zero operation.</p></div><h3><a id=83533 href="#83533">ðŸ”—</a>Cameron Bobro &#x3C;misterbobro@...&#x3E;</h3><span>5/9/2009 3:38:31 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Kees van Prooijen &lt;keesvp@...&gt; wrote:<br/>&gt;<br/>&gt; On Sat, May 9, 2009 at 1:47 PM, Cameron Bobro &lt;misterbobro@...&gt; wrote:<br/>&gt;<br/>&gt; &gt; The Bode frequency shifter from the mid-late 60s shifts the partials by a<br/>&gt; constant Hz amount,<br/>&gt; &gt; and that&apos;s the one Daniel is thinking of.<br/>&gt;<br/>&gt; Thanks for that info Cameron! I must confess, I had never heard of it.<br/>&gt; From this site:<br/>&gt;<br/>&gt; <a href="http://www.till.com/articles/moog/patents.html#US03800088">http://www.till.com/articles/moog/patents.html#US03800088</a><br/>&gt;<br/>&gt; it appears to do (almost) exactly the same thing I&apos;m doing, but then with<br/>&gt; analog circuitry.<br/>&gt; Amazing!<br/>&gt;<br/>&gt; -----------------------------------------<br/>&gt; The basic idea is an implementation of the trigonometric identity for the<br/>&gt; cosine of the sum of two angles to shift the frequency up:<br/>&gt;<br/>&gt; cos(x + y) = cos(x) cos(y) - sin(x) sin(y)<br/>&gt;<br/>&gt; (Remember this from high school math?)  And this variation will shift the<br/>&gt; frequency down:<br/>&gt;<br/>&gt; cos(x - y) = cos(x) cos(y) + sin(x) sin(y)<br/>&gt;<br/>&gt; Bode&apos;s approach uses:<br/>&gt;<br/>&gt;    - a &quot;Dome Filter&quot;, two all-pass networks tuned 90-degrees apart.  The<br/>&gt;    input signal goes through these in parallel, effectively providing<br/>&gt; cos*x*and sin<br/>&gt;    *x* signals (relatively).<br/>&gt;    - two multipliers.<br/>&gt;    - a quadrature variable frequency oscillator<br/>&gt;<br/>&gt;  The latter item, the quadrature variable frequency oscillator, is tricky.<br/>&gt; Bode uses a fixed-frequency quadrature sine wave oscillator running at<br/>&gt; 20kHz, a voltage controlled oscillator with a range of 15kHz to 25KHz, and<br/>&gt; with two multipliers beats the oscillators to get a range of -5kHz to<br/>&gt; +5kHz.  It sounds like a lot of work to go through for a local oscillator,<br/>&gt; but it does get you quadrature sine waves, over a wide range, and<br/>&gt; through-zero operation.<br/>&gt;</p><p>So that&apos;s how the Bode filter physically does what it does, interesting! They&apos;re pretty expensive modules, like 700 Euros? or something. I&apos;ve only done this in Csound.</p></div><h3><a id=83537 href="#83537">ðŸ”—</a>Daniel Forro &#x3C;dan.for@...&#x3E;</h3><span>5/9/2009 5:14:47 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 10 May 2009, at 7:05 AM, Kees van Prooijen wrote:</p><p>&gt; Thanks for that info Cameron! I must confess, I had never heard of it.<br/>&gt;<br/>&gt; From this site:<br/>&gt;<br/>&gt; <a href="http://www.till.com/articles/moog/patents.html#US03800088">http://www.till.com/articles/moog/patents.html#US03800088</a><br/>&gt;<br/>&gt; it appears to do (almost) exactly the same thing I&apos;m doing, but &gt; then with analog circuitry.<br/>&gt; Amazing!<br/>&gt;</p><p>Yes, Bode was electronics wizard.</p><p>Daniel Forro</p></div><h3><a id=83546 href="#83546">ðŸ”—</a>Petr Par&#xED;zek &#x3C;p.parizek@...&#x3E;</h3><span>5/10/2009 7:17:06 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Cameron wrote:</p><p>&gt; So that&apos;s how the Bode filter physically does what it does, interesting! They&apos;re<br/>&gt; pretty expensive modules, like 700 Euros? or something. I&apos;ve only done this in Csound.</p><p>If I&apos;ve understood correctly some webpages which I read a few years ago, The CSound&apos;s &quot;Hilbert&quot; algorithm is actually an IIR filter. This sounds a bit weird to me because a correct Hilbert transform impulse should also contain some non-zero coefficients before the original time, not only after, which is impossible to achieve in IIR filters just because of the way they work. But I think, anyway, the webpages did say something in the sense that it&apos;s an approximated version of the Hilbert transform (I have no idea why they don&apos;t use a FIR filter for that which is very easily realisable by convolution -- if I wanted, I could happily do that with the old QBasic for Dos). And I even think that the algorithm makes a tiny delay between the original and the frequency-shifted signal (meaning just a fraction of a millisecond), which, in cases of very low frequency shifts, eventually results in phaser-like effects when you add or subtract the two, instead of just the overall volume rising and falling alternately. I&apos;ve tried the FIR version many times and it always worked perfectly.</p><p>Petr</p></div><h3><a id=83547 href="#83547">ðŸ”—</a>Petr Par&#xED;zek &#x3C;p.parizek@...&#x3E;</h3><span>5/10/2009 7:33:36 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>BTW: Is there anyone who could suggest a piece of hardware which is able to do that today in the 21st century? I had a frequency shifter on my &quot;former&quot; PC sound card but that SBLive has stopped working about 3 years ago :-( ... And I was using that effect sooo much in my music then -- now my frequency-shifting times have gone, it seems.</p><p>Petr</p></div><h3><a id=83548 href="#83548">ðŸ”—</a>Daniel Forro &#x3C;dan.for@...&#x3E;</h3><span>5/10/2009 8:07:58 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>High quality hardware will be pretty expensive if there&apos;s some<br/>(harmonizers can do what you want?). Simple pitch shifting algorithms<br/>used to be a part of multieffect audioprocessors, even onboard DSP in<br/>synthesizers.</p><p>And why not to go in the direction of some VST plug-in? For sure<br/>there&apos;s something. Or non realtime pitch shifting algorithms in<br/>sample editing software... As I don&apos;t use it, I can&apos;t help you more<br/>in detail.</p><p>Daniel Forro</p><p>On 10 May 2009, at 11:33 PM, Petr Par&iacute;zek wrote:</p><p>&gt;<br/>&gt;<br/>&gt;<br/>&gt; BTW: Is there anyone who could suggest a piece of hardware which is<br/>&gt; able to do that today in the 21st century? I had a frequency<br/>&gt; shifter on my &quot;former&quot; PC sound card but that SBLive has stopped<br/>&gt; working about 3 years ago :-( ... And I was using that effect sooo<br/>&gt; much in my music then -- now my frequency-shifting times have gone,<br/>&gt; it seems.<br/>&gt;<br/>&gt; Petr</p></div><h3><a id=83549 href="#83549">ðŸ”—</a>Charles Lucy &#x3C;lucy@...&#x3E;</h3><span>5/10/2009 8:28:27 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>You might try Melodyne to pitch shift from audio.<br/>My son uses a Logic Plug-in or ToneWorks hardware, and PitchWheel from<br/>QuikQuak</p><p>On 10 May 2009, at 16:07, Daniel Forro wrote:</p><p>&gt;<br/>&gt;<br/>&gt; High quality hardware will be pretty expensive if there&apos;s some<br/>&gt; (harmonizers can do what you want?). Simple pitch shifting algorithms<br/>&gt; used to be a part of multieffect audioprocessors, even onboard DSP in<br/>&gt; synthesizers.<br/>&gt;<br/>&gt; And why not to go in the direction of some VST plug-in? For sure<br/>&gt; there&apos;s something. Or non realtime pitch shifting algorithms in<br/>&gt; sample editing software... As I don&apos;t use it, I can&apos;t help you more<br/>&gt; in detail.<br/>&gt;<br/>&gt; Daniel Forro<br/>&gt;<br/>&gt; On 10 May 2009, at 11:33 PM, Petr Par&iacute;zek wrote:<br/>&gt;<br/>&gt; &gt;<br/>&gt; &gt;<br/>&gt; &gt;<br/>&gt; &gt; BTW: Is there anyone who could suggest a piece of hardware which is<br/>&gt; &gt; able to do that today in the 21st century? I had a frequency<br/>&gt; &gt; shifter on my &quot;former&quot; PC sound card but that SBLive has stopped<br/>&gt; &gt; working about 3 years ago :-( ... And I was using that effect sooo<br/>&gt; &gt; much in my music then -- now my frequency-shifting times have gone,<br/>&gt; &gt; it seems.<br/>&gt; &gt;<br/>&gt; &gt; Petr<br/>&gt;</p><p>Charles Lucy<br/>lucy@...</p><p>- Promoting global harmony through LucyTuning -</p><p>for information on LucyTuning go to:<br/><a href="http://www.lucytune.com">http://www.lucytune.com</a></p><p>For LucyTuned Lullabies go to:<br/><a href="http://www.lullabies.co.uk">http://www.lullabies.co.uk</a></p></div><h3><a id=83555 href="#83555">ðŸ”—</a>Petr Par&#xED;zek &#x3C;p.parizek@...&#x3E;</h3><span>5/10/2009 1:38:56 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Daniel and Charles,</p><p>thanks for your contributions; but I meant linear frequency shifting as Kees and Cameron were discussing, not ordinary exponential pitch shifting -- i.e. what I&apos;m talking about is the effect which can turn a harmonic triad of 400:500:600Hz into, let&apos;s say, totally inharmonic 430:530:630Hz. I was using this effect a lot in my older recordings. Nowadays I can only do that with pre-recorded sounds by using a pair of ring modulators and a hilbert transformer, but no longer in real time.</p><p>Petr</p></div><h3><a id=83557 href="#83557">ðŸ”—</a>Cameron Bobro &#x3C;misterbobro@...&#x3E;</h3><span>5/10/2009 1:52:30 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Petr Par&iacute;zek &lt;p.parizek@...&gt; wrote:<br/>&gt;<br/>&gt; Cameron wrote:<br/>&gt;<br/>&gt; &gt; So that&apos;s how the Bode filter physically does what it does, interesting! They&apos;re<br/>&gt; &gt; pretty expensive modules, like 700 Euros? or something. I&apos;ve only done this in Csound.<br/>&gt;<br/>&gt; If I&apos;ve understood correctly some webpages which I read a few years ago, The CSound&apos;s &quot;Hilbert&quot; algorithm is actually an IIR filter. This sounds a bit weird to me because a correct Hilbert transform impulse should also contain some non-zero coefficients before the original time, not only after, which is impossible to achieve in IIR filters just because of the way they work. But I think, anyway, the webpages did say something in the sense that it&apos;s an approximated version of the Hilbert transform (I have no idea why they don&apos;t use a FIR filter for that which is very easily realisable by convolution -- if I wanted, I could happily do that with the old QBasic for Dos). And I even think that the algorithm makes a tiny delay between the original and the frequency-shifted signal (meaning just a fraction of a millisecond), which, in cases of very low frequency shifts, eventually results in phaser-like effects when you add or subtract the two, instead of just the overall volume rising and falling alternately. I&apos;ve tried the FIR version many times and it always worked perfectly.<br/>&gt;<br/>&gt; Petr<br/>&gt;</p><p>Yes, the Hilbert in Csound is imperfect, they mention it in the documentation. The guy who writes the wonderful Straightliner VST instrument told me that he uses the theoretically perfect FIR hilbert in his (superb) stereo spread algorithms, so it obviously works in realtime and can be coded in C.</p><p>When I said I do this in Csound, I meant longhand. :-) Like adsyn, and piles of oscillators, and so on. Pain in the butt, but total control.</p></div><h3><a id=83560 href="#83560">ðŸ”—</a>Kees van Prooijen &#x3C;keesvp@...&#x3E;</h3><span>5/10/2009 2:26:52 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>A theoretically perfect FIR implementation of the discrete Hilbert transform<br/>has an<br/>infinite kernel size, and is non causal, so it&apos;s impossible to work in real<br/>time. Or am<br/>I misinterpreting something here?<br/>In a realistic implementation, the better the approximation, the longer the<br/>time delay.<br/>I implemented it in C++ if anybody&apos;s interested.</p><p>On Sun, May 10, 2009 at 1:52 PM, Cameron Bobro &lt;misterbobro@...&gt;wrote:</p><p>&gt;    Yes, the Hilbert in Csound is imperfect, they mention it in the<br/>&gt; documentation. The guy who writes the wonderful Straightliner VST instrument<br/>&gt; told me that he uses the theoretically perfect FIR hilbert in his (superb)<br/>&gt; stereo spread algorithms, so it obviously works in realtime and can be coded<br/>&gt; in C.<br/>&gt;<br/>&gt;</p></div><h3><a id=83561 href="#83561">ðŸ”—</a>Cameron Bobro &#x3C;misterbobro@...&#x3E;</h3><span>5/10/2009 2:40:55 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:tuning@yahoogroups.com">tuning@yahoogroups.com</a>, Kees van Prooijen &lt;keesvp@...&gt; wrote:<br/>&gt;<br/>&gt; A theoretically perfect FIR implementation of the discrete Hilbert &gt;transform<br/>&gt; has an<br/>&gt; infinite kernel size, and is non causal, so it&apos;s impossible to work &gt;in real<br/>&gt; time. Or am<br/>&gt; I misinterpreting something here?<br/>&gt; In a realistic implementation, the better the approximation, the &gt;longer the<br/>&gt; time delay.<br/>&gt; I implemented it in C++ if anybody&apos;s interested.</p><p>&quot;Realtime&quot; here means &quot;with some microscopic latency&quot;. Hm, it&apos;s beyond me, but perhaps the fact that it&apos;s essentially a 1024 partial additive synthesizer has something to do with being able to implement it practically?</p><p>&gt;<br/>&gt; On Sun, May 10, 2009 at 1:52 PM, Cameron Bobro &lt;misterbobro@...&gt;wrote:<br/>&gt;<br/>&gt; &gt;    Yes, the Hilbert in Csound is imperfect, they mention it in the<br/>&gt; &gt; documentation. The guy who writes the wonderful Straightliner VST instrument<br/>&gt; &gt; told me that he uses the theoretically perfect FIR hilbert in his (superb)<br/>&gt; &gt; stereo spread algorithms, so it obviously works in realtime and can be coded<br/>&gt; &gt; in C.<br/>&gt; &gt;<br/>&gt; &gt;<br/>&gt;</p></div><h3><a id=83562 href="#83562">ðŸ”—</a>Petr Par&#xED;zek &#x3C;p.parizek@...&#x3E;</h3><span>5/10/2009 3:07:02 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Cameron wrote:</p><p>&gt; &quot;Realtime&quot; here means &quot;with some microscopic latency&quot;. Hm, it&apos;s beyond me,<br/>&gt; but perhaps the fact that it&apos;s essentially a 1024 partial additive synthesizer<br/>&gt; has something to do with being able to implement it practically?</p><p>Here I can&apos;t speak for myself because I only do that with pre-recorded sounds, which allows me to use filters as large as I can load into the actual impulse memory used by CoolEdit. Sometimes I was even using such terribly long delays as 4 seconds or similar (which actually results in an 8-second impulse because the filter has to be symmetric). :-D</p><p>Petr</p></div><h3><a id=83569 href="#83569">ðŸ”—</a>Petr Par&#xED;zek &#x3C;p.parizek@...&#x3E;</h3><span>5/11/2009 1:15:43 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Daniel wrote:</p><p>&gt; It&apos;s necessary to distinguish   Frequency Shifter (shifting all harmonics/non harmonics,<br/>&gt; that means changing timbre) and Pitch Shifter (shifting the pitch, of course</p><p>Exactly. And that&apos;s why I said I was trying to find a piece of hardware that could work as a frequency shifter, not a pitch shifter.</p><p>Petr</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            