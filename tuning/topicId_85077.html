<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup tuning Better tuning resolution with Timidity, but still not good enough</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/tuning">back to list</a><h1>Better tuning resolution with Timidity, but still not good enough</h1><h3><a id=85077 href="#85077">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/19/2009 9:48:57 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Upon the suggestion of Marcel de Velde, I have installed Timidity for<br/>Windows XP, ran the TWsynth component and hooked up the midi to a<br/>decent XG soundfont via Midi Yoke.</p><p>The XG-soundset is here (you have to sign up for download):</p><p><a href="http://www.sf2midi.com/soundfonts/download/yamaha-xg-sound-set-sf2-108.html">http://www.sf2midi.com/soundfonts/download/yamaha-xg-sound-set-sf2-108.html</a></p><p>After going through several badly tuned soundfonts and patches, I<br/>finally found in the original Yamaha XG sound set a French Horn (patch<br/>61) that sounds fairly decent and very correctly tuned.</p><p>Using the same AutoStrobe experiment setup, I measured each pitch from<br/>A=440 Hz up a quarter-tone by 1 cent increments. RHS signifies SCALA&apos;s<br/>steps from A up in cents, LHS indicates actual sounds from the<br/>Timidity Synth using the XG-soundset.</p><p>cents - measured<br/>0 - 0<br/>1 - 1<br/>2 - 1.9<br/>3 - 2.9<br/>4 - 3.8<br/>5 - 4.7<br/>6 - 6.5<br/>7 - 6.5<br/>8 - 8.3<br/>9 - 9.2<br/>...<br/>...<br/>50 - 50</p><p>Apparently, the tuning is done by about 0.93 cent increments. Maximum<br/>deviation from theoretical is half a cent, which is a drastic<br/>improvement compared to the tuning discrepancies with the Yamaha S-<br/>YXG50. I don&apos;t know what the significance of this increment in MIDI<br/>parlance is though. Mayhap the octave is divided into 1296 equal<br/>parts? Or else, could we be dealing with 0.25 Hertz increments?</p><p>A severe problem is the occasional crackling and chopping of the audio<br/>when using TWSynth. Size of the referenced soundfont is not a factor. I am guessing the generic windows audio driver is troublesome. How can<br/>I remedy this situation?</p><p>Cordially,<br/>Oz.</p><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p></div><h3><a id=85080 href="#85080">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/19/2009 10:02:20 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:</p><p>&gt; A severe problem is the occasional crackling and chopping of the audio  &gt; when using TWSynth. Size of the referenced soundfont is not a factor.  &gt; I am guessing the generic windows audio driver is troublesome. How can  &gt; I remedy this situation?</p><p>Timidity on Linux has the option to convert a MIDI file directly to an audio file.  You should be able to do the same thing on Windows.</p><p>                    Graham</p></div><h3><a id=85082 href="#85082">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/19/2009 10:17:03 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>But I am not yet at the point where I will be making audio files. I<br/>want to obtain the same stability as with S-YXG50 using Timidity Synth<br/>in realtime.</p><p>Oz.</p><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p><p>On Oct 20, 2009, at 8:02 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;<br/>&gt;&gt; A severe problem is the occasional crackling and chopping of the<br/>&gt;&gt; audio<br/>&gt;&gt; when using TWSynth. Size of the referenced soundfont is not a factor.<br/>&gt;&gt; I am guessing the generic windows audio driver is troublesome. How<br/>&gt;&gt; can<br/>&gt;&gt; I remedy this situation?<br/>&gt;<br/>&gt; Timidity on Linux has the option to convert a MIDI file<br/>&gt; directly to an audio file.  You should be able to do the<br/>&gt; same thing on Windows.<br/>&gt;</p></div><h3><a id=85092 href="#85092">ðŸ”—</a>Marcel de Velde &#x3C;m.develde@...&#x3E;</h3><span>10/20/2009 12:17:38 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Oz,</p><p>Apparently, the tuning is done by about 0.93 cent increments. Maximum<br/>&gt; deviation from theoretical is half a cent, which is a drastic<br/>&gt; improvement compared to the tuning discrepancies with the Yamaha S-<br/>&gt; YXG50. I don&apos;t know what the significance of this increment in MIDI<br/>&gt; parlance is though. Mayhap the octave is divided into 1296 equal<br/>&gt; parts? Or else, could we be dealing with 0.25 Hertz increments?<br/>&gt;<br/>&gt; A severe problem is the occasional crackling and chopping of the audio<br/>&gt; when using TWSynth. Size of the referenced soundfont is not a factor.<br/>&gt; I am guessing the generic windows audio driver is troublesome. How can<br/>&gt; I remedy this situation?<br/>&gt;<br/>&gt; Cordially,<br/>&gt; Oz.<br/>&gt;</p><p>You can do different soudsettings that will lower the cpu, and choose a<br/>different driver for you soundcard etc under preferences.<br/>Don&apos;t have the crackling problem myself and don&apos;t know what&apos;s causing it in<br/>your case, but it looks like timidity can be made very cpu light and should<br/>work on a 10 year old computer with the right settings.</p><p>Furthermore timidity can cause the notes to be too abubtly cutoff at the<br/>tail because of 0 release envelope.<br/>This will also cause clicks (only on release of the note)<br/>To fix this add a line to your instrument in the cfg file to make a longer<br/>release like this:</p><p>dir &quot;C:\\Documents and<br/>Settings\\mars\\Bureaublad\\Soundfonts\\sonimusicae\\Orgue-de-salon-sf2\\&quot;<br/>bank 0<br/>0 %font &quot;Orguedesalon.sf2&quot; 0 22 rate=:::180 strip=tail</p><p>this is my cfg file for an organ sound.<br/>the last line begins with 0. This is the midi program channel the instrument<br/>receives on.<br/>after the font you see a 0 again, this is the bank of the font, then you see<br/>a 22, this is the midi program channel inside the soundfont that point to a<br/>specific program (like 61 for the french horn in your xg soundfont file).<br/>(note this program 22 sound inside the soundfont now listenes to program 0<br/>in timidity. Also note that some midi equipment will send on channel 1 but<br/>this is seen as channel 0 by timidity. 0 to 127 vs 1 to 128)<br/>btw also note the \\ in the directory line, seems this is somehow needed<br/>otherwise timidity won&apos;t read the directory line correctly.</p><p>As for tuning.<br/>Good to hear that it has better than a cent resolution with pitchbends.<br/>Hope this is enough for realtime playing.<br/>But for non realtime I recomend MIDI Tuning Standard tuning which has a much<br/>better resolution.</p><p>Btw if someone knows a way to tune timidity in realtime with MTS please let<br/>me (and Oz offcourse:) know!</p><p>Good luck and if you need any more help feel free to contact me onlist or<br/>offlist!<br/>Only started using timidity recently but I have it working nicely now.</p><p>Marcel</p></div><h3><a id=85107 href="#85107">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/21/2009 6:30:28 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Dear Marcel,</p><p>On Oct 20, 2009, at 10:17 PM, Marcel de Velde wrote:</p><p>&gt;<br/>&gt;<br/>&gt; Hi Oz,<br/>&gt;<br/>&gt; Apparently, the tuning is done by about 0.93 cent increments. Maximum<br/>&gt; deviation from theoretical is half a cent, which is a drastic<br/>&gt; improvement compared to the tuning discrepancies with the Yamaha S-<br/>&gt; YXG50. I don&apos;t know what the significance of this increment in MIDI<br/>&gt; parlance is though. Mayhap the octave is divided into 1296 equal<br/>&gt; parts? Or else, could we be dealing with 0.25 Hertz increments?<br/>&gt;<br/>&gt; A severe problem is the occasional crackling and chopping of the audio<br/>&gt; when using TWSynth. Size of the referenced soundfont is not a factor.<br/>&gt; I am guessing the generic windows audio driver is troublesome. How can<br/>&gt; I remedy this situation?<br/>&gt;<br/>&gt; Cordially,<br/>&gt; Oz.<br/>&gt;<br/>&gt;<br/>&gt; You can do different soudsettings that will lower the cpu, and &gt; choose a different driver for you soundcard etc under preferences.<br/>&gt; Don&apos;t have the crackling problem myself and don&apos;t know what&apos;s &gt; causing it in your case, but it looks like timidity can be made very &gt; cpu light and should work on a 10 year old computer with the right &gt; settings.<br/>&gt;</p><p>I have tweaked many settings the way you described, without, alas, any remedies for the crackling audio.</p><p>&gt; Furthermore timidity can cause the notes to be too abubtly cutoff at &gt; the tail because of 0 release envelope.<br/>&gt; This will also cause clicks (only on release of the note)<br/>&gt; To fix this add a line to your instrument in the cfg file to make a &gt; longer release like this:<br/>&gt;<br/>&gt; dir &quot;C:\\Documents and Settings\\mars\\Bureaublad\\Soundfonts\&gt; \sonimusicae\\Orgue-de-salon-sf2\\&quot;<br/>&gt; bank 0<br/>&gt; 0 %font &quot;Orguedesalon.sf2&quot; 0 22 rate=:::180 strip=tail<br/>&gt;<br/>&gt; this is my cfg file for an organ sound.<br/>&gt; the last line begins with 0. This is the midi program channel the &gt; instrument receives on.<br/>&gt; after the font you see a 0 again, this is the bank of the font, then &gt; you see a 22, this is the midi program channel inside the soundfont &gt; that point to a specific program (like 61 for the french horn in &gt; your xg soundfont file).<br/>&gt; (note this program 22 sound inside the soundfont now listenes to &gt; program 0 in timidity. Also note that some midi equipment will send &gt; on channel 1 but this is seen as channel 0 by timidity. 0 to 127 vs &gt; 1 to 128)<br/>&gt; btw also note the \\ in the directory line, seems this is somehow &gt; needed otherwise timidity won&apos;t read the directory line correctly.<br/>&gt;</p><p>Thanks for the tips. I tried this suggestion, but alas, again without any fix for the crackling audio.</p><p>I attempted to tweak many settings in TWSynth, but discovered that meddling with the output values (for example, trying to change audio quality from 16-bit to 24-bit) could crash TWsynth and freeze Windows XP every time the synth is re-run. I had to delete the configuration (ini) files often and did a hard boot several times before giving up messing with the output settings.</p><p>I swear I could select Directsound as a driver before, but it somehow disappeared after one of those crashes. A reinstall of DirectX did not help. I am stuck with Windows audio driver unless somebody can suggest another way for TWSynth in Windows XP.</p><p>&gt; As for tuning.<br/>&gt; Good to hear that it has better than a cent resolution with &gt; pitchbends.<br/>&gt; Hope this is enough for realtime playing.<br/>&gt; But for non realtime I recomend MIDI Tuning Standard tuning which &gt; has a much better resolution.<br/>&gt;<br/>&gt; Btw if someone knows a way to tune timidity in realtime with MTS &gt; please let me (and Oz offcourse:) know!<br/>&gt;</p><p>You mean it is actually possible to hear less than 0.1 cent differences realtime while playing around with SCALA Chromatic Keyboard using TWSynth? How does one do that? It would be great to have such a tuning resolution at hand.</p><p>&gt; Good luck and if you need any more help feel free to contact me &gt; onlist or offlist!<br/>&gt; Only started using timidity recently but I have it working nicely now.<br/>&gt;</p><p>Thanks for all your help!</p><p>&gt; Marcel<br/>&gt;<br/>&gt;<br/>&gt;<br/>&gt;</p><p>Oz.</p></div><h3><a id=85108 href="#85108">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/21/2009 8:18:32 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:</p><p>&gt; Apparently, the tuning is done by about 0.93 cent increments. Maximum  &gt; deviation from theoretical is half a cent, which is a drastic  &gt; improvement compared to the tuning discrepancies with the Yamaha S- &gt; YXG50. I don&apos;t know what the significance of this increment in MIDI  &gt; parlance is though. Mayhap the octave is divided into 1296 equal  &gt; parts? Or else, could we be dealing with 0.25 Hertz increments?</p><p>I&apos;ve checked the source code.  The only loss of precision I see is in the pitch bend lookup table, which only has 256 divisions of a semitone.  That should mean about 0.39 cent steps.  Not perfect but better than what you&apos;re seeing.</p><p>It could be fixed fairly easily but I&apos;m not sure it matters.   Does anybody care about pitch bend precision?  I hope the tuning tables are better.  Maybe you could check them.</p><p>                 Graham</p></div><h3><a id=85109 href="#85109">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/21/2009 8:22:15 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Marcel de Velde wrote:</p><p>&gt; Btw if someone knows a way to tune timidity in realtime with MTS please let<br/>&gt; me (and Oz offcourse:) know!</p><p>From the manual,</p><p>              z/Z, --[no-]temper-control<br/>                     Enable/disable MIDI Tuning Standard temperament  control&dash;<br/>                     ling.</p><p>I thought the Scala output worked with it.</p><p>                  Graham</p></div><h3><a id=85139 href="#85139">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/27/2009 11:49:49 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>O Graham,</p><p>Sorry for the late reply. I have been checking qsynth, which is kind<br/>of screwy with the soundfonts (playing C sounds a -200 cents Bb, and<br/>pitch bend commands do not function properly). I have finally managed<br/>to find a copy of twsynth that does not produce crackling audio. So<br/>far so good. I also discovered through trial and error that the<br/>Fantasia (New Age) Pad of the soundfont named &quot;Scc1t2.sf2&quot; features a<br/>sweet sounding (teensy wobbly) and correctly tuned patch. I made new<br/>measurements and confirm that, indeed, the smallest increment in<br/>Timidity must be 0.39 cents (256th of an equal semitone).</p><p>Do you know how the smallest increment can be set to 1024th of an<br/>equal semitone in Timidity++ for Windows? That would equate to nearly<br/>0.1 cent increments. It would be good to have such a resolution handy,<br/>especially considering experimenting with proportional beating chords.<br/>I would appreciate it very much if someone can assist me in that<br/>direction.</p><p>I didn&apos;t check the tuning tables though. I feel much more comfortable<br/>with +12 pitches per octave over 16 channels simultaneously.</p><p>Cordially,<br/>Oz.</p><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p><p>On Oct 22, 2009, at 6:18 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;<br/>&gt;&gt; Apparently, the tuning is done by about 0.93 cent increments. Maximum<br/>&gt;&gt; deviation from theoretical is half a cent, which is a drastic<br/>&gt;&gt; improvement compared to the tuning discrepancies with the Yamaha S-<br/>&gt;&gt; YXG50. I don&apos;t know what the significance of this increment in MIDI<br/>&gt;&gt; parlance is though. Mayhap the octave is divided into 1296 equal<br/>&gt;&gt; parts? Or else, could we be dealing with 0.25 Hertz increments?<br/>&gt;<br/>&gt; I&apos;ve checked the source code.  The only loss of precision I<br/>&gt; see is in the pitch bend lookup table, which only has 256<br/>&gt; divisions of a semitone.  That should mean about 0.39 cent<br/>&gt; steps.  Not perfect but better than what you&apos;re seeing.<br/>&gt;<br/>&gt; It could be fixed fairly easily but I&apos;m not sure it matters.<br/>&gt;  Does anybody care about pitch bend precision?  I hope the<br/>&gt; tuning tables are better.  Maybe you could check them.<br/>&gt;<br/>&gt;<br/>&gt;                  Graham</p></div><h3><a id=85140 href="#85140">ðŸ”—</a>Marcel de Velde &#x3C;m.develde@...&#x3E;</h3><span>10/27/2009 12:39:41 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hello Oz and Graham,</p><p>&gt; Sorry for the late reply. I have been checking qsynth, which is kind<br/>&gt; of screwy with the soundfonts (playing C sounds a -200 cents Bb, and<br/>&gt; pitch bend commands do not function properly). I have finally managed<br/>&gt; to find a copy of twsynth that does not produce crackling audio.<br/>&gt;<br/>Ah good that you found this was the problem!</p><p>&gt; So far so good. I also discovered through trial and error that the<br/>&gt; Fantasia (New Age) Pad of the soundfont named &quot;Scc1t2.sf2&quot; features a<br/>&gt; sweet sounding (teensy wobbly) and correctly tuned patch.<br/>&gt;<br/>Thanks for the tip, will try it out.</p><p>&gt; I made new<br/>&gt; measurements and confirm that, indeed, the smallest increment in<br/>&gt; Timidity must be 0.39 cents (256th of an equal semitone).<br/>&gt;<br/>&gt; Do you know how the smallest increment can be set to 1024th of an<br/>&gt; equal semitone in Timidity++ for Windows? That would equate to nearly<br/>&gt; 0.1 cent increments. It would be good to have such a resolution handy,<br/>&gt; especially considering experimenting with proportional beating chords.<br/>&gt; I would appreciate it very much if someone can assist me in that<br/>&gt; direction.<br/>&gt;<br/>I have a hunch that if you tune by Midi Tuning Standard you will get a<br/>better pitch resoluton.<br/>I just tried out Graham&apos;s tip that Scala&apos;s realtime midi relay output should<br/>also work for MTS and indeed it does! :)<br/>Thank you Graham!</p><p>The way I have it set up is as follows:<br/>I did not have to set any Z flag in Timidity, apparently it was correctly<br/>set allready by default.<br/>I selected in Scala under preferences - midi: synthesizer tuning options<br/>(send): model: 1: MIDI Tuning Standard single notes dump, 3 byte.<br/>Then I installed Loopbe1 (an internal midi relay cable)<br/>The under midi relay in Scala I selected as output loopbe, and in Timidity++<br/>realtime synthesizer I selected as input Loopbe.<br/>And it&apos;s working perfectly. Timidity realtime synthesizer is retuned<br/>realtime by Scala midi relay by MTS tuning.</p><p>I didn&apos;t check the tuning tables though. I feel much more comfortable<br/>&gt; with +12 pitches per octave over 16 channels simultaneously.<br/>&gt;<br/>The MTS will give you this.<br/>And with as much polyphony on each channel as Timidity can handle.</p><p>Good luck,</p><p>Marcel</p></div><h3><a id=85141 href="#85141">ðŸ”—</a>Marcel de Velde &#x3C;m.develde@...&#x3E;</h3><span>10/27/2009 1:26:14 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Sorry cheered to early.<br/>I had somehow convinced myself I was listening to MTS realtime tuning of<br/>Timidity but checking revealed that Scala in not using MTS but sitll using<br/>pitch bends for the realtime tuning.<br/>Selecting synthesizer model had no effect on the real time midi relay<br/>settings.<br/>Will figure out how to make it work though.<br/>I think it will be either through the send tuning interface in Scala or by<br/>saving the tuning to a textfile and leading this in Timidity.<br/>Again sorry if you allready went through the trouble of trying it out.</p><p>Marcel</p><p>I have a hunch that if you tune by Midi Tuning Standard you will get a<br/>&gt; better pitch resoluton.<br/>&gt; I just tried out Graham&apos;s tip that Scala&apos;s realtime midi relay output<br/>&gt; should also work for MTS and indeed it does! :)<br/>&gt; Thank you Graham!<br/>&gt;<br/>&gt; The way I have it set up is as follows:<br/>&gt; I did not have to set any Z flag in Timidity, apparently it was correctly<br/>&gt; set allready by default.<br/>&gt; I selected in Scala under preferences - midi: synthesizer tuning options<br/>&gt; (send): model: 1: MIDI Tuning Standard single notes dump, 3 byte.<br/>&gt; Then I installed Loopbe1 (an internal midi relay cable)<br/>&gt; The under midi relay in Scala I selected as output loopbe, and in<br/>&gt; Timidity++ realtime synthesizer I selected as input Loopbe.<br/>&gt; And it&apos;s working perfectly. Timidity realtime synthesizer is retuned<br/>&gt; realtime by Scala midi relay by MTS tuning.<br/>&gt;</p></div><h3><a id=85142 href="#85142">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/27/2009 3:55:51 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>O Marcel,</p><p>On Oct 27, 2009, at 9:39 PM, Marcel de Velde wrote:</p><p>&gt;<br/>&gt;<br/>&gt;<br/>&gt; SNIP<br/>&gt;<br/>&gt; I made new<br/>&gt; measurements and confirm that, indeed, the smallest increment in<br/>&gt; Timidity must be 0.39 cents (256th of an equal semitone).<br/>&gt;<br/>&gt; Do you know how the smallest increment can be set to 1024th of an<br/>&gt; equal semitone in Timidity++ for Windows? That would equate to nearly<br/>&gt; 0.1 cent increments. It would be good to have such a resolution handy,<br/>&gt; especially considering experimenting with proportional beating chords.<br/>&gt; I would appreciate it very much if someone can assist me in that<br/>&gt; direction.<br/>&gt;<br/>&gt; I have a hunch that if you tune by Midi Tuning Standard you will get &gt; a better pitch resoluton.<br/>&gt; I just tried out Graham&apos;s tip that Scala&apos;s realtime midi relay &gt; output should also work for MTS and indeed it does! :)<br/>&gt; Thank you Graham!<br/>&gt;<br/>&gt; The way I have it set up is as follows:<br/>&gt; I did not have to set any Z flag in Timidity, apparently it was &gt; correctly set allready by default.<br/>&gt; I selected in Scala under preferences - midi: synthesizer tuning &gt; options (send): model: 1: MIDI Tuning Standard single notes dump, 3 &gt; byte.<br/>&gt; Then I installed Loopbe1 (an internal midi relay cable)<br/>&gt; The under midi relay in Scala I selected as output loopbe, and in &gt; Timidity++ realtime synthesizer I selected as input Loopbe.<br/>&gt; And it&apos;s working perfectly. Timidity realtime synthesizer is retuned &gt; realtime by Scala midi relay by MTS tuning.<br/>&gt;</p><p>I am using MidiYoke, which does the same job linking SCALA to TWSynth. But I am not relaying MIDI yet, I&apos;m experimenting with the Chromatic Keyboard in SCALA as always, trying out chords and intervals. The tuning resolution is by steps of 256th of an equal semitone. Peterson AutoStrobe 590 confirms that TWSynth is operating by 0.39 cent increments when pitchbending. Hence, MTS is not working to its full potential in TWSynth.</p><p>All I ask is for someone to show me how the pitch bend resolution could be increased in Timidity, hopefully with some line added to the timidity.cfg file.</p><p>&gt; I didn&apos;t check the tuning tables though. I feel much more comfortable<br/>&gt; with +12 pitches per octave over 16 channels simultaneously.<br/>&gt;<br/>&gt; The MTS will give you this.<br/>&gt; And with as much polyphony on each channel as Timidity can handle.<br/>&gt;</p><p>The polyphony is currently set to 256 simultaneous voices in TWSynth. It can be increased on demand as far as computer memory allows.</p><p>&gt; Good luck,<br/>&gt;<br/>&gt; Marcel<br/>&gt;<br/>&gt;<br/>&gt;</p><p>Oz.</p></div><h3><a id=85143 href="#85143">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/27/2009 4:37:38 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>You may like to check this info:</p><p><a href="http://www.nabble.com/note-changes-and-pitch-bending-td19546994.html">http://www.nabble.com/note-changes-and-pitch-bending-td19546994.html</a></p><p>Oz.</p><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p><p>On Oct 27, 2009, at 10:26 PM, Marcel de Velde wrote:</p><p>&gt;<br/>&gt;<br/>&gt; Sorry cheered to early.<br/>&gt; I had somehow convinced myself I was listening to MTS realtime<br/>&gt; tuning of Timidity but checking revealed that Scala in not using MTS<br/>&gt; but sitll using pitch bends for the realtime tuning.<br/>&gt; Selecting synthesizer model had no effect on the real time midi<br/>&gt; relay settings.<br/>&gt; Will figure out how to make it work though.<br/>&gt; I think it will be either through the send tuning interface in Scala<br/>&gt; or by saving the tuning to a textfile and leading this in Timidity.<br/>&gt; Again sorry if you allready went through the trouble of trying it out.<br/>&gt;<br/>&gt; Marcel<br/>&gt;<br/>&gt; I have a hunch that if you tune by Midi Tuning Standard you will get<br/>&gt; a better pitch resoluton.<br/>&gt; I just tried out Graham&apos;s tip that Scala&apos;s realtime midi relay<br/>&gt; output should also work for MTS and indeed it does! :)<br/>&gt; Thank you Graham!<br/>&gt;<br/>&gt; The way I have it set up is as follows:<br/>&gt; I did not have to set any Z flag in Timidity, apparently it was<br/>&gt; correctly set allready by default.<br/>&gt; I selected in Scala under preferences - midi: synthesizer tuning<br/>&gt; options (send): model: 1: MIDI Tuning Standard single notes dump, 3<br/>&gt; byte.<br/>&gt; Then I installed Loopbe1 (an internal midi relay cable)<br/>&gt; The under midi relay in Scala I selected as output loopbe, and in<br/>&gt; Timidity++ realtime synthesizer I selected as input Loopbe.<br/>&gt; And it&apos;s working perfectly. Timidity realtime synthesizer is retuned<br/>&gt; realtime by Scala midi relay by MTS tuning.<br/>&gt;<br/>&gt;<br/>&gt;<br/>&gt;</p></div><h3><a id=85144 href="#85144">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/27/2009 5:43:45 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:</p><p>&gt; Do you know how the smallest increment can be set to 1024th of an  &gt; equal semitone in Timidity++ for Windows? That would equate to nearly  &gt; 0.1 cent increments. It would be good to have such a resolution handy,  &gt; especially considering experimenting with proportional beating chords.  &gt; I would appreciate it very much if someone can assist me in that  &gt; direction.</p><p>You&apos;d have to compile a patched version.  The changes don&apos;t look that difficult but you have all the problems of compiling something on Windows.  Or convincing the developers to lift the restriction.</p><p>&gt; I didn&apos;t check the tuning tables though. I feel much more comfortable  &gt; with +12 pitches per octave over 16 channels simultaneously.</p><p>I expect it&apos;s the same anyway.</p><p>The trouble is, the primary use case for pitch bends is where you have a lot of them arriving close together, and each one has to be cheap to process.  In that case, each one being accurate to less than a cent isn&apos;t important at all so you can use a lookup table if it saves processing power. With the MIDI Tuning Standard there&apos;s a better argument that you want the accuracy first and the processor overhead isn&apos;t important because you won&apos;t have more than one retuning per note.</p><p>Personally, I&apos;m not convinced that the lookup tables are saving processor time.  But given it only matters if the samples start out tuned correctly I don&apos;t think it&apos;s worth arguing about.  (But I notice that Timdity has a load of pitch detection code -- I don&apos;t know what it&apos;s for.)</p><p>If you really want high precision microtonality, try to get Csound working with an algorithm that doesn&apos;t depend on samples.  Or look at ZynAddSubFX -- I don&apos;t know how precise that is.</p><p>                   Graham</p></div><h3><a id=85146 href="#85146">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/27/2009 6:39:24 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Dear Graham,</p><p>On Oct 28, 2009, at 2:43 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;<br/>&gt;&gt; Do you know how the smallest increment can be set to 1024th of an<br/>&gt;&gt; equal semitone in Timidity++ for Windows? That would equate to nearly<br/>&gt;&gt; 0.1 cent increments. It would be good to have such a resolution &gt;&gt; handy,<br/>&gt;&gt; especially considering experimenting with proportional beating &gt;&gt; chords.<br/>&gt;&gt; I would appreciate it very much if someone can assist me in that<br/>&gt;&gt; direction.<br/>&gt;<br/>&gt; You&apos;d have to compile a patched version.  The changes don&apos;t<br/>&gt; look that difficult but you have all the problems of<br/>&gt; compiling something on Windows.  Or convincing the<br/>&gt; developers to lift the restriction.</p><p>I did a successful compilation of libsndfile just yesterday using MinGW + MSys. If I knew what to change and where exactly, I assume I could try to make a personal Timidity compilation for Windows featuring 0.1 cent pitchbend precision. Does anyone wish to suggest a better increment for Timidity while we are at it?</p><p>Also, I need to know what packages are needed prior to the compilation process. Can you help fill in the blanks?</p><p>&gt;<br/>&gt;&gt; I didn&apos;t check the tuning tables though. I feel much more comfortable<br/>&gt;&gt; with +12 pitches per octave over 16 channels simultaneously.<br/>&gt;<br/>&gt; I expect it&apos;s the same anyway.<br/>&gt;<br/>&gt; The trouble is, the primary use case for pitch bends is<br/>&gt; where you have a lot of them arriving close together, and<br/>&gt; each one has to be cheap to process.  In that case, each one<br/>&gt; being accurate to less than a cent isn&apos;t important at all so<br/>&gt; you can use a lookup table if it saves processing power.</p><p>I don&apos;t necessarily use pitchbend control to bend a pitch (or pitches) continuously in realtime. That would indeed require too much processing power if the increments were 16,384 steps per interval. Let us optimize then. I was thinking of settling for 0.1 cents to realize near-perfect proportional beating chords. What do you think is the optimum increment here?</p><p>&gt; With the MIDI Tuning Standard there&apos;s a better argument that<br/>&gt; you want the accuracy first and the processor overhead isn&apos;t<br/>&gt; important because you won&apos;t have more than one retuning per<br/>&gt; note.<br/>&gt;<br/>&gt; Personally, I&apos;m not convinced that the lookup tables are<br/>&gt; saving processor time.  But given it only matters if the<br/>&gt; samples start out tuned correctly I don&apos;t think it&apos;s worth<br/>&gt; arguing about.  (But I notice that Timdity has a load of<br/>&gt; pitch detection code -- I don&apos;t know what it&apos;s for.)<br/>&gt;<br/>&gt; If you really want high precision microtonality, try to get<br/>&gt; Csound working with an algorithm that doesn&apos;t depend on<br/>&gt; samples.</p><p>I never got fond of Csound. Too much programming language is required for that. I work better with interfaces, knobs and buttons.</p><p>&gt; Or look at ZynAddSubFX -- I don&apos;t know how precise<br/>&gt; that is.</p><p>Glad you spoke of it. I did indeed check ZynAddSubFX a day ago. It responds to 0.1 cent increments in the very least. I can&apos;t measure smaller increments, my AutoStrobe&apos;s accuracy of pitch detection is 0.1 cent. I am guessing it implements MTS wholly... 14-bits that is.</p><p>But the sounds are too wobbly (Only the Clarinet sound is a dependable patch for measurements), and I am not a person who is into electronic instrument modelling. So, back to TWSynth.</p><p>&gt;<br/>&gt;<br/>&gt;                    Graham<br/>&gt;</p><p>Oz.</p></div><h3><a id=85147 href="#85147">ðŸ”—</a>Daniel Forro &#x3C;dan.for@...&#x3E;</h3><span>10/27/2009 6:49:59 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On 28 Oct 2009, at 7:55 AM, Ozan Yarman wrote:<br/>&gt;<br/>&gt; I am using MidiYoke, which does the same job linking SCALA to &gt; TWSynth. But I am not relaying MIDI yet, I&apos;m experimenting with the &gt; Chromatic Keyboard in SCALA as always, trying out chords and &gt; intervals. The tuning resolution is by steps of 256th of an equal &gt; semitone. Peterson AutoStrobe 590 confirms that TWSynth is &gt; operating by 0.39 cent increments when pitchbending. Hence, MTS is &gt; not working to its full potential in TWSynth.<br/>&gt;<br/>&gt; All I ask is for someone to show me how the pitch bend resolution &gt; could be increased in Timidity, hopefully with some line added to &gt; the timidity.cfg file.</p><p>I would say PB resolution depends on synth and has its limits, not every instrument is capable of full 14-bit resolution. It&apos;s not necessarily problem of MIDI itself or software working with PB. Maybe PB output use full resolution, but synth just can&apos;t follow it...</p><p> Daniel Forro</p></div><h3><a id=85150 href="#85150">ðŸ”—</a>cameron &#x3C;misterbobro@...&#x3E;</h3><span>10/27/2009 11:18:07 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan, ZynAddSubFx and a good number of software synths which use the approach loading .scl files directly into the synth. The synth then recalibrates itself to send the proper new cycles per second to the midi note numbers.</p><p>In ZynAddSubFx, the tuning can also be reassigned to keys with a Scala .kbd file (so you can have mute keys, duplicate pitches, upside-down scales, etc).</p><p>The accuracy is something like .00001 Hz (cycles per second), can&apos;t remember. The .scl files can contain ratios, which the synths calculate to its internal resolution, 32-bit or whatever.</p><p>Anyway it really is accurate enough! Loading Scala files directly<br/>is clearly the best approach, the next best is .tun files, which are also extremely acccurate.</p><p>This program:</p><p><a href="http://12equalboresme.com/">http://12equalboresme.com/</a></p><p>converts Scala files to Kontakt scripts. It is also extremely accurate- .00001 Cent IIRC. This is nominal if you are using acoustic samples, as they wobble a lot more than that, but if you make your own samples for a dead-still synthetic instrument, you can verify that it is indeed an extremely accurate system. Kontakt + script is the best solution for acoustic instrument samples.</p><p>- Cameron Bobro</p></div><h3><a id=85151 href="#85151">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/27/2009 11:39:52 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:</p><p>&gt; I did a successful compilation of libsndfile just yesterday using  &gt; MinGW + MSys. If I knew what to change and where exactly, I assume I  &gt; could try to make a personal Timidity compilation for Windows  &gt; featuring 0.1 cent pitchbend precision. Does anyone wish to suggest a  &gt; better increment for Timidity while we are at it?</p><p>I don&apos;t see why Timidity needs to define its own lookup tables.  The obvious reason is to avoid the C pow() function.  But modern processors calculate standard functions pretty efficiently, involving lookup tables, so I expect one pitch bend per note to carry a negligible overhead.</p><p>At least try no restriction and benchmark it.  Note that you may be able to avoid initializing the lookup table, which will save 256 calculations on startup!  If there is a siginificant saving with the lookup table, note that an alternative approach is to use linear interpolation to get the extra precision.  I think this would give very accurate results with the existing lookup tables.</p><p>The procedure is:</p><p>Look at the init_bend_fine in timidity/tables.c</p><p>Replace the 8 lookups from bend_fine in timidity/playmidi.c with the relevant expression, using full precision.</p><p>Grep for other uses of bend_fine if you want to purge the lookup table completely.</p><p>&gt; Also, I need to know what packages are needed prior to the compilation  &gt; process. Can you help fill in the blanks?</p><p>No, sorry.  All I did is download the code from CVS.  And what I&apos;m looking at doesn&apos;t look like the Windows synth anyway.</p><p>&gt; Glad you spoke of it. I did indeed check ZynAddSubFX a day ago. It  &gt; responds to 0.1 cent increments in the very least. I can&apos;t measure  &gt; smaller increments, my AutoStrobe&apos;s accuracy of pitch detection is 0.1  &gt; cent. I am guessing it implements MTS wholly... 14-bits that is.<br/>&gt; &gt; But the sounds are too wobbly (Only the Clarinet sound is a dependable  &gt; patch for measurements), and I am not a person who is into electronic  &gt; instrument modelling. So, back to TWSynth.</p><p>I&apos;ve used ZASFX a bit.  It doesn&apos;t have the greatest interface, but it looks easier to tweak than Csound.  You should be able to remove that wobbliness.</p><p>                Graham</p></div><h3><a id=85155 href="#85155">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/28/2009 6:09:32 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>O Cameron,</p><p>On Oct 28, 2009, at 8:18 AM, cameron wrote:</p><p>&gt; Ozan, ZynAddSubFx and a good number of software synths which use the &gt; approach loading .scl files directly into the synth. The synth then &gt; recalibrates itself to send the proper new cycles per second to the &gt; midi note numbers.<br/>&gt;</p><p>I have and use ZASFx, it&apos;s a great tool. But as I said earlier, most samples sound wobbly and instrument modelling is beyond me.</p><p>&gt; In ZynAddSubFx, the tuning can also be reassigned to keys with a &gt; Scala .kbd file (so you can have mute keys, duplicate pitches, &gt; upside-down scales, etc).<br/>&gt;</p><p>I know this.</p><p>&gt; The accuracy is something like .00001 Hz (cycles per second), can&apos;t &gt; remember. The .scl files can contain ratios, which the synths &gt; calculate to its internal resolution, 32-bit or whatever.<br/>&gt;</p><p>At 440 Hz, an increase by that cps will equate to 0.00004 cents difference. It is fantastic, but overkill at the same time.</p><p>&gt; Anyway it really is accurate enough!</p><p>Surely!</p><p>&gt; Loading Scala files directly<br/>&gt; is clearly the best approach, the next best is .tun files, which are &gt; also extremely acccurate.<br/>&gt;<br/>&gt; This program:<br/>&gt;<br/>&gt; <a href="http://12equalboresme.com/">http://12equalboresme.com/</a><br/>&gt;<br/>&gt; converts Scala files to Kontakt scripts. It is also extremely &gt; accurate- .00001 Cent IIRC. This is nominal if you are using &gt; acoustic samples, as they wobble a lot more than that, but if you &gt; make your own samples for a dead-still synthetic instrument, you can &gt; verify that it is indeed an extremely accurate system. Kontakt + &gt; script is the best solution for acoustic instrument samples.<br/>&gt;</p><p>There is no way to verify any increment smaller than 0.1 cents with my hardware. 0.1 cents is plenty as far as I am concerned.</p><p>Good to know that there is a way to convert Scala files to Kontakt scripts. Thanks for pointing that out.</p><p>&gt; - Cameron Bobro<br/>&gt;<br/>&gt;<br/>&gt;</p><p>Oz.</p></div><h3><a id=85156 href="#85156">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/28/2009 6:22:19 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Dear Graham,</p><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p><p>On Oct 28, 2009, at 8:39 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;<br/>&gt;&gt; I did a successful compilation of libsndfile just yesterday using<br/>&gt;&gt; MinGW + MSys. If I knew what to change and where exactly, I assume I<br/>&gt;&gt; could try to make a personal Timidity compilation for Windows<br/>&gt;&gt; featuring 0.1 cent pitchbend precision. Does anyone wish to suggest a<br/>&gt;&gt; better increment for Timidity while we are at it?<br/>&gt;<br/>&gt; I don&apos;t see why Timidity needs to define its own lookup<br/>&gt; tables.  The obvious reason is to avoid the C pow()<br/>&gt; function.  But modern processors calculate standard<br/>&gt; functions pretty efficiently, involving lookup tables, so I<br/>&gt; expect one pitch bend per note to carry a negligible overhead.<br/>&gt;</p><p>I don&apos;t understand any of what you said. Please elaborate. What is a<br/>lookup table?</p><p>&gt; At least try no restriction and benchmark it.</p><p>How do I benchmark timidity? Don&apos;t I need special benchmarking tools for the job?</p><p>&gt; Note that you<br/>&gt; may be able to avoid initializing the lookup table, which<br/>&gt; will save 256 calculations on startup!  If there is a<br/>&gt; siginificant saving with the lookup table, note that an<br/>&gt; alternative approach is to use linear interpolation to get<br/>&gt; the extra precision.  I think this would give very accurate<br/>&gt; results with the existing lookup tables.<br/>&gt;</p><p>Please remind me, what was linear interpolation?</p><p>&gt; The procedure is:<br/>&gt;<br/>&gt; Look at the init_bend_fine in timidity/tables.c<br/>&gt;</p><p>Don&apos;t I need a special editor to view this file?</p><p>&gt; Replace the 8 lookups from bend_fine in timidity/playmidi.c<br/>&gt; with the relevant expression, using full precision.<br/>&gt;</p><p>Is the relevant expression &quot;full precision&quot;, or some kind of number?</p><p>&gt; Grep for other uses of bend_fine if you want to purge the<br/>&gt; lookup table completely.</p><p>Again, please elaborate.</p><p>&gt;<br/>&gt;&gt; Also, I need to know what packages are needed prior to the<br/>&gt;&gt; compilation<br/>&gt;&gt; process. Can you help fill in the blanks?<br/>&gt;<br/>&gt; No, sorry.  All I did is download the code from CVS.  And<br/>&gt; what I&apos;m looking at doesn&apos;t look like the Windows synth anyway.</p><p>I was assuming that the macbuild, linuxbuild, and winbuild are all in<br/>the same bundle?</p><p>&gt;<br/>&gt;&gt; Glad you spoke of it. I did indeed check ZynAddSubFX a day ago. It<br/>&gt;&gt; responds to 0.1 cent increments in the very least. I can&apos;t measure<br/>&gt;&gt; smaller increments, my AutoStrobe&apos;s accuracy of pitch detection is<br/>&gt;&gt; 0.1<br/>&gt;&gt; cent. I am guessing it implements MTS wholly... 14-bits that is.<br/>&gt;&gt;<br/>&gt;&gt; But the sounds are too wobbly (Only the Clarinet sound is a<br/>&gt;&gt; dependable<br/>&gt;&gt; patch for measurements), and I am not a person who is into electronic<br/>&gt;&gt; instrument modelling. So, back to TWSynth.<br/>&gt;<br/>&gt; I&apos;ve used ZASFX a bit.  It doesn&apos;t have the greatest<br/>&gt; interface, but it looks easier to tweak than Csound.  You<br/>&gt; should be able to remove that wobbliness.<br/>&gt;</p><p>I&apos;d rather not mess up with the hundreds of controls that I don&apos;t know<br/>does what. TWSynth is good enough if only we could fix the PB precision.</p><p>&gt;<br/>&gt;                 Graham<br/>&gt;</p><p>Oz.</p></div><h3><a id=85157 href="#85157">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/28/2009 8:18:18 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:</p><p>&gt;&gt; I don&apos;t see why Timidity needs to define its own lookup<br/>&gt;&gt; tables.  The obvious reason is to avoid the C pow()<br/>&gt;&gt; function.  But modern processors calculate standard<br/>&gt;&gt; functions pretty efficiently, involving lookup tables, so I<br/>&gt;&gt; expect one pitch bend per note to carry a negligible overhead.<br/>&gt; &gt; I don&apos;t understand any of what you said. Please elaborate. What is a  &gt; lookup table?</p><p>The lookup table is what restricts Timidity to 256 divisions of the semitone.  It calculates all 256 different fine tunings and remembers them to save time calculating the exact bend each time you want it.</p><p>&gt;&gt; At least try no restriction and benchmark it.<br/>&gt; &gt; How do I benchmark timidity? Don&apos;t I need special benchmarking tools  &gt; for the job?</p><p>See how long it takes to process a file, or how much the sound breaks up in real time or how much of the processor it uses.</p><p>&gt;&gt; Note that you<br/>&gt;&gt; may be able to avoid initializing the lookup table, which<br/>&gt;&gt; will save 256 calculations on startup!  If there is a<br/>&gt;&gt; siginificant saving with the lookup table, note that an<br/>&gt;&gt; alternative approach is to use linear interpolation to get<br/>&gt;&gt; the extra precision.  I think this would give very accurate<br/>&gt;&gt; results with the existing lookup tables.</p><p>&gt; Please remind me, what was linear interpolation?</p><p>Drawing a straight line between two data points so that you can guess a value in the middle.</p><p>&gt;&gt; The procedure is:<br/>&gt;&gt;<br/>&gt;&gt; Look at the init_bend_fine in timidity/tables.c<br/>&gt; &gt; Don&apos;t I need a special editor to view this file?</p><p>No.</p><p>&gt;&gt; Replace the 8 lookups from bend_fine in timidity/playmidi.c<br/>&gt;&gt; with the relevant expression, using full precision.<br/>&gt; &gt; Is the relevant expression &quot;full precision&quot;, or some kind of number?</p><p>It&apos;s a bit of C code you copy from the other file.</p><p>&gt;&gt; Grep for other uses of bend_fine if you want to purge the<br/>&gt;&gt; lookup table completely.<br/>&gt; &gt; Again, please elaborate.</p><p>Every time the lookup table is accessed, you may be losing precision.  So search for each time it&apos;s mentioned in the code.</p><p>&gt;&gt;&gt; Also, I need to know what packages are needed prior to the  &gt;&gt;&gt; compilation<br/>&gt;&gt;&gt; process. Can you help fill in the blanks?<br/>&gt;&gt; No, sorry.  All I did is download the code from CVS.  And<br/>&gt;&gt; what I&apos;m looking at doesn&apos;t look like the Windows synth anyway.<br/>&gt; &gt; I was assuming that the macbuild, linuxbuild, and winbuild are all in  &gt; the same bundle?</p><p>I couldn&apos;t get a bundle.  There should be some but I got an error message in Japanese.  The CVS is accessible in SourceForge but the instructions are incomplete.  You have to specify a module name but there isn&apos;t a list of modules.   I guessed &quot;timidity&quot; and I&apos;m missing some folders that I can see from the web browser.</p><p>&gt; I&apos;d rather not mess up with the hundreds of controls that I don&apos;t know  &gt; does what. TWSynth is good enough if only we could fix the PB precision.</p><p>But you do want to mess with C code?  &quot;Wobbliness&quot; is probably due to LFOs.  Try turning down any LFO depth you find.</p><p>                 Graham</p></div><h3><a id=85177 href="#85177">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/30/2009 6:43:52 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Dear Graham,</p><p>So, if I eliminate the pitchbend lookup tables in Timidity entirely,<br/>do I arrive at MTS with 16384 increments per interval (semitone,wholetone, etc...)?</p><p>I imagine trying to benchmark the different compilations of Timidity<br/>on my powerful Macbook Pro will produce negligible results.</p><p>Wait, did you say that the audio might crackle again after this? I<br/>hope it&apos;s not so.</p><p>You have to be real specific about how to change the 8 lookup tables in:</p><p>&gt; init_bend_fine in timidity/tables.c</p><p>Seeing as I am a complete dummy in C programming language. What and<br/>from where do I copy the relevant C code to replace the lookup tables?<br/>And if I want to eliminate the lookup tables entirely, do I delete all<br/>instances of bend_fine?</p><p>Please bear patiently with me on this one. A step-by-step list of<br/>instructions will be much appreciated.</p><p>Or else, maybe you can patch of the tables.c file to eliminate the<br/>pitchbend lookup tables entirely and send it to me via e-mail?</p><p>One more thing, I couldn&apos;t find a Windows executable of the latest<br/>version of ZASFX, which is v. 2.4. Do you have a compiled version 2.4?<br/>Or do I need to compile it myself too?</p><p>Cordially,<br/>Oz.</p><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p><p>On Oct 29, 2009, at 5:18 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;<br/>&gt;&gt;&gt; I don&apos;t see why Timidity needs to define its own lookup<br/>&gt;&gt;&gt; tables.  The obvious reason is to avoid the C pow()<br/>&gt;&gt;&gt; function.  But modern processors calculate standard<br/>&gt;&gt;&gt; functions pretty efficiently, involving lookup tables, so I<br/>&gt;&gt;&gt; expect one pitch bend per note to carry a negligible overhead.<br/>&gt;&gt;<br/>&gt;&gt; I don&apos;t understand any of what you said. Please elaborate. What is a<br/>&gt;&gt; lookup table?<br/>&gt;<br/>&gt; The lookup table is what restricts Timidity to 256 divisions<br/>&gt; of the semitone.  It calculates all 256 different fine<br/>&gt; tunings and remembers them to save time calculating the<br/>&gt; exact bend each time you want it.<br/>&gt;<br/>&gt;&gt;&gt; At least try no restriction and benchmark it.<br/>&gt;&gt;<br/>&gt;&gt; How do I benchmark timidity? Don&apos;t I need special benchmarking tools<br/>&gt;&gt; for the job?<br/>&gt;<br/>&gt; See how long it takes to process a file, or how much the<br/>&gt; sound breaks up in real time or how much of the processor it<br/>&gt; uses.<br/>&gt;<br/>&gt;&gt;&gt; Note that you<br/>&gt;&gt;&gt; may be able to avoid initializing the lookup table, which<br/>&gt;&gt;&gt; will save 256 calculations on startup!  If there is a<br/>&gt;&gt;&gt; siginificant saving with the lookup table, note that an<br/>&gt;&gt;&gt; alternative approach is to use linear interpolation to get<br/>&gt;&gt;&gt; the extra precision.  I think this would give very accurate<br/>&gt;&gt;&gt; results with the existing lookup tables.<br/>&gt;<br/>&gt;&gt; Please remind me, what was linear interpolation?<br/>&gt;<br/>&gt; Drawing a straight line between two data points so that you<br/>&gt; can guess a value in the middle.<br/>&gt;<br/>&gt;&gt;&gt; The procedure is:<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; Look at the init_bend_fine in timidity/tables.c<br/>&gt;&gt;<br/>&gt;&gt; Don&apos;t I need a special editor to view this file?<br/>&gt;<br/>&gt; No.<br/>&gt;<br/>&gt;&gt;&gt; Replace the 8 lookups from bend_fine in timidity/playmidi.c<br/>&gt;&gt;&gt; with the relevant expression, using full precision.<br/>&gt;&gt;<br/>&gt;&gt; Is the relevant expression &quot;full precision&quot;, or some kind of number?<br/>&gt;<br/>&gt; It&apos;s a bit of C code you copy from the other file.<br/>&gt;<br/>&gt;&gt;&gt; Grep for other uses of bend_fine if you want to purge the<br/>&gt;&gt;&gt; lookup table completely.<br/>&gt;&gt;<br/>&gt;&gt; Again, please elaborate.<br/>&gt;<br/>&gt; Every time the lookup table is accessed, you may be losing<br/>&gt; precision.  So search for each time it&apos;s mentioned in the code.<br/>&gt;<br/>&gt;&gt;&gt;&gt; Also, I need to know what packages are needed prior to the<br/>&gt;&gt;&gt;&gt; compilation<br/>&gt;&gt;&gt;&gt; process. Can you help fill in the blanks?<br/>&gt;&gt;&gt; No, sorry.  All I did is download the code from CVS.  And<br/>&gt;&gt;&gt; what I&apos;m looking at doesn&apos;t look like the Windows synth anyway.<br/>&gt;&gt;<br/>&gt;&gt; I was assuming that the macbuild, linuxbuild, and winbuild are all in<br/>&gt;&gt; the same bundle?<br/>&gt;<br/>&gt; I couldn&apos;t get a bundle.  There should be some but I got an<br/>&gt; error message in Japanese.  The CVS is accessible in<br/>&gt; SourceForge but the instructions are incomplete.  You have<br/>&gt; to specify a module name but there isn&apos;t a list of modules.<br/>&gt;  I guessed &quot;timidity&quot; and I&apos;m missing some folders that I<br/>&gt; can see from the web browser.<br/>&gt;<br/>&gt;&gt; I&apos;d rather not mess up with the hundreds of controls that I don&apos;t<br/>&gt;&gt; know<br/>&gt;&gt; does what. TWSynth is good enough if only we could fix the PB<br/>&gt;&gt; precision.<br/>&gt;<br/>&gt; But you do want to mess with C code?  &quot;Wobbliness&quot; is<br/>&gt; probably due to LFOs.  Try turning down any LFO depth you find.<br/>&gt;<br/>&gt;<br/>&gt;                  Graham<br/>&gt;<br/>&gt;<br/>&gt; ------------------------------------<br/>&gt;<br/>&gt; You can configure your subscription by sending an empty email to one<br/>&gt; of these addresses (from the address at which you receive the list):<br/>&gt;  <a href="mailto:tuning-subscribe@yahoogroups.com">tuning-subscribe@yahoogroups.com</a> - join the tuning group.<br/>&gt;  <a href="mailto:tuning-unsubscribe@yahoogroups.com">tuning-unsubscribe@yahoogroups.com</a> - leave the group.<br/>&gt;  <a href="mailto:tuning-nomail@yahoogroups.com">tuning-nomail@yahoogroups.com</a> - turn off mail from the group.<br/>&gt;  <a href="mailto:tuning-digest@yahoogroups.com">tuning-digest@yahoogroups.com</a> - set group to send daily digests.<br/>&gt;  <a href="mailto:tuning-normal@yahoogroups.com">tuning-normal@yahoogroups.com</a> - set group to send individual emails.<br/>&gt;  <a href="mailto:tuning-help@yahoogroups.com">tuning-help@yahoogroups.com</a> - receive general help information.<br/>&gt; Yahoo! Groups Links<br/>&gt;<br/>&gt;<br/>&gt;</p></div><h3><a id=85178 href="#85178">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>10/30/2009 6:47:32 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Graham, can you elaborate how using linear interpolation with the lookup tables will increase the pitch bend precision? Please be specific and remember that I am a C programming dummy.</p><p>Oz.</p><p>&gt;&gt;<br/>&gt;&gt; SNIP<br/>&gt;<br/>&gt; I don&apos;t see why Timidity needs to define its own lookup<br/>&gt; tables.  The obvious reason is to avoid the C pow()<br/>&gt; function.  But modern processors calculate standard<br/>&gt; functions pretty efficiently, involving lookup tables, so I<br/>&gt; expect one pitch bend per note to carry a negligible overhead.<br/>&gt;<br/>&gt; At least try no restriction and benchmark it.  Note that you<br/>&gt; may be able to avoid initializing the lookup table, which<br/>&gt; will save 256 calculations on startup!  If there is a<br/>&gt; siginificant saving with the lookup table, note that an<br/>&gt; alternative approach is to use linear interpolation to get<br/>&gt; the extra precision.  I think this would give very accurate<br/>&gt; results with the existing lookup tables.</p></div><h3><a id=85182 href="#85182">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/30/2009 10:38:50 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:</p><p>&gt; So, if I eliminate the pitchbend lookup tables in Timidity entirely,  &gt; do I arrive at MTS with 16384 increments per interval (semitone,  &gt; wholetone, etc...)?</p><p>Yes.  But it&apos;s only as good as the sample set you&apos;re using.   If the samples aren&apos;t tuned that accurately, the results won&apos;t be anyway.  That&apos;s why you should go for a purely algorithmic approach for high-precision tuning.</p><p>&gt; I imagine trying to benchmark the different compilations of Timidity  &gt; on my powerful Macbook Pro will produce negligible results.</p><p>Probably, yes.  There may be a good reason for the optimization but without seeing benchmarks I&apos;ll assume not.</p><p>&gt; Wait, did you say that the audio might crackle again after this? I  &gt; hope it&apos;s not so.</p><p>I doubt it.</p><p>&gt; Or else, maybe you can patch of the tables.c file to eliminate the  &gt; pitchbend lookup tables entirely and send it to me via e-mail?</p><p>If you know what you want to change, I can send you the updated file.  It&apos;d probably easier to switch to something like :-</p><p>&gt; One more thing, I couldn&apos;t find a Windows executable of the latest  &gt; version of ZASFX, which is v. 2.4. Do you have a compiled version 2.4?  &gt; Or do I need to compile it myself too?</p><p>I have the Linux version from the Ubuntu repository.  It doesn&apos;t have a version number, may be a custom build.  I&apos;ve never downloaded or used the Windows version.</p><p>                  Graham</p></div><h3><a id=85183 href="#85183">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>10/30/2009 11:28:45 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:<br/>&gt; Graham, can you elaborate how using linear interpolation with the lookup &gt; tables will increase the pitch bend precision? Please be specific and &gt; remember that I am a C programming dummy.</p><p>Sure.  I don&apos;t need C, but I&apos;ll use bc (the Unix calculator) for examples.</p><p>The usual formula for converting a pitch difference in cents to a frequency ratio is</p><p>e(x*l(2)/1200)</p><p>where e() is the exp function, l() is the corresponding logarithm function, and x is the cents value.  Because l(2)/1200 is a constant, that can be simplified to.</p><p>e(x*0.00057762265)</p><p>So it only requires one multiplication and the e() function, which is a basic piece of mathematics and sure to be in floating point processors or libraries.</p><p>The problem is that e() isn&apos;t that easy to calculate.  There are standard algorithms that come from pure mathematics, but they require a relatively large number of operations to get an accurate result.  You can also use a lookup table, which is a big list of known values kept in memory, like the log tables people used to use before desktop calculators.</p><p>The standard libraries (in either hardware or software) will use fairly sophisticated ways of calculating e() that involve lookup tables and are optimized to be very fast. For most of us, those are all we ever need.  There are, however, cases where you may find an improvement by writing your own algorithm:</p><p>1) You&apos;re running on limited hardware (like a hardware synth) and don&apos;t have enough memory free for the lookup tables.</p><p>2) You need this function in a critical piece of code where every bit of optimization makes a difference.</p><p>3) A time machine has transported you back to the 1970s where even desktop processors are more limited and the libraries aren&apos;t so good.</p><p>There are other cases where you might not see an improvement, but start fiddling around anyway:</p><p>4) You&apos;re used to running on limited hardware and got into the habit of implementing these things yourself.</p><p>5) You didn&apos;t bother to check if the piece of code your working on is critical to performance or not.</p><p>6) You learned C programming from a text book written in the 1970s.</p><p>So, for whatever reason, you think you can do better then the standard library designers at writing an exponential function.  Is that hubris?  Maybe not.  The point is, when you&apos;re dealing with pitch differences, you have a very good idea what range of values you&apos;re going to plug in and you don&apos;t need the full precision of your floating point variables.  That allows you to take short-cuts that the standard library designers couldn&apos;t take account of.  And the easiest thing to write is a lookup table.</p><p>The way Timidity does it is to split the calculation between two different lookup tables: one for equal tempered semitones and one for fine tunings smaller than a semitone.   This is convenient because we only need to consider the fine tuning.</p><p>So the problem is to return the frequency ratio corresponding to an interval between 0 and 100 cents.  The method they use is a 256 entry lookup table.  The number 256 is chosen because you can get the index into the table from the original tuning specification by bit shifting, which is very fast.  The lookup is also very fast, so we have a way of finding the frequency ratios accurately, but only in 1/256 semitone steps.</p><p>(Note: Csound users may be getting smug here, but you still have to be careful.  Csound does also implement its own functions with limited precision.  For example: &quot;powoftwo() function returns 2 ^ x and allows positive and negatives numbers as argument. The range of values admitted in powoftwo() is -5 to +5 allowing a precision more fine than one cent in a range of ten octaves.&quot;  Avoid this for microtonal work.)</p><p>Because 256 isn&apos;t a convenient number to work with in decimal, I&apos;ll instead talk about 100 divisions, or a resolution of 1 cent.  Imagine a lookup table that gives you the tuning of an interval to the nearest cent.</p><p>The correct tuning of a 5:4 major third in cents is, from bc,</p><p>l(1.25)/l(2)*1200<br/>386.31371386483481743200</p><p>reversing that calculation with limited precision gives</p><p>e(386.3137*0.00057762265)<br/>1.24999998976386909720</p><p>Very close to 1.25.  But our lookup table only gives us values to the nearest cent, so we have to choose between:</p><p>e(386*0.00057762265)<br/>1.24977351000380408917</p><p>e(387*0.00057762265)<br/>1.25049561602287101401</p><p>We know that both of these are close to what we want.  We also know that they&apos;re both wrong.  In fact, because we threw away a fractional part of 0.3137, we can guess that the true value is about 0.3137 of the way from the value for 386 cents and that for 387 cents.  That gives a new expression:</p><p>e(386*0.00057762265)*(1-0.3137) + e(387*0.00057762265)*0.3137<br/>1.25000003466198538348</p><p>You can see that this result is much closer to what we wanted -- and that&apos;s linear interpolation.  The true size of the interval that came out is</p><p>l(1.25000003466198538348)*1200/l(2)<br/>386.31376187124159514818</p><p>Not bad -- four decimal places in and nearly four out, or accuracy to better than a millicent.  All this from a lookup table in cents.  The calculation will be slower -- maybe it&apos;ll take two or three times as long -- and the lookup table is less than half the size of Timidity&apos;s.</p><p>You need to calculate the frequency every time a note is played, or the pitch wheel moves.  That won&apos;t happen very often, compared to the rate at which any digital equipment has to process its samples.  Merely doubling the time it takes shouldn&apos;t be significant.  Unfortunately, the poor pitch resolution of many synthesizers shows that they aren&apos;t bothering :-(</p><p>                      Graham</p></div><h3><a id=85187 href="#85187">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>11/1/2009 12:58:47 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p><p>On Oct 31, 2009, at 7:38 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;<br/>&gt;&gt; So, if I eliminate the pitchbend lookup tables in Timidity entirely,<br/>&gt;&gt; do I arrive at MTS with 16384 increments per interval (semitone,<br/>&gt;&gt; wholetone, etc...)?<br/>&gt;<br/>&gt; Yes.  But it&apos;s only as good as the sample set you&apos;re using.<br/>&gt;  If the samples aren&apos;t tuned that accurately, the results<br/>&gt; won&apos;t be anyway.  That&apos;s why you should go for a purely<br/>&gt; algorithmic approach for high-precision tuning.<br/>&gt;</p><p>So you mean that it is safer to keep the PB lookup tables and<br/>implement linear interpolation?</p><p>&gt;&gt; I imagine trying to benchmark the different compilations of Timidity<br/>&gt;&gt; on my powerful Macbook Pro will produce negligible results.<br/>&gt;<br/>&gt; Probably, yes.  There may be a good reason for the<br/>&gt; optimization but without seeing benchmarks I&apos;ll assume not.<br/>&gt;<br/>&gt;&gt; Wait, did you say that the audio might crackle again after this? I<br/>&gt;&gt; hope it&apos;s not so.<br/>&gt;<br/>&gt; I doubt it.<br/>&gt;<br/>&gt;&gt; Or else, maybe you can patch of the tables.c file to eliminate the<br/>&gt;&gt; pitchbend lookup tables entirely and send it to me via e-mail?<br/>&gt;<br/>&gt; If you know what you want to change, I can send you the<br/>&gt; updated file.  It&apos;d probably easier to switch to something<br/>&gt; like :-<br/>&gt;</p><p>Send me both a version of tables.c with no lookup tables and maximum<br/>precision and another version with 256 divisions of the equal semitone<br/>improved with linear interpolation. I&apos;ll test both versions if I can<br/>ever successfully compile Timidity for Windows.</p><p>&gt;&gt; One more thing, I couldn&apos;t find a Windows executable of the latest<br/>&gt;&gt; version of ZASFX, which is v. 2.4. Do you have a compiled version<br/>&gt;&gt; 2.4?<br/>&gt;&gt; Or do I need to compile it myself too?<br/>&gt;<br/>&gt; I have the Linux version from the Ubuntu repository.  It<br/>&gt; doesn&apos;t have a version number, may be a custom build.  I&apos;ve<br/>&gt; never downloaded or used the Windows version.<br/>&gt;</p><p>Ok.</p><p>&gt;<br/>&gt;                   Graham<br/>&gt;<br/>&gt;<br/>&gt;</p><p>Oz.</p></div><h3><a id=85188 href="#85188">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>11/1/2009 1:13:13 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&#x2729; &#x2729; &#x2729;<br/><a href="http://www.ozanyarman.com">www.ozanyarman.com</a></p><p>On Oct 31, 2009, at 8:28 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;&gt; Graham, can you elaborate how using linear interpolation with the<br/>&gt;&gt; lookup<br/>&gt;&gt; tables will increase the pitch bend precision? Please be specific and<br/>&gt;&gt; remember that I am a C programming dummy.<br/>&gt;<br/>&gt; Sure.  I don&apos;t need C, but I&apos;ll use bc (the Unix calculator)<br/>&gt; for examples.<br/>&gt;<br/>&gt; The usual formula for converting a pitch difference in cents<br/>&gt; to a frequency ratio is<br/>&gt;<br/>&gt; e(x*l(2)/1200)<br/>&gt;<br/>&gt; where e() is the exp function, l() is the corresponding<br/>&gt; logarithm function, and x is the cents value.  Because<br/>&gt; l(2)/1200 is a constant, that can be simplified to.<br/>&gt;<br/>&gt; e(x*0.00057762265)</p><p>Where l is ln, or neperian (natural) logarithm of course. The same<br/>results can be obtained by the formula:</p><p>2^(cents/1200)</p><p>&gt;<br/>&gt; So it only requires one multiplication and the e() function,<br/>&gt; which is a basic piece of mathematics and sure to be in<br/>&gt; floating point processors or libraries.<br/>&gt;</p><p>Agreed.</p><p>&gt; The problem is that e() isn&apos;t that easy to calculate.  There<br/>&gt; are standard algorithms that come from pure mathematics, but<br/>&gt; they require a relatively large number of operations to get<br/>&gt; an accurate result.  You can also use a lookup table, which<br/>&gt; is a big list of known values kept in memory, like the log<br/>&gt; tables people used to use before desktop calculators.<br/>&gt;</p><p>So far so good.</p><p>&gt; The standard libraries (in either hardware or software) will<br/>&gt; use fairly sophisticated ways of calculating e() that<br/>&gt; involve lookup tables and are optimized to be very fast.<br/>&gt; For most of us, those are all we ever need.  There are,<br/>&gt; however, cases where you may find an improvement by writing<br/>&gt; your own algorithm:<br/>&gt;<br/>&gt; 1) You&apos;re running on limited hardware (like a hardware<br/>&gt; synth) and don&apos;t have enough memory free for the lookup tables.<br/>&gt;<br/>&gt; 2) You need this function in a critical piece of code where<br/>&gt; every bit of optimization makes a difference.<br/>&gt;<br/>&gt; 3) A time machine has transported you back to the 1970s<br/>&gt; where even desktop processors are more limited and the<br/>&gt; libraries aren&apos;t so good.<br/>&gt;<br/>&gt; There are other cases where you might not see an<br/>&gt; improvement, but start fiddling around anyway:<br/>&gt;<br/>&gt; 4) You&apos;re used to running on limited hardware and got into<br/>&gt; the habit of implementing these things yourself.<br/>&gt;<br/>&gt; 5) You didn&apos;t bother to check if the piece of code your<br/>&gt; working on is critical to performance or not.<br/>&gt;<br/>&gt; 6) You learned C programming from a text book written in the<br/>&gt; 1970s.<br/>&gt;<br/>&gt; So, for whatever reason, you think you can do better then<br/>&gt; the standard library designers at writing an exponential<br/>&gt; function.  Is that hubris?  Maybe not.  The point is, when<br/>&gt; you&apos;re dealing with pitch differences, you have a very good<br/>&gt; idea what range of values you&apos;re going to plug in and you<br/>&gt; don&apos;t need the full precision of your floating point<br/>&gt; variables.  That allows you to take short-cuts that the<br/>&gt; standard library designers couldn&apos;t take account of.  And<br/>&gt; the easiest thing to write is a lookup table.<br/>&gt;</p><p>Ok.</p><p>&gt; The way Timidity does it is to split the calculation between<br/>&gt; two different lookup tables: one for equal tempered<br/>&gt; semitones and one for fine tunings smaller than a semitone.<br/>&gt;  This is convenient because we only need to consider the<br/>&gt; fine tuning.</p><p>Right.</p><p>&gt;<br/>&gt; So the problem is to return the frequency ratio<br/>&gt; corresponding to an interval between 0 and 100 cents.  The<br/>&gt; method they use is a 256 entry lookup table.  The number 256<br/>&gt; is chosen because you can get the index into the table from<br/>&gt; the original tuning specification by bit shifting, which is<br/>&gt; very fast.</p><p>Bit shifting? Please elaborate here. What number other than 256 is<br/>appropriate for this bit shifting? Is 1024 such a number for example?</p><p>&gt; The lookup is also very fast, so we have a way<br/>&gt; of finding the frequency ratios accurately, but only in<br/>&gt; 1/256 semitone steps.<br/>&gt;</p><p>So far so good.</p><p>&gt; (Note: Csound users may be getting smug here, but you still<br/>&gt; have to be careful.  Csound does also implement its own<br/>&gt; functions with limited precision.  For example: &quot;powoftwo()<br/>&gt; function returns 2 ^ x and allows positive and negatives<br/>&gt; numbers as argument. The range of values admitted in<br/>&gt; powoftwo() is -5 to +5 allowing a precision more fine than<br/>&gt; one cent in a range of ten octaves.&quot;  Avoid this for<br/>&gt; microtonal work.)<br/>&gt;<br/>&gt; Because 256 isn&apos;t a convenient number to work with in<br/>&gt; decimal, I&apos;ll instead talk about 100 divisions, or a<br/>&gt; resolution of 1 cent.  Imagine a lookup table that gives you<br/>&gt; the tuning of an interval to the nearest cent.<br/>&gt;<br/>&gt; The correct tuning of a 5:4 major third in cents is, from bc,<br/>&gt;<br/>&gt; l(1.25)/l(2)*1200<br/>&gt; 386.31371386483481743200</p><p>Or otherwise = log(10) 1.25 x 1200 / log(10) 2.</p><p>&gt;<br/>&gt; reversing that calculation with limited precision gives<br/>&gt;<br/>&gt; e(386.3137*0.00057762265)<br/>&gt; 1.24999998976386909720<br/>&gt;<br/>&gt; Very close to 1.25.  But our lookup table only gives us<br/>&gt; values to the nearest cent, so we have to choose between:<br/>&gt;<br/>&gt; e(386*0.00057762265)<br/>&gt; 1.24977351000380408917<br/>&gt;<br/>&gt; e(387*0.00057762265)<br/>&gt; 1.25049561602287101401</p><p>I&apos;m getting this now.</p><p>&gt;<br/>&gt; We know that both of these are close to what we want.  We<br/>&gt; also know that they&apos;re both wrong.  In fact, because we<br/>&gt; threw away a fractional part of 0.3137, we can guess that<br/>&gt; the true value is about 0.3137 of the way from the value for<br/>&gt; 386 cents and that for 387 cents.  That gives a new expression:<br/>&gt;<br/>&gt; e(386*0.00057762265)*(1-0.3137) + e(387*0.00057762265)*0.3137<br/>&gt; 1.25000003466198538348<br/>&gt;<br/>&gt; You can see that this result is much closer to what we<br/>&gt; wanted -- and that&apos;s linear interpolation.  The true size of<br/>&gt; the interval that came out is<br/>&gt;<br/>&gt; l(1.25000003466198538348)*1200/l(2)<br/>&gt; 386.31376187124159514818<br/>&gt;<br/>&gt; Not bad -- four decimal places in and nearly four out, or<br/>&gt; accuracy to better than a millicent.  All this from a lookup<br/>&gt; table in cents.</p><p>Fabulous.</p><p>&gt; The calculation will be slower -- maybe<br/>&gt; it&apos;ll take two or three times as long -- and the lookup<br/>&gt; table is less than half the size of Timidity&apos;s.<br/>&gt;</p><p>So, all that is needed is to add the arguments for linear<br/>interpolation whilst preserving the original 256 equal divisions of<br/>the semitone tuning resolution. That way the actual increments we&apos;ll<br/>be working with shall be much smaller than 0.39 cents. Right?</p><p>&gt; You need to calculate the frequency every time a note is<br/>&gt; played, or the pitch wheel moves.  That won&apos;t happen very<br/>&gt; often, compared to the rate at which any digital equipment<br/>&gt; has to process its samples.  Merely doubling the time it<br/>&gt; takes shouldn&apos;t be significant.  Unfortunately, the poor<br/>&gt; pitch resolution of many synthesizers shows that they aren&apos;t<br/>&gt; bothering :-(</p><p>Good thing that there is Timidity++ then!</p><p>&gt;<br/>&gt;<br/>&gt;                       Graham<br/>&gt;<br/>&gt;</p><p>Oz.</p></div><h3><a id=85193 href="#85193">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>11/1/2009 9:58:06 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:</p><p>&gt;&gt; e(x*l(2)/1200)</p><p>&gt; Where l is ln, or neperian (natural) logarithm of course. The same  &gt; results can be obtained by the formula:<br/>&gt; &gt; 2^(cents/1200)</p><p>That&apos;s it.  But not, as it happens, in bc, because the ^ operator doesn&apos;t work with non-integer powers.  And this may correspond to how the underlying hardware works, and so may be a difference you care about.</p><p>&gt;&gt; So the problem is to return the frequency ratio<br/>&gt;&gt; corresponding to an interval between 0 and 100 cents.  The<br/>&gt;&gt; method they use is a 256 entry lookup table.  The number 256<br/>&gt;&gt; is chosen because you can get the index into the table from<br/>&gt;&gt; the original tuning specification by bit shifting, which is<br/>&gt;&gt; very fast.<br/>&gt; &gt; &gt; Bit shifting? Please elaborate here. What number other than 256 is  &gt; appropriate for this bit shifting? Is 1024 such a number for example?</p><p>There are 14 bits of fine tuning, right?  256 requires 8 bits, so you throw away bits.  1024 is, indeed, another number that works.  It needs 10 bits and you throw away 4. A number that doesn&apos;t work is 100.  Dividing by 100 in binary is more difficult than repeatedly dividing by 2 -- but obviously easier in decimal.  The numbers that work are 2^n for integer n.</p><p>&gt;&gt; The calculation will be slower -- maybe<br/>&gt;&gt; it&apos;ll take two or three times as long -- and the lookup<br/>&gt;&gt; table is less than half the size of Timidity&apos;s.<br/>&gt; &gt; So, all that is needed is to add the arguments for linear  &gt; interpolation whilst preserving the original 256 equal divisions of  &gt; the semitone tuning resolution. That way the actual increments we&apos;ll  &gt; be working with shall be much smaller than 0.39 cents. Right?</p><p>That&apos;s it.  But it&apos;s still easier to keep the original expression and let the standard libraries sort it out if you&apos;re on desktop hardware.</p><p>&gt;&gt; You need to calculate the frequency every time a note is<br/>&gt;&gt; played, or the pitch wheel moves.  That won&apos;t happen very<br/>&gt;&gt; often, compared to the rate at which any digital equipment<br/>&gt;&gt; has to process its samples.  Merely doubling the time it<br/>&gt;&gt; takes shouldn&apos;t be significant.  Unfortunately, the poor<br/>&gt;&gt; pitch resolution of many synthesizers shows that they aren&apos;t<br/>&gt;&gt; bothering :-(<br/>&gt; &gt; Good thing that there is Timidity++ then!</p><p>No, that&apos;s an example of an application that doesn&apos;t bother with interpolation.  ZynAddSubFX is apparently better, though, and Csound can use the 64-bit standard library.</p><p>                    Graham</p></div><h3><a id=85194 href="#85194">ðŸ”—</a>Graham Breed &#x3C;gbreed@...&#x3E;</h3><span>11/1/2009 10:05:06 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Ozan Yarman wrote:<br/>&gt; &#x2729; &#x2729; &#x2729;<br/>&gt; <a href="http://www.ozanyarman.com">www.ozanyarman.com</a><br/>&gt; &gt; On Oct 31, 2009, at 7:38 AM, Graham Breed wrote:<br/>&gt; &gt;&gt; Ozan Yarman wrote:<br/>&gt;&gt;<br/>&gt;&gt;&gt; So, if I eliminate the pitchbend lookup tables in Timidity entirely,<br/>&gt;&gt;&gt; do I arrive at MTS with 16384 increments per interval (semitone,<br/>&gt;&gt;&gt; wholetone, etc...)?<br/>&gt;&gt; Yes.  But it&apos;s only as good as the sample set you&apos;re using.<br/>&gt;&gt;  If the samples aren&apos;t tuned that accurately, the results<br/>&gt;&gt; won&apos;t be anyway.  That&apos;s why you should go for a purely<br/>&gt;&gt; algorithmic approach for high-precision tuning.<br/>&gt; &gt; So you mean that it is safer to keep the PB lookup tables and  &gt; implement linear interpolation?</p><p>No, I mean it may not be worth bothering.  If your samples aren&apos;t tuned to MTS precision it doesn&apos;t matter how precisely Timidity retunes them -- unless it does something clever with pitch recognition, which I doubt.  But ZynAddSubFX or VAZ Plus or Csound don&apos;t require real-world samples and so you can get much better control over the pitch.  So if you really care about this level of precision you may be better off without a sampler.</p><p>If you want to work with SoundFonts you may have to stomach this level of imprecision.  I have a vague idea that the SoundFont standard doesn&apos;t specify the pitch of samples any more precisely than Timidity&apos;s tuning tables anyway ... which would be a good reason why Timdity uses that level of precision.</p><p>&gt; Send me both a version of tables.c with no lookup tables and maximum  &gt; precision and another version with 256 divisions of the equal semitone  &gt; improved with linear interpolation. I&apos;ll test both versions if I can  &gt; ever successfully compile Timidity for Windows.</p><p>I can do that if you&apos;re ready to compile it.  I can also send you ZynAddSubFX instruments because I&apos;m playing with it now.  Maybe other people can help you there as well.</p><p>                  Graham</p></div><h3><a id=85242 href="#85242">ðŸ”—</a>Ozan Yarman &#x3C;ozanyarman@...&#x3E;</h3><span>11/13/2009 3:53:04 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hello Graham, a late reply:</p><p>On Nov 2, 2009, at 8:05 AM, Graham Breed wrote:</p><p>&gt; Ozan Yarman wrote:<br/>&gt;&gt; &#x2729; &#x2729; &#x2729;<br/>&gt;&gt; <a href="http://www.ozanyarman.com">www.ozanyarman.com</a><br/>&gt;&gt;<br/>&gt;&gt; On Oct 31, 2009, at 7:38 AM, Graham Breed wrote:<br/>&gt;&gt;<br/>&gt;&gt;&gt; Ozan Yarman wrote:<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt;&gt; So, if I eliminate the pitchbend lookup tables in Timidity<br/>&gt;&gt;&gt;&gt; entirely,<br/>&gt;&gt;&gt;&gt; do I arrive at MTS with 16384 increments per interval (semitone,<br/>&gt;&gt;&gt;&gt; wholetone, etc...)?<br/>&gt;&gt;&gt; Yes.  But it&apos;s only as good as the sample set you&apos;re using.<br/>&gt;&gt;&gt; If the samples aren&apos;t tuned that accurately, the results<br/>&gt;&gt;&gt; won&apos;t be anyway.  That&apos;s why you should go for a purely<br/>&gt;&gt;&gt; algorithmic approach for high-precision tuning.<br/>&gt;&gt;<br/>&gt;&gt; So you mean that it is safer to keep the PB lookup tables and<br/>&gt;&gt; implement linear interpolation?<br/>&gt;<br/>&gt; No, I mean it may not be worth bothering.  If your samples<br/>&gt; aren&apos;t tuned to MTS precision it doesn&apos;t matter how<br/>&gt; precisely Timidity retunes them -- unless it does something<br/>&gt; clever with pitch recognition, which I doubt.</p><p>I have experienced firsthand that the same soundfont contains patches<br/>that respond differently to pitch bends. One patch was a Reed Organthat only accepted cent increments, and the other was a Fantasia Pad<br/>that at least accepted 0.39 cent increments (due to the restriction of<br/>Timidity++ maybe?).</p><p>&gt; But<br/>&gt; ZynAddSubFX or VAZ Plus or Csound don&apos;t require real-world<br/>&gt; samples and so you can get much better control over the<br/>&gt; pitch.  So if you really care about this level of precision<br/>&gt; you may be better off without a sampler.<br/>&gt;</p><p>I concur.</p><p>&gt; If you want to work with SoundFonts you may have to stomach<br/>&gt; this level of imprecision.  I have a vague idea that the<br/>&gt; SoundFont standard doesn&apos;t specify the pitch of samples any<br/>&gt; more precisely than Timidity&apos;s tuning tables anyway ...</p><p>Yes, there is always the danger of that happening.</p><p>&gt; which would be a good reason why Timdity uses that level of<br/>&gt; precision.</p><p>Possibly.</p><p>&gt;<br/>&gt;&gt; Send me both a version of tables.c with no lookup tables and maximum<br/>&gt;&gt; precision and another version with 256 divisions of the equal<br/>&gt;&gt; semitone<br/>&gt;&gt; improved with linear interpolation. I&apos;ll test both versions if I can<br/>&gt;&gt; ever successfully compile Timidity for Windows.<br/>&gt;<br/>&gt; I can do that if you&apos;re ready to compile it.</p><p>I found this document on the internet for the compiling of Timidity++:</p><p><a href="http://www.csee.umbc.edu/help/sound/TiMidity++-2.13.2/doc/C/README.w32">http://www.csee.umbc.edu/help/sound/TiMidity++-2.13.2/doc/C/README.w32</a></p><p>It seems a lot of work, but I already set up Mingw and Msys (am not<br/>sure what additional libraries and components are needed), Got the<br/>pexports, pdcurses... I downloaded Oggvorbis, Gogo nocoder, Flac,<br/>Portaudio and Portmidi, but the instructions require me to compile<br/>them seperately, at which I was not successful.</p><p>&gt; I can also<br/>&gt; send you ZynAddSubFX instruments because I&apos;m playing with it<br/>&gt; now.  Maybe other people can help you there as well.<br/>&gt;</p><p>Yes, I would very much like to have your ZASFX instruments.</p><p>&gt;<br/>&gt;                   Graham<br/>&gt;<br/>&gt;</p><p>Cordially,<br/>Oz.</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            