<a href="/metatuning">back to list</a><h1>Python vs. Scheme/Lisp/Ruby</h1><h3>Aaron K. Johnson &#x3C;akjmicro@...&#x3E;</h3><span>8/29/2004 8:24:51 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On Sunday 29 August 2004 12:49 am, Carl Lumma wrote:<br/>&gt; &gt; (Aaron wrote):<br/>&gt; &gt; What could you possibly hate about Python? Let me guess--you<br/>&gt; &gt;are addicted to parentheses? (i.e. you are part of the<br/>&gt; &gt;Python vs. Lisp wars)<br/>&gt; (Carl wrote):<br/>&gt; No, the indents are actually my favorite part.  My main qualms<br/>&gt; are with the oo syntax, where I like Ruby better but still not<br/>&gt; to the point of liking it.  The problem is, when it comes to<br/>&gt; something like programming language syntax, I can basically carve<br/>&gt; wood with my ass.  The only way I&apos;ll ever be satisfied is to<br/>&gt; write my own language, which I do plan to undertake one day.<br/>&gt; And yes, I plan to use Scheme.</p><p>I don&apos;t have experience using Ruby, so I can&apos;t speak for it. I can say that<br/>being a Python user first, and loving it, would seem to mean that one is<br/>partial to think of Ruby as an inferior &apos;Python wannabe&apos;, and that it&apos;s a bit<br/>more obtuse-looking on the page (screen). Honestly, not being an &apos;OO weenee&apos;<br/>myself, I rarely use Python for it&apos;s &apos;OO features&apos; (oddly enough, because it&apos;s<br/>highly touted for them). I&apos;m more comfortable writing functional/imperative<br/>type programs anyway. And yes, indentations for block style programming kick<br/>ass, and it&apos;s a shame language designer before Guido van Rossum didn&apos;t pick<br/>up on that feature. Fuck braces, man.</p><p>In theory, I like the idea of Scheme/Lisp syntax. And it has a long cherished<br/>history and tradition in academic circles. And yes, it is aesthetically<br/>appealing. But in practice, I want to *get things done*, so I hate it&apos;s<br/>syntax, which is easy for computers, but hard for humans to parse. And, both<br/>seem not to have kept up with modern library functionality (ex. Web-based<br/>libs...). Web searches for Lisp/Scheme libraries give one pages that were<br/>last updated in 1998, it seems, on average. Ouch...if that doesn&apos;t indicate<br/>&apos;dead language&apos; I don&apos;t know what does. Correct me if I&apos;m wrong, though.<br/>Also, I left the Scheme/Lisp world in disgust over *that*, plus the<br/>unfriendly types on their respective usenets who were so unhelpful and<br/>disdainful of newer users. For a laugh (or a cry), look in the usenet<br/>archives for &apos;Erik Naggum&apos;, the Lisp worlds&apos; Brian McLaren, for an example of<br/>what I mean. In contrast, Python people are/seem to be knowledgeable,<br/>friendly and community-oriented.</p><p>Another factor for me that killed Scheme/Lisp is the utter fragmentation of<br/>their distribution. There is no standardization, in spite of the &apos;ANSI<br/>common&apos; claims. One couldn&apos;t guarantee that one could find all the features<br/>or libraries one needed in any one distribution, or that code that works in<br/>one would work in any of the others. Every vendor/implementor is off doing<br/>their own little fetish. That is an absolutely untenable situation AFAI am<br/>concerned, for any programming language. Python, Ruby, and even lame-ass-Perl<br/>(which is about the most heinous language syntax ever invented...I piss on<br/>Perl and on Larry Wall with utter contempt) don&apos;t suffer this, because there<br/>is one central place making/defining the language.</p><p>A final note--I&apos;ve come down, after back-and-forth thinking about it, on the<br/>side of infix math operators. I know, I know---RPN calculators are cool, but<br/>in a programming language, I find it gets the jobs done easier to think like<br/>a mathematician does, or like we all were taught in grade school, about how<br/>to write equations down.</p><p>Peace,</p><p>Aaron Krister Johnson<br/><a href="http://www.dividebypi.com">http://www.dividebypi.com</a><br/><a href="http://www.akjmusic.com">http://www.akjmusic.com</a></p></div><h3>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>8/29/2004 9:59:40 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt;No, the indents are actually my favorite part.  My main qualms<br/>&gt;&gt;are with the oo syntax, where I like Ruby better but still not<br/>&gt;&gt;to the point of liking it.  The problem is, when it comes to<br/>&gt;&gt;something like programming language syntax, I can basically<br/>&gt;&gt;carve wood with my ass.  The only way I&apos;ll ever be satisfied<br/>&gt;&gt;is to write my own language, which I do plan to undertake one<br/>&gt;&gt;day.  And yes, I plan to use Scheme.<br/>&gt;<br/>&gt; I don&apos;t have experience using Ruby, so I can&apos;t speak for it.<br/>&gt; I can say that being a Python user first, and loving it,<br/>&gt; would seem to mean that one is partial to think of Ruby as<br/>&gt; an inferior &apos;Python wannabe&apos;,</p><p>It&apos;s more of a Perl wannabe, and a great improvement on that<br/>wasp&apos;s nest if you ask me.</p><p>&gt; Honestly, not being an &apos;OO weenee&apos;<br/>&gt; myself, I rarely use Python for it&apos;s &apos;OO features&apos; (oddly<br/>&gt; enough, because it&apos;s highly touted for them). I&apos;m more<br/>&gt; comfortable writing functional/imperative type programs<br/>&gt; anyway.</p><p>The two are not mutually exclusive.</p><p>&gt; In theory, I like the idea of Scheme/Lisp syntax.<br/>//<br/>&gt; But in practice, I want to *get things done*, so I hate<br/>&gt; it&apos;s syntax, which is easy for computers, but hard for<br/>&gt; humans to parse.</p><p>I find it very easy to parse, but that may be because<br/>it was the first language I learned (other than BASIC).</p><p>&gt; And, both seem not to have kept up with modern library<br/>&gt; functionality (ex. Web-based libs...).</p><p>Yeah, it&apos;s a problem.</p><p>&gt; A final note--I&apos;ve come down, after back-and-forth<br/>&gt; thinking about it, on the side of infix math operators.<br/>&gt; I know, I know---RPN calculators are cool, but in a<br/>&gt; programming language, I find it gets the jobs done<br/>&gt; easier to think like a mathematician does, or like<br/>&gt; we all were taught in grade school, about how<br/>&gt; to write equations down.</p><p>I&apos;ve always hated infix.  Hated it in gradeschool, hated<br/>it when learning C and Java.  Mathematicians don&apos;t have<br/>to deal with assignment.  Scheme is plain polish by the<br/>way, rather thna RPN.</p><p>Ok, now I will make a confession re. functional v.<br/>imperitive.  Functional is more compact, more reusable<br/>and probably easier to maintain.  But, unless you&apos;re<br/>one of the few who are just smart enough to do it, I<br/>think the extra difficulty of functional programming<br/>is hard to justify.  It&apos;s harder to write and harder<br/>to read, compared to good imperitive code (yes,<br/>imperitive lets programmers get away with writing<br/>worse code).  I think imperitive is so much more<br/>popular for a reason: humans are used to thinking in<br/>terms of stepwise actions in their environment.  For<br/>this reason I do not even buy the &apos;lisp is good for<br/>teaching programming&apos; argument, and I think this goes<br/>a long way in explaining why so few good programmers<br/>come out of MIT these days. :)</p><p>Yes, both styles are natural for their own styles of<br/>problems, which is why both Scheme and Python support<br/>both, but on balance, I acknowledge that I need to<br/>adopt an imperitive lang.</p><p>-Carl</p></div><h3>Aaron K. Johnson &#x3C;akjmicro@...&#x3E;</h3><span>8/29/2004 11:31:11 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>On Sunday 29 August 2004 11:59 am, Carl Lumma wrote:<br/>&gt; &gt;&gt;No, the indents are actually my favorite part.  My main qualms<br/>&gt; &gt;&gt;are with the oo syntax, where I like Ruby better but still not<br/>&gt; &gt;&gt;to the point of liking it.  The problem is, when it comes to<br/>&gt; &gt;&gt;something like programming language syntax, I can basically<br/>&gt; &gt;&gt;carve wood with my ass.  The only way I&apos;ll ever be satisfied<br/>&gt; &gt;&gt;is to write my own language, which I do plan to undertake one<br/>&gt; &gt;&gt;day.  And yes, I plan to use Scheme.<br/>&gt; &gt;<br/>&gt; &gt; Aaron wrote :I don&apos;t have experience using Ruby, so I can&apos;t speak for it.<br/>&gt; &gt; I can say that being a Python user first, and loving it,<br/>&gt; &gt; would seem to mean that one is partial to think of Ruby as<br/>&gt; &gt; an inferior &apos;Python wannabe&apos;,<br/>&gt;<br/>&gt; It&apos;s more of a Perl wannabe, and a great improvement on that<br/>&gt; wasp&apos;s nest if you ask me.</p><p>How is it similar to/different from Perl? Can you elaborate?</p><p>&gt; &gt; Honestly, not being an &apos;OO weenee&apos;<br/>&gt; &gt; myself, I rarely use Python for it&apos;s &apos;OO features&apos; (oddly<br/>&gt; &gt; enough, because it&apos;s highly touted for them). I&apos;m more<br/>&gt; &gt; comfortable writing functional/imperative type programs<br/>&gt; &gt; anyway.<br/>&gt;<br/>&gt; The two are not mutually exclusive.</p><p>True, it&apos;s just that I don&apos;t tend to think in OO.</p><p>&gt; &gt; In theory, I like the idea of Scheme/Lisp syntax.<br/>&gt;<br/>&gt; //<br/>&gt;<br/>&gt; &gt; But in practice, I want to *get things done*, so I hate<br/>&gt; &gt; it&apos;s syntax, which is easy for computers, but hard for<br/>&gt; &gt; humans to parse.<br/>&gt;<br/>&gt; I find it very easy to parse, but that may be because<br/>&gt; it was the first language I learned (other than BASIC).</p><p>Could be the reason....</p><p>&gt; Ok, now I will make a confession re. functional v.<br/>&gt; imperitive.  Functional is more compact, more reusable<br/>&gt; and probably easier to maintain.  But, unless you&apos;re<br/>&gt; one of the few who are just smart enough to do it, I<br/>&gt; think the extra difficulty of functional programming<br/>&gt; is hard to justify.  It&apos;s harder to write and harder<br/>&gt; to read, compared to good imperitive code (yes,<br/>&gt; imperitive lets programmers get away with writing<br/>&gt; worse code).  I think imperitive is so much more<br/>&gt; popular for a reason: humans are used to thinking in<br/>&gt; terms of stepwise actions in their environment.  For<br/>&gt; this reason I do not even buy the &apos;lisp is good for<br/>&gt; teaching programming&apos; argument, and I think this goes<br/>&gt; a long way in explaining why so few good programmers<br/>&gt; come out of MIT these days. :)</p><p>Functional code reduces to imperative code at the machine level, eventually.<br/>I think functional thinking is very powerful, esp. if the implementation<br/>allows for in-place variable update, so as not to waste stack space (e.g.<br/>Scheme, with it&apos;s tail-recursive feature) I suspect this is now standard with<br/>most languages nowadays.</p><p>One bad about Python is that it is a pretty heavy cost speed-wise to<br/>repeatedly call a function from a loop--it&apos;s better to prototype the<br/>functions, then do inline code during a loop.</p><p>Aaron Krister Johnson<br/><a href="http://www.dividebypi.com">http://www.dividebypi.com</a><br/><a href="http://www.akjmusic.com">http://www.akjmusic.com</a></p></div><h3>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>8/29/2004 12:37:30 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt;&gt; [Ruby]&apos;s more of a Perl wannabe, and a great improvement<br/>&gt;&gt; on that wasp&apos;s nest if you ask me.<br/>&gt;<br/>&gt; How is it similar to/different from Perl? Can you elaborate?</p><p>Sorry, I&apos;m cutting this thread off.  No time.  There<br/>are many good Ruby tutorials on the web if you&apos;re interested.</p><p>&gt; Functional code reduces to imperative code at the machine<br/>&gt; level, eventually.</p><p>Obviously.</p><p>&gt; I think functional thinking is very powerful, esp. if the<br/>&gt; implementation allows for in-place variable update, so as<br/>&gt; not to waste stack space (e.g. Scheme, with it&apos;s<br/>&gt; tail-recursive feature) I suspect this is now standard with<br/>&gt; most languages nowadays.<br/>&gt;<br/>&gt; One bad about Python is that it is a pretty heavy cost<br/>&gt; speed-wise to repeatedly call a function from a loop--it&apos;s<br/>&gt; better to prototype the functions, then do inline code<br/>&gt; during a loop.</p><p>Yeah.  I&apos;m not aware of any particular performance hit in<br/>Scheme for using its imperitive stuff, but then again Scheme<br/>isn&apos;t all that fast to begin with (though apparently Bigloo<br/>is pretty good).</p><p>-Carl</p></div>