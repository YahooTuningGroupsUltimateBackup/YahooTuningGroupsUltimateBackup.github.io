<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup metatuning types</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/metatuning">back to list</a><h1>types</h1><h3><a id=8474 href="#8474">ðŸ”—</a>Christopher Bailey &#x3C;chris@...&#x3E;</h3><span>8/30/2004 12:11:46 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; competition for &quot;real&quot; languages in what they do best. It is not<br/>&gt; fancy, a feature I like. It isn&apos;t oo. It does not fuss very much about<br/>&gt; data types. It has a syntax which looks about as much like standard</p><p>Yes. . .this is what I like about LISP also.   You can make lists of<br/>instrument-name,  pitch-class, ratio,  etc., all co-existing in the same<br/>list.</p><p>BTW, Ratio is a data type.  Whoopeeee!</p></div><h3><a id=8476 href="#8476">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@...&#x3E;</h3><span>8/30/2004 5:04:02 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:metatuning@yahoogroups.com">metatuning@yahoogroups.com</a>, Christopher Bailey &lt;chris@m...&gt; wrote:<br/>&gt;<br/>&gt;<br/>&gt; &gt; competition for &quot;real&quot; languages in what they do best. It is not<br/>&gt; &gt; fancy, a feature I like. It isn&apos;t oo. It does not fuss very much about<br/>&gt; &gt; data types. It has a syntax which looks about as much like standard<br/>&gt;<br/>&gt; Yes. . .this is what I like about LISP also.</p><p>With all due respect to the Lots of Irritating Single Parenthesis, I<br/>don&apos;t think LISP looks all that much like anything but LISP. It is<br/>related to the lambda calculus, but that&apos;s hardly the same as standard<br/>math notation.</p><p>You can make lists of<br/>&gt; instrument-name,  pitch-class, ratio,  etc., all co-existing in the<br/>same<br/>&gt; list.</p><p>LISP can eat that stuff alive, I am sure.<br/>&gt;<br/>&gt; BTW, Ratio is a data type.  Whoopeeee!</p></div><h3><a id=8483 href="#8483">ðŸ”—</a>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>8/31/2004 10:38:17 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi there,</p><p>Well while we are talking about computer languages<br/>may I just put in a word for C :-).</p><p>I know all its failings - that it isn&apos;t type safe,<br/>no array bound checking, permits wild pointers and so forth.<br/>And this is about C, not about C++. I&apos;d better not<br/>say anything about C++ as I don&apos;t use it but I think<br/>it isn&apos;t particularly reputed to be the best of the<br/>object orientated languages available.</p><p>However, C itself was written as a low to intermediate<br/>level language orignially, for such tasks as writing compilers.<br/>So, it&apos;s no surprise that it was hard to extend it to<br/>make a good object orientated language, and it shows<br/>how good it must be that anyone would even attempt that<br/>rather than start again from scratch.</p><p>It does what it was originally designed for well<br/>- lets you work at a low level quite close to assembly,<br/>and at the same time to be able to make high level<br/>constructs and macros.</p><p>It is a demanding language - you have to think clearly to<br/>write in C and if you don&apos;t you end up writing spaghetti<br/>which no-one can read, even yourself. You have to<br/>think clearly and comment your code extensively<br/>and learn the art of commenting - what needs to be<br/>said and what can be expected to be inferred by the<br/>reader later on.</p><p>But when you get into the swing of it then it is<br/>a beautiful language - it rewards clear thinking.<br/>It also requires clear thinking too - that&apos;s the<br/>thing.</p><p>What&apos;s nice about it is that it lets you design<br/>your own architecture to such a large extent.<br/>That then gives you the freedom to construct<br/>something aesthetic, beautiful and easy to<br/>add to later - or something ugly and impossible<br/>for anyone else to work with. You can write<br/>a C program of only a 10 lines that is almost<br/>comletely unreadable and so spaghettified<br/>that it would be hard to make even the<br/>smallest change to it without breaking it completely.<br/>- see the obfuscated C contests for<br/>examples. Or you can write a C program of hundreds of<br/>thousands of lines of code that is a pleasure to work with<br/>when you add more features to it later on.</p><p>Most C programmers are somewhere between those<br/>two extremes - well the obfuscated c programmers<br/>deliberately make spaghetti code with just<br/>a dozen lines or so - it must be one of the<br/>best obfuscating languages there is :-).<br/>Then Windows C also - C + the addition of the architecture<br/>and routines of Windows libraries - that also is a very<br/>beautiful language too in my opinion. I came to it<br/>from X Windows - the Unix version of Windowing<br/>and was very much struck by the clarity of the<br/>architecture of Windows C - the low level<br/>C programming again there - not the C++ constructs<br/>which I don&apos;t know enough about to comment on.<br/>It is a pleasure to write in it and you feel it<br/>is worth all the effort to learn<br/>to write well in Windows C.</p><p>I&apos;m not trying to convert anyone else to C.<br/>Very much an individual thing, what language<br/>one likes to write in. Maple sounds good.<br/>I remember that when I was at the Maths<br/>dept then they had Maple there.</p><p>I&apos;d get Mathematica or Maple myself certainly,<br/>if they didn&apos;t cost so very much - a thousand<br/>pounds for mathematica I believe, and<br/>don&apos;t know how much for Maple, but quite a lot.</p><p>Surely Maple would have unlimited precision<br/>arithmetic does it not? I&apos;d be surprised if not.<br/>E.g. if you enter 191! or something - it has<br/>to write out all the digits or it would be<br/>rather strange, for a mathematical package.</p><p>That&apos;s not so rare these days and there are various<br/>open source libraries for it, and I think<br/>it wouldn&apos;t take so much work to develop<br/>such a library. I wish C had that.</p><p>Also native support for ratios would<br/>be great. I just added 64 bit ratios<br/>(i.e.denumerator and denominator 64 bit)<br/>to the calculator in FTS and having sorted<br/>out the arithmetic for adding, dividing<br/>multiplying and subtracting, and exponentiating<br/>by an integer, it would be routine<br/>(but would take a while) to convert all<br/>the scales in FTS to be able to handle<br/>64 bit ratios in the same way, which would be<br/>enough for almost any tuning application, apart<br/>from some rare ones. That&apos;s the sort of<br/>thing that might be easier in a higher level<br/>object orienated language I gather<br/>- but then I find the idea of operator<br/>overloading very confusing to think about<br/>and maybe it isn&apos;t for me. I prefer<br/>to know exactly what an operator does.<br/>Very much an individual thing I&apos;m sure.</p><p>Robert</p></div><h3><a id=8486 href="#8486">ðŸ”—</a>Graham Breed &#x3C;graham@...&#x3E;</h3><span>9/1/2004 1:47:05 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Robert Walker wrote:</p><p>&gt; I&apos;d get Mathematica or Maple myself certainly,<br/>&gt; if they didn&apos;t cost so very much - a thousand<br/>&gt; pounds for mathematica I believe, and<br/>&gt; don&apos;t know how much for Maple, but quite a lot.</p><p>I found Maple V for Windows in a bookshop for under 100 pounds.  If you aren&apos;t a student, and you can&apos;t find a bookshop selling old copies, it is very expensive.</p><p>Say, would you like my copy?  I hardly use it.</p><p>&gt; Surely Maple would have unlimited precision<br/>&gt; arithmetic does it not? I&apos;d be surprised if not.<br/>&gt; E.g. if you enter 191! or something - it has<br/>&gt; to write out all the digits or it would be<br/>&gt; rather strange, for a mathematical package.</p><p>It supports &quot;arbitrary precision&quot; rather than the unrealistic &quot;unlimited precision&quot;.  It also seems to support do arbitrary precision floating point, which is more difficult, and you don&apos;t get with Python out of the box.</p><p>&gt; That&apos;s not so rare these days and there are various<br/>&gt; open source libraries for it, and I think<br/>&gt; it wouldn&apos;t take so much work to develop<br/>&gt; such a library. I wish C had that.</p><p>Well, here&apos;s a library:</p><p><a href="http://www.swox.com/gmp/">http://www.swox.com/gmp/</a></p><p>                       Graham</p></div><h3><a id=8487 href="#8487">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@...&#x3E;</h3><span>9/1/2004 3:20:36 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:metatuning@yahoogroups.com">metatuning@yahoogroups.com</a>, &quot;Robert Walker&quot; &lt;robertwalker@n...&gt;<br/>wrote:</p><p>&gt; Surely Maple would have unlimited precision<br/>&gt; arithmetic does it not? I&apos;d be surprised if not.<br/>&gt; E.g. if you enter 191! or something - it has<br/>&gt; to write out all the digits or it would be<br/>&gt; rather strange, for a mathematical package.</p><p>It&apos;s limited by the physical limits of your computer, of course.<br/>People can have funny ideas about what those are. A characteristically<br/>brilliant Berkeley math professor asked me how I&apos;d go about evaluating<br/>n! modulo prime powers using Macsyma; it&apos;s easy enough mod a prime,<br/>but how about prime powers? I said the bonehead method of simply<br/>plugging it in would work fine unless the numbers involved were large,<br/>and he replied in a worried voice that it could get up to 1000! or so,<br/>so that wouldn&apos;t work!</p></div><h3><a id=8488 href="#8488">ðŸ”—</a>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>9/1/2004 11:09:39 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; &gt; Surely Maple would have unlimited precision<br/>&gt; &gt; arithmetic does it not? I&apos;d be surprised if not.<br/>&gt; &gt; E.g. if you enter 191! or something - it has<br/>&gt; &gt; to write out all the digits or it would be<br/>&gt; &gt; rather strange, for a mathematical package.<br/>&gt;<br/>&gt; It&apos;s limited by the physical limits of your computer, of<br/>&gt; course. People can have funny ideas about what those are. A<br/>characteristically brilliant Berkeley math professor asked<br/>&gt; me how I&apos;d go about evaluating n! modulo prime powers using<br/>&gt; Macsyma; it&apos;s easy enough mod a prime, but how about prime<br/>&gt; powers? I said the bonehead method of simply plugging it in<br/>&gt; would work fine unless the numbers involved were large, and<br/>&gt; he replied in a worried voice that it could get up to 1000!<br/>&gt; or so, so that wouldn&apos;t work!</p><p>Hmm, I&apos;m guessing is the joke that he was brilliant but<br/>outdated, and 1000! is tiny.  That right?</p><p>-Carl</p></div><h3><a id=8489 href="#8489">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@...&#x3E;</h3><span>9/1/2004 11:24:28 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:metatuning@yahoogroups.com">metatuning@yahoogroups.com</a>, &quot;Carl Lumma&quot; &lt;clumma@y...&gt; wrote:</p><p>&gt; Hmm, I&apos;m guessing is the joke that he was brilliant but<br/>&gt; outdated, and 1000! is tiny.  That right?</p><p>He was not a computer person; most mathematicians aren&apos;t. Yes, even<br/>back in the 80s 1000!, a number of 2568 digits, hardly qualified as &quot;big&quot;.</p><p>Maple, by the way, uses &quot;1000!&quot; to denote 1000!, a typical Maple move.<br/>It also works for complex numbers--stick in (-0.5)!, square it, and<br/>you get pi. Stick in ((-1/2)!)^2 and you have to simplify it, but if<br/>you do you get pi exactly. This sort of thing is an example of why<br/>Maple isn&apos;t really like a typical computer language and is called a<br/>computer algebra package.</p></div><h3><a id=8492 href="#8492">ðŸ”—</a>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>9/1/2004 11:40:58 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Gene,</p><p>&gt; &gt; Surely Maple would have unlimited precision<br/>&gt; &gt; arithmetic does it not? I&apos;d be surprised if not.<br/>&gt; &gt; E.g. if you enter 191! or something - it has<br/>&gt; &gt; to write out all the digits or it would be<br/>&gt; &gt; rather strange, for a mathematical package.<br/>&gt;<br/>&gt; It&apos;s limited by the physical limits of your computer, of course.<br/>&gt; People can have funny ideas about what those are. A characteristically<br/>&gt; brilliant Berkeley math professor asked me how I&apos;d go about evaluating<br/>&gt; n! modulo prime powers using Macsyma; it&apos;s easy enough mod a prime,<br/>&gt; but how about prime powers? I said the bonehead method of simply<br/>&gt; plugging it in would work fine unless the numbers involved were large,<br/>&gt; and he replied in a worried voice that it could get up to 1000! or so,<br/>&gt; so that wouldn&apos;t work!<br/>&gt;</p><p>Yes would be limited by the disk space required to store<br/>all the digits :-). Well - sort of, usually would be.</p><p>Actually even if your entire disk were filled with a large integer<br/>as digits type representation of some very large number,<br/>you only see part of it at any time. Similarly even<br/>if it is a large book, showing thousands of digits<br/>of pi or something, then you can only see one line<br/>or page at a time, and your eye may not even see the<br/>complete line in one go.</p><p>Do you remember the algorithm someone found that<br/>lets you calculate digits of pi at any particular<br/>point to some particular base without calculating the<br/>previous digits leading up to that one?</p><p>I can&apos;t remember how it worked now - but I remember downloading a program<br/>that did the calculation, and trying it out, may even still have it<br/>somewhere on my hard disk.</p><p>To get philsophical about it - if you can see e.g. a slice of<br/>10 consecutive digits anywhere at any point in the expansion,<br/>up to some very large number, too large to store all the digits on ones<br/>hard drive, I wonder if that counts equally well as a representation<br/>of that very large number. (I don&apos;t know if this particular<br/>one really gets quite that far so easily but you never know).</p><p>Well - I could easily do a program to display e.g.<br/>10^(10^(10^10)) in that way. Ask for any position before<br/>the (10^(10^10)) th digit,  and it shows you a string of 0s.<br/>Anything after that and it doesn&apos;t show anythign at all.<br/>If user happens to hit exactly on the (10^(10^10)) th<br/>digit then show a 1 in the appropriate place<br/>on the screen followed by 0s.</p><p>So you could say that that is a complete large integer<br/>type digits representation of 10^(10^(10^10))<br/>which could be shown on an ordinary p.c.<br/>The digits happen to be created dynamically<br/>rather than all in one go and then stored on<br/>hard disk and recovered again later for display.</p><p>After all what difference does it make if the<br/>digits are actually stored on the hard disk<br/>or generated dynamically on request by<br/>the user?</p><p>After all it is only the human<br/>reading it on a computer display that makes it a<br/>count as a digital representation of a number<br/>- otherwise it is just a pattern of<br/>magnetic domains on a piece of material.</p><p>You could even get the computer to<br/>flash the digits up scrolling them as if reading<br/>a huge number, dial in any point in the sequence<br/>and get it to read it from there,<br/>even though it doesn&apos;t have the whole thing<br/>stored anywhere. Kind of true virtual memory...</p><p>So in some special cases you mighte able to even go<br/>somewhat beyond the physical limitations of ones<br/>computer.</p><p>way, uses &quot;1000!&quot; to denote 1000!, a typical Maple move.<br/>&gt; It also works for complex numbers--stick in (-0.5)!, square it, and<br/>&gt; you get pi. Stick in ((-1/2)!)^2 and you have to simplify it, but if<br/>&gt; you do you get pi exactly. This sort of thing is an example of why<br/>&gt; Maple isn&apos;t really like a typical computer language and is called a<br/>&gt; computer algebra package.</p><p>Yes (0.5)! is a bit strange looking when unacustomed to it.<br/>:-).</p><p>It would be using the Gamma function generalisation of<br/>factorials to reals I assume. I&apos;m not very familiar<br/>with that, and never actually needed to use it for<br/>anything, but believe it uses pi.</p><p>Robert</p></div><h3><a id=8493 href="#8493">ðŸ”—</a>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>9/1/2004 11:38:34 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Graham,</p><p>&gt; &gt; I&apos;d get Mathematica or Maple myself certainly,<br/>&gt; &gt; if they didn&apos;t cost so very much - a thousand<br/>&gt; &gt; pounds for mathematica I believe, and<br/>&gt; &gt; don&apos;t know how much for Maple, but quite a lot.<br/>&gt;<br/>&gt; I found Maple V for Windows in a bookshop for under 100 pounds.  If you<br/>&gt; aren&apos;t a student, and you can&apos;t find a bookshop selling old copies, it<br/>&gt; is very expensive.<br/>&gt;<br/>&gt; Say, would you like my copy?  I hardly use it.</p><p>That would be great, thanks!</p><p>&gt;<br/>&gt; &gt; Surely Maple would have unlimited precision<br/>&gt; &gt; arithmetic does it not? I&apos;d be surprised if not.<br/>&gt; &gt; E.g. if you enter 191! or something - it has<br/>&gt; &gt; to write out all the digits or it would be<br/>&gt; &gt; rather strange, for a mathematical package.<br/>&gt;<br/>&gt; It supports &quot;arbitrary precision&quot; rather than the unrealistic &quot;unlimited<br/>&gt; precision&quot;.  It also seems to support do arbitrary precision floating<br/>&gt; point, which is more difficult, and you don&apos;t get with Python out of the<br/>&gt; box.</p><p>Rightio that makes sense - I suppose you set the precision in advance.</p><p>&gt; &gt; That&apos;s not so rare these days and there are various<br/>&gt; &gt; open source libraries for it, and I think<br/>&gt; &gt; it wouldn&apos;t take so much work to develop<br/>&gt; &gt; such a library. I wish C had that.<br/>&gt;<br/>&gt; Well, here&apos;s a library:<br/>&gt;<br/>&gt; <a href="http://www.swox.com/gmp/">http://www.swox.com/gmp/</a></p><p>Thanks, great. I see that it is Lpgl&apos;d rather than Gpl&apos;d<br/>so I can include it with commercial programs so long<br/>as I keep it unchanged or make available any modifications<br/>I make to it (unlikely to need that probably).</p><p>Also looks as though it should be very fast indeed<br/>if that is ever a consideration.</p><p>I found a site for pre-compiled windows dlls for it here:<br/>ftp://deltatrinity.dynip.com/gmp-4.1.3_DLL_SharedLibs/<br/>so will give them a go some time. I&apos;m sure it will be useful, as I<br/>fairly often wish I had a big numbers library for something or other.</p><p>Robert</p></div><h3><a id=8494 href="#8494">ðŸ”—</a>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>9/2/2004 2:57:51 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; Do you remember the algorithm someone found that<br/>&gt; lets you calculate digits of pi at any particular<br/>&gt; point to some particular base without calculating the<br/>&gt; previous digits leading up to that one?</p><p>There may be several &quot;spigot&quot; algoritms for pi, but<br/>the most famous is due to Ramanujan (sp?).</p><p>This is actually very interesting, because pi is<br/>normal in base 2 IIRC and maybe all bases.  It is<br/>also essentially random as far as Shannon entropy<br/>is concerned.  Yet there&apos;s a simple spigot algorithm<br/>for it.  This is the most extreme case of this<br/>kind of thing I&apos;m aware of, but I assume there are<br/>many.</p><p>But not too many, because there aren&apos;t too many<br/>short spigot algorithms out there, since they too<br/>are strings.</p><p>&gt; Yes (0.5)! is a bit strange looking when unacustomed to it.<br/>&gt; :-).<br/>&gt;<br/>&gt; It would be using the Gamma function generalisation of<br/>&gt; factorials to reals I assume. I&apos;m not very familiar<br/>&gt; with that, and never actually needed to use it for<br/>&gt; anything, but believe it uses pi.</p><p>I too was shocked and aghast.  But gamma functions are<br/>mentioned at the bottom of mathworld&apos;s page on Factorial.<br/>I haven&apos;t had a chance to look at it though, and probably<br/>won&apos;t until I get back from burning man.</p><p>-Carl</p></div><h3><a id=8498 href="#8498">ðŸ”—</a>Graham Breed &#x3C;graham@...&#x3E;</h3><span>9/2/2004 6:19:14 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Robert Walker wrote:</p><p>&gt; Actually even if your entire disk were filled with a large integer<br/>&gt; as digits type representation of some very large number,<br/>&gt; you only see part of it at any time. Similarly even<br/>&gt; if it is a large book, showing thousands of digits &gt; of pi or something, then you can only see one line &gt; or page at a time, and your eye may not even see the<br/>&gt; complete line in one go.</p><p>And if you needed to multiply two such numbers, the number of times you had to read each one from the disk would be proporitional to the number of bits in each.  It&apos;d be really, incredibly slow.</p><p>&gt; To get philsophical about it - if you can see e.g. a slice of<br/>&gt; 10 consecutive digits anywhere at any point in the expansion,<br/>&gt; up to some very large number, too large to store all the digits on ones<br/>&gt; hard drive, I wonder if that counts equally well as a representation<br/>&gt; of that very large number. (I don&apos;t know if this particular<br/>&gt; one really gets quite that far so easily but you never know).</p><p>Remember that if the number&apos;s stored in binary, extracting a decimal digit requires you to read the whole number.  Some libraries do let you store the number in decimal.</p><p>&gt; Well - I could easily do a program to display e.g.<br/>&gt; 10^(10^(10^10)) in that way. Ask for any position before<br/>&gt; the (10^(10^10)) th digit,  and it shows you a string of 0s.<br/>&gt; Anything after that and it doesn&apos;t show anythign at all.<br/>&gt; If user happens to hit exactly on the (10^(10^10)) th &gt; digit then show a 1 in the appropriate place<br/>&gt; on the screen followed by 0s. Yes, there are lots of cases where writing the program a better way saves you having to worry about a super-duper library.</p><p>&gt; After all it is only the human<br/>&gt; reading it on a computer display that makes it a &gt; count as a digital representation of a number &gt; - otherwise it is just a pattern of<br/>&gt; magnetic domains on a piece of material.</p><p>Printing very large (that is, beyond RAM limitations) numbers in decimal is pretty useless anyway.  Some calculations may happen to require very large numbers as intermediate results, but nobody has to see them.  I wondered if Maple simplified them automatically, but it seems not. Examples like (10^1000000)-(10^100000 - 1) are obviously taking a non trivial amount of time.</p><p>There&apos;s a standard algorithm for raising one number to the power of another, modulo a third.  It gets used in cryptography, and makes the calculation a lot faster than the naive approach, as well as saving memory.  So math libraries tend to supply it.</p><p>&gt; So in some special cases you mighte able to even go<br/>&gt; somewhat beyond the physical limitations of ones<br/>&gt; computer.</p><p>That&apos;s roughly what we do with prime factor notation.  As long as the numbers start off relatively simple, they can be converted to arrays and then multiplied and divided to your heart&apos;s content.  You can work out their sizes as intervals in cents without worrying about what the ratio looks like in decimal.</p><p>                  Graham</p></div><h3><a id=8500 href="#8500">ðŸ”—</a>Graham Breed &#x3C;graham@...&#x3E;</h3><span>9/2/2004 6:36:27 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Robert Walker wrote:</p><p>&gt; That would be great, thanks!</p><p>I&apos;ll drop it off if I&apos;m ever around Oxford.  May happen!</p><p>&gt; Rightio that makes sense - I suppose you set the precision in advance.</p><p>For floating point, yes, I think so.  At least that&apos;s how Maple and BC work.  For integers, you can adapt to make them as large as they need be.  Rationals too, by extension.</p><p>Arbitrary precision integers are mainstream now, because they&apos;re needed for encryption protocols.  All kinds of languages decide they need to make SSL connections and the like.  Another niche is decimal arithmetic for financial applications.  This can be critically important, because a rounding error on a tax return can be a criminal offence :-O.  Here&apos;s the Python proposal if anybody&apos;s interested:</p><p><a href="http://www.python.org/peps/pep-0327.html">http://www.python.org/peps/pep-0327.html</a></p><p>BTW, the educational language ABC used exact rational arithmetic by default.  So if you did 1/2 it would hold it as a ratio.  The idea was that newbie programmers didn&apos;t have to worry about the loss of precision inherent in floating point.  It turns out that engineers ran into trouble because the numbers got so large their programs became inefficient.  Usually, floating point was all they needed, or expected.   It was this experience that led Guido to drop the feature in Python. For the average programmer, floating point is less confusing.  Those who really need rationals can always find a way, and there aren&apos;t actually very many of us.</p><p>                       Graham</p></div><h3><a id=8501 href="#8501">ðŸ”—</a>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>9/2/2004 9:33:39 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Carl,</p><p>Thanks for the mention of pi spigot programs. They were<br/>new to me actually.</p><p>Actually what I had in mind was a digit extraction algorithm.</p><p>Here is the url:</p><p><a href="http://mathworld.wolfram.com/BBPFormula.html">http://mathworld.wolfram.com/BBPFormula.html</a></p><p>and more about it at the bottom of this page:</p><p><a href="http://mathworld.wolfram.com/PiFormulas.html">http://mathworld.wolfram.com/PiFormulas.html</a></p><p>Looking up the spigot programs,<br/>I find that they are streaming algorithms<br/>that let you discard earlier digits after you<br/>calculate them - I just found this minimalist c program for<br/>spigot pi:</p><p><a href="http://www1.physik.tu-muenchen.de/~gammel/matpack/html/Mathematics/Pi.html">http://www1.physik.tu-muenchen.de/~gammel/matpack/html/Mathematics/Pi.html</a></p><p>But the digit extraction algorithm lets<br/>you calculate e.g. the trillionth digit of pi to base 16<br/>without ever calculating any of the earlier digits at all.<br/>Just plug in 10^12 (or 10^18 if it is an British trillion<br/>though we all use American billions and trillions nowadays)<br/>into the formula and it will give you the trillionth digit<br/>of pi to base 16, no need to wait at all, with no more<br/>calculation than that.</p><p>Quite remarkable!</p><p>If you can do it to base 16 then that means that<br/>you have the binary expansion of pi too.</p><p>Robert</p></div><h3><a id=8502 href="#8502">ðŸ”—</a>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>9/2/2004 9:40:27 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; BTW, the educational language ABC used exact rational<br/>&gt; arithmetic by default.  So if you did 1/2 it would hold<br/>&gt; it as a ratio.  The idea was that newbie programmers<br/>&gt; didn&apos;t have to worry about the loss of precision<br/>&gt; inherent in floating point.</p><p>Scheme does this, and it isn&apos;t only useful for newbies.<br/>It also has arbitrary precision decimals.  The data<br/>types are called &quot;exact&quot; and &quot;inexact&quot; numbers, resp.</p><p>&gt; It turns out that engineers ran into trouble because<br/>&gt; the numbers got so large their programs became inefficient.</p><p>Now this sounds like a problem of newbies.</p><p>&gt; Usually, floating point was all they needed, or expected.</p><p>My position is the weaker the typing the better.</p><p>&gt; For the average programmer, floating point is less confusing.</p><p>If somebody&apos;s used to something, it&apos;s bound to be the<br/>less confusing way.</p><p>-Carl</p></div><h3><a id=8506 href="#8506">ðŸ”—</a>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>9/2/2004 10:52:22 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Graham,</p><p>&gt; &gt; That would be great, thanks!<br/>&gt;<br/>&gt; I&apos;ll drop it off if I&apos;m ever around Oxford.  May happen!</p><p>Fine!</p><p>&gt; &gt; Rightio that makes sense - I suppose you set the precision in advance.<br/>&gt;<br/>&gt; For floating point, yes, I think so.  At least that&apos;s how Maple and BC<br/>&gt; work.  For integers, you can adapt to make them as large as they need<br/>&gt; be.  Rationals too, by extension.<br/>&gt;<br/>&gt; Arbitrary precision integers are mainstream now, because they&apos;re needed<br/>&gt; for encryption protocols.  All kinds of languages decide they need to<br/>&gt; make SSL connections and the like.  Another niche is decimal arithmetic<br/>&gt; for financial applications.  This can be critically important, because a<br/>&gt; rounding error on a tax return can be a criminal offence :-O.  Here&apos;s<br/>&gt; the Python proposal if anybody&apos;s interested:<br/>&gt;<br/>&gt; <a href="http://www.python.org/peps/pep-0327.html">http://www.python.org/peps/pep-0327.html</a><br/>&gt;<br/>&gt; BTW, the educational language ABC used exact rational arithmetic by<br/>&gt; default.  So if you did 1/2 it would hold it as a ratio.  The idea was<br/>&gt; that newbie programmers didn&apos;t have to worry about the loss of precision<br/>&gt; inherent in floating point.  It turns out that engineers ran into<br/>&gt; trouble because the numbers got so large their programs became<br/>&gt; inefficient.  Usually, floating point was all they needed, or expected.<br/>&gt;   It was this experience that led Guido to drop the feature in Python.<br/>&gt; For the average programmer, floating point is less confusing.  Those who<br/>&gt; really need rationals can always find a way, and there aren&apos;t actually<br/>&gt; very many of us.</p><p>Thanks yes - an ineresting thing on that page, that even 0.2<br/>for instance has rounding errors in it as a floating point type,<br/>since the binary expansion of 1/5 is infinite recurring, like 1/7 in<br/>decimal.</p><p>Robert</p></div><h3><a id=8508 href="#8508">ðŸ”—</a>Manuel Op de Coul &#x3C;coul@...&#x3E;</h3><span>9/3/2004 3:22:04 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Who needs types when we have Turing-complete programming<br/>languages such as COW: <a href="http://www.bigzaphod.org/cow/">http://www.bigzaphod.org/cow/</a><br/>and BF: <a href="http://www.muppetlabs.com/~breadbox/bf/">http://www.muppetlabs.com/~breadbox/bf/</a><br/>:-)</p><p>Manuel</p></div><h3><a id=8509 href="#8509">ðŸ”—</a>Graham Breed &#x3C;graham@...&#x3E;</h3><span>9/3/2004 4:34:00 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Manuel Op de Coul wrote:<br/>&gt; Who needs types when we have Turing-complete programming<br/>&gt; languages such as COW: <a href="http://www.bigzaphod.org/cow/">http://www.bigzaphod.org/cow/</a><br/>&gt; and BF: <a href="http://www.muppetlabs.com/~breadbox/bf/">http://www.muppetlabs.com/~breadbox/bf/</a><br/>&gt; :-)</p><p>Sure, there&apos;s a list here:</p><p><a href="http://en.wikipedia.org/wiki/List_of_esoteric_programming_languages">http://en.wikipedia.org/wiki/List_of_esoteric_programming_languages</a></p><p>My favourites are Whitespace (which Yahoo&apos;s formatting will unfortunately destroy) and Chef, for which I&apos;ve copied the hello world:</p><p>    Ingredients.<br/>    72 g haricot beans<br/>    101 eggs<br/>    108 g lard<br/>    111 cups oil<br/>    32 zucchinis<br/>    119 ml water<br/>    114 g red salmon<br/>    100 g dijon mustard<br/>    33 potatoes</p><p>    Method.<br/>    Put potatoes into the mixing bowl.<br/>    Put dijon mustard into the mixing bowl.<br/>    Put lard into the mixing bowl.<br/>    Put red salmon into the mixing bowl.<br/>    Put oil into the mixing bowl.<br/>    Put water into the mixing bowl.<br/>    Put zucchinis into the mixing bowl.<br/>    Put oil into the mixing bowl.<br/>    Put lard into the mixing bowl.<br/>    Put lard into the mixing bowl.<br/>    Put eggs into the mixing bowl.<br/>    Put haricot beans into the mixing bowl.<br/>    Liquefy contents of the mixing bowl.<br/>    Pour contents of the mixing bowl into the baking dish.</p><p>    Serves 1.</p></div><h3><a id=8513 href="#8513">ðŸ”—</a>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>9/6/2004 10:43:32 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Robert,</p><p>&gt; Thanks for the mention of pi spigot programs. They were<br/>&gt; new to me actually.<br/>&gt;<br/>&gt; Actually what I had in mind was a digit extraction algorithm.</p><p>It isn&apos;t clear that there&apos;s any difference between &quot;spigot&quot;<br/>and &quot;digit extraction&quot; from their mathworld definitions,<br/>though they are not cross-referenced.</p><p>&gt; and more about it at the bottom of this page:<br/>&gt;<br/>&gt; <a href="http://mathworld.wolfram.com/PiFormulas.html">http://mathworld.wolfram.com/PiFormulas.html</a></p><p>This page does make it sound like there&apos;s a difference,<br/>though,</p><p>&quot;A spigot algorithm for pi is given by Rabinowitz<br/>and Wagon (1995; Borwein and Bailey 2003, pp. 141-142).<br/>More amazingly still, a closed form expression giving a<br/>digit-extraction algorithm which produces digits of pi<br/>(or pi^2) in base-16 was discovered by Bailey et al.&quot;</p><p>Here it isn&apos;t clear to me whether the digit extraction<br/>algorithm is more amazing because digit extraction is<br/>different than spigot, or because it is a &quot;closed form<br/>expression&quot;.</p><p>In any case, looks like I was wrong about Ramanujan.<br/>He calculates pi, but apparently didn&apos;t give a spigot/<br/>digit extraction algorithm for it.</p><p>&gt; Looking up the spigot programs,<br/>&gt; I find that they are streaming algorithms<br/>&gt; that let you discard earlier digits after you<br/>&gt; calculate them</p><p>This doesn&apos;t seem to agree with the mathworld<br/>definition.</p><p>&gt; But the digit extraction algorithm lets<br/>&gt; you calculate e.g. the trillionth digit of pi to base 16<br/>&gt; without ever calculating any of the earlier digits at all.<br/>&gt; Just plug in 10^12 (or 10^18 if it is an British trillion<br/>&gt; though we all use American billions and trillions nowadays)<br/>&gt; into the formula and it will give you the trillionth digit<br/>&gt; of pi to base 16, no need to wait at all, with no more<br/>&gt; calculation than that.<br/>&gt;<br/>&gt; Quite remarkable!</p><p>This is what I thought a spigot algorithm was.</p><p>-Carl</p></div><h3><a id=8514 href="#8514">ðŸ”—</a>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>9/6/2004 7:25:15 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Carl,</p><p>Yes I wondered too about the details of the distinction between<br/>a spigot algorithm and a digit extraction algorithm.</p><p>However, searching again, the start of this paper makes it all clear:</p><p><a href="http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf">http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf</a></p><p>A spigot algorithm makes the digits of pi one at a time so it would<br/>produce<br/>3, 1, 4, 1, 5, etc</p><p>but has to start from the beginning.</p><p>It starts by first putting the entire sequence in a mixed radix<br/>base into the memory - then it works through that sequence<br/>converting it to decimal. Actually I&apos;m not sure I quite<br/>understand how it does that from the paper but<br/>the outline of the procedure is clear - it involves<br/>multiplying all the digits by 10, then you<br/>truncate it to get the first digit, output that,<br/>subtract that from the sequence, and proceed in that way<br/>to convert the mixed radix sequence into decimal digits<br/>one at a time.</p><p>However, though you need to keep the terms of the<br/>original sequence all in memory you don&apos;t need<br/>to keep the digits as they are output.<br/>You can discard them after they have been found.<br/>The sequence itself I think gets smaller as you go through<br/>it truncating it and removing terms,<br/>though I don&apos;t quite understand how it works<br/>yet.</p><p>The streaming algorithms introduced by the author<br/>of that paper are a separate thing - they are like spigots<br/>except that you work along the series<br/>from left to right instead of repeatedly<br/>working from right to left and truncating,<br/>so don&apos;t need to  allocate memory for all<br/>the digits in advance. Instead you just<br/>need a small amount of memory to store<br/>a matrix, and a few numbers, and that&apos;s all,<br/>if I understand correctly.</p><p>Digit extraction however is special because it<br/>gives you the ten billionth digit<br/>and gets it far faster than any method known for generating<br/>all the first ten billion digits, and does it without<br/>the need to find any of the earlier digits<br/>(even to discard them). They just never<br/>get calculated at all.</p><p>Normal pi calculations would work using arbitrary<br/>precision arithmetic, and in order to find<br/>the thousandth digit of pi, you will need<br/>to add and multiply and so on terms<br/>that involve a thousand digits.<br/>The spigot algorithm doesn&apos;t require<br/>that - you can use ordinary limited precision<br/>arithmetic. So that&apos;s how you can have<br/>short simple c code programs that<br/>are able to output a 1000 digits of<br/>pi using only normal 32 bit precision<br/>arithmetic. Eventually you would hit a<br/>limit there as the numbers in<br/>2 + 1/3*(2 + 2/5 *(2 + 4/7* (...)))<br/>get too large for 32 bit precision, but<br/>you will be working with much smaller numbers<br/>so can go far further with ordinary limited<br/>precision arithmetic.</p><p>At least, that&apos;s the best I can make of<br/>it so far. But I&apos;m a little confused,<br/>didn&apos;t understand in that paper what<br/>the author meant when they say that<br/>{0;2,4,6,8,...} is the mixed radix<br/>representation of 2 - seemed to me<br/>that it would be infinity instead.<br/>I must be missing something. It is<br/>easy to miss some essential point when reading<br/>a paper in a field you aren&apos;t especially<br/>familiar with.</p><p>Spigot alogrithms are reasonably old,<br/>I gather from this search,<br/>though I think not quite old enough<br/>for Ramanujan to have made one,<br/>maybe fifty years old or something,<br/>but the digit extraction algorithm is<br/>much more recent, well within the last decade.</p><p>Robert</p></div><h3><a id=8515 href="#8515">ðŸ”—</a>Gene Ward Smith &#x3C;gwsmith@...&#x3E;</h3><span>9/6/2004 8:54:38 PM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:metatuning@yahoogroups.com">metatuning@yahoogroups.com</a>, &quot;Carl Lumma&quot; &lt;clumma@y...&gt; wrote:</p><p>&gt; This is what I thought a spigot algorithm was.</p><p>Stan Rabinowitz told me his spigot spits out the digits of pi, in base<br/>10, one at a time. It&apos;s short but even so has been used for writing<br/>obfuscated code--I think an obfuscated version of it won the C contest<br/>one year.</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            