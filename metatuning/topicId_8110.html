<a href="/metatuning">back to list</a><h1>Re: Penrose's argument - was Re: Digest Number 1022 was re: Belief-o-matic</h1><h3>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>7/10/2004 5:21:04 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Carl,</p><p>&gt; So in that sense he shows that<br/>&gt; no program can ever pass the<br/>&gt; turing argument in full generality.</p><p>Does that cover self-extensible programs?</p><p>Yes if it is done by adding axioms by<br/>a program that works by using an inbuilt<br/>axiom system to evaluate truth.</p><p>If it is done by some other method then<br/>you are back in the same situation<br/>as with the neural nets and expert systems<br/>that you don&apos;t know how it works, so how<br/>can you say that it understands truth<br/>or even that it will always come up with<br/>true answers.</p><p>Of course we don&apos;t know how we work either<br/>but then we are the ones asking the<br/>question and we know what truth is<br/>and are trying to find out if a computer<br/>can understand the same notion of truth<br/>as a human being.</p><p>That&apos;s enough for me anyway. But<br/>I can understand it mightn&apos;t convince<br/>depending on ones views.<br/>Maybe Roger Penrose has found<br/>more elaborate arguments to deal<br/>with them.</p><p>Even if the program is extensible,<br/>it is still a program, and provided the<br/>way it extends its programming is also<br/>programmable, the way<br/>you could do it is to consider<br/>it as data for another (quite possibly smaller)<br/>program that consists of an interpreter<br/>that interprets that program and<br/>executes its instructions (including its<br/>instructions to overwrite parts of itself<br/>or whatever it does). The interpreter<br/>+ its initialisation data all as one thing<br/>can then be considered as the program<br/>you are testing for its understanding of<br/>truth. That then is just a single<br/>fixed size thing that doesn&apos;t change its programming<br/>though the data it is using gets transformed<br/>and changed and can get increased in size<br/>etc.</p><p>So unless you say it also changes<br/>the language in which it is written<br/>as it goes on (and there is no<br/>great advantage in doing that<br/>as all computer languages are<br/>universal as far as computing is concerned)<br/>then that gives you a finite program<br/>+ data.</p><p>So, one wonders having got that<br/>far if there is some kind of diagonalisation<br/>argument that could be used to show that<br/>there exists a Godel sentence for any<br/>program, maybe even a constructive<br/>argument that can construct one.<br/>But I won&apos;t try to figure that out,<br/>I&apos;m sure Roger Penrose would have followed<br/>up that line of investigation if it can<br/>be done, at least if it can be done in<br/>any way I&apos;m likely to hit on in a<br/>short time - so I&apos;ll wait<br/>until I read Shadoes of the Mind and<br/>see if he covers it.</p><p>BTW sorry about the replies to digests<br/>- I try to remember not to do that<br/>but slip up now and again.</p><p>Robert</p></div><h3>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>7/10/2004 5:21:04 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>Hi Carl,</p><p>&gt; So in that sense he shows that<br/>&gt; no program can ever pass the<br/>&gt; turing argument in full generality.</p><p>Does that cover self-extensible programs?</p><p>Yes if it is done by adding axioms by<br/>a program that works by using an inbuilt<br/>axiom system to evaluate truth.</p><p>If it is done by some other method then<br/>you are back in the same situation<br/>as with the neural nets and expert systems<br/>that you don&apos;t know how it works, so how<br/>can you say that it understands truth<br/>or even that it will always come up with<br/>true answers.</p><p>Of course we don&apos;t know how we work either<br/>but then we are the ones asking the<br/>question and we know what truth is<br/>and are trying to find out if a computer<br/>can understand the same notion of truth<br/>as a human being.</p><p>That&apos;s enough for me anyway. But<br/>I can understand it mightn&apos;t convince<br/>depending on ones views.<br/>Maybe Roger Penrose has found<br/>more elaborate arguments to deal<br/>with them.</p><p>Even if the program is extensible,<br/>it is still a program, and provided the<br/>way it extends its programming is also<br/>programmable, the way<br/>you could do it is to consider<br/>it as data for another (quite possibly smaller)<br/>program that consists of an interpreter<br/>that interprets that program and<br/>executes its instructions (including its<br/>instructions to overwrite parts of itself<br/>or whatever it does). The interpreter<br/>+ its initialisation data all as one thing<br/>can then be considered as the program<br/>you are testing for its understanding of<br/>truth. That then is just a single<br/>fixed size thing that doesn&apos;t change its programming<br/>though the data it is using gets transformed<br/>and changed and can get increased in size<br/>etc.</p><p>So unless you say it also changes<br/>the language in which it is written<br/>as it goes on (and there is no<br/>great advantage in doing that<br/>as all computer languages are<br/>universal as far as computing is concerned)<br/>then that gives you a finite program<br/>+ data.</p><p>So, one wonders having got that<br/>far if there is some kind of diagonalisation<br/>argument that could be used to show that<br/>there exists a Godel sentence for any<br/>program, maybe even a constructive<br/>argument that can construct one.<br/>But I won&apos;t try to figure that out,<br/>I&apos;m sure Roger Penrose would have followed<br/>up that line of investigation if it can<br/>be done, at least if it can be done in<br/>any way I&apos;m likely to hit on in a<br/>short time - so I&apos;ll wait<br/>until I read Shadoes of the Mind and<br/>see if he covers it.</p><p>BTW sorry about the replies to digests<br/>- I try to remember not to do that<br/>but slip up now and again.</p><p>Robert</p></div><h3>Robert Walker &#x3C;robertwalker@...&#x3E;</h3><span>7/10/2004 5:59:35 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>HI Carl,</p><p>that got sent by accident<br/>while I was still thinking<br/>about the self-extensible program<br/>idea:</p><p>Here is that bit again:</p><p>BTW a self-extensible program<br/>is still a finite program<br/>with a fixed number of instructions<br/>if you consider it another way<br/>as data for an interpreter<br/>and consider the interpreter<br/>executing those instructions as<br/>the actual program running in a larger<br/>machine. Then the self modifying<br/>bit just becomes a particular<br/>way of modifying that data.<br/>So there is no real sharp<br/>dividing line between data and<br/>program and what you can do in<br/>a self modifying program you<br/>can do equally well using<br/>just a normal program with a<br/>finite number of instructions<br/>fixed in size and modifying<br/>data.</p><p>If you can change the programming<br/>language too as you go on that<br/>is a bit more complex, and one<br/>could imagine that being used<br/>- but it must eventually be<br/>compiled to run on some machine<br/>or other presumably, so you can<br/>then just use a software simulator<br/>of that machine as your interpreter.</p><p>If the machine can re-build itself<br/>then that gets harder - because it<br/>could deliberately or through evolution<br/>build in glitches. Eventually it<br/>might evolve into a truly aware<br/>machine I suppose, that&apos;s an idea<br/>that  gets explored in SF,</p><p>I remember a short SF story in which<br/>there is a great taboo amongst humans<br/>on ever building self replicating machines<br/>because then you could get imperfect<br/>replication and evolution and<br/>then who knows what could happen.<br/>They can copy themselves but there<br/>are always safeguards to limit how much<br/>is done - they have to go up to a human<br/>(or ET) surveyer who unlocks<br/>them so that they can replicate.</p><p>But another group of ETs not knowing and<br/>understanding the taboo (through temperament<br/>not being so interested in robot technology<br/>as much as humans are) buy some of the<br/>human robots and remove the safeguards<br/>to make it easier to construct lots of them.</p><p>By the time humans find out what they<br/>have done it is too late to do anything<br/>about it - and the story just leaves you<br/>hanging wondering what happened next.</p><p>Just a short story, in one of the series<br/>in a future universe idea set up by Asimov<br/>as a context for stories written by others<br/>- can&apos;t reemmber the name now though.</p><p>BTW sorry about the replies to digests<br/>- I try to remember not to do that<br/>but slip up now and again.</p><p>Robert</p></div><h3>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>7/10/2004 9:44:23 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; &gt; So in that sense he shows that<br/>&gt; &gt; no program can ever pass the<br/>&gt; &gt; turing argument in full generality.<br/>&gt;<br/>&gt; Does that cover self-extensible programs?<br/>&gt;<br/>&gt; Yes if it is done by adding axioms by<br/>&gt; a program that works by using an inbuilt<br/>&gt; axiom system to evaluate truth.</p><p>Hmm... sounds right.</p><p>&gt; If it is done by some other method then<br/>&gt; you are back in the same situation<br/>&gt; as with the neural nets and expert systems<br/>&gt; that you don&apos;t know how it works, so how<br/>&gt; can you say that it understands truth<br/>&gt; or even that it will always come up with<br/>&gt; true answers.</p><p>You can say that they understand truth in<br/>the same way you can say other humans<br/>understand truth: by observing their behavior.</p><p>&gt; Of course we don&apos;t know how we work either<br/>&gt; but then we are the ones asking the<br/>&gt; question and we know what truth is<br/>&gt; and are trying to find out if a computer<br/>&gt; can understand the same notion of truth<br/>&gt; as a human being.<br/>&gt;<br/>&gt; That&apos;s enough for me anyway. But<br/>&gt; I can understand it mightn&apos;t convince<br/>&gt; depending on ones views.</p><p>Yes: functional isomorphism is enough<br/>for me.</p><p>&gt; So unless you say it also changes<br/>&gt; the language in which it is written<br/>&gt; as it goes on (and there is no<br/>&gt; great advantage in doing that<br/>&gt; as all computer languages are<br/>&gt; universal as far as computing is concerned)<br/>&gt; then that gives you a finite program<br/>&gt; + data.</p><p>Yes.  But it might still be the case that<br/>G today is no longer G tomorrow.</p><p>-Carl</p></div><h3>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>7/10/2004 9:57:45 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; HI Carl,<br/>&gt;<br/>&gt; that got sent by accident<br/>&gt; while I was still thinking<br/>&gt; about the self-extensible program<br/>&gt; idea:</p><p>Oops!  I&apos;ve already replied.  I&apos;ll<br/>play catch-up here...</p><p>&gt; BTW a self-extensible program<br/>&gt; is still a finite program<br/>&gt; with a fixed number of instructions</p><p>Yes, it is finite at any point in<br/>time.</p><p>&gt; If the machine can re-build itself<br/>&gt; then that gets harder - because it<br/>&gt; could deliberately or through evolution<br/>&gt; build in glitches.</p><p>It doesn&apos;t need to rebuild itself to<br/>get glitches.  Turing machines already<br/>have access to the most random<br/>behaviors known.</p><p>&gt; I remember a short SF story in which<br/>&gt; there is a great taboo amongst humans<br/>&gt; on ever building self replicating machines<br/>&gt; because then you could get imperfect<br/>&gt; replication and evolution and<br/>&gt; then who knows what could happen.<br/>&gt; They can copy themselves but there<br/>&gt; are always safeguards to limit how much<br/>&gt; is done - they have to go up to a human<br/>&gt; (or ET) surveyer who unlocks<br/>&gt; them so that they can replicate.</p><p>Our cells do have telomeres, which limit<br/>the number of times they can divide.<br/>It&apos;s believed to have evolved as an anti-<br/>cancer measure, though I&apos;m not sure if it<br/>works in all cases.</p><p>&gt; But another group of ETs not knowing and<br/>&gt; understanding the taboo (through temperament<br/>&gt; not being so interested in robot technology<br/>&gt; as much as humans are) buy some of the<br/>&gt; human robots and remove the safeguards<br/>&gt; to make it easier to construct lots of them.<br/>&gt;<br/>&gt; By the time humans find out what they<br/>&gt; have done it is too late to do anything<br/>&gt; about it - and the story just leaves you<br/>&gt; hanging wondering what happened next.</p><p>Cool!</p><p>-Carl</p></div><h3>Paul Erlich &#x3C;PERLICH@...&#x3E;</h3><span>7/10/2004 10:09:36 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:metatuning@yahoogroups.com">metatuning@yahoogroups.com</a>, &quot;Carl Lumma&quot; &lt;clumma@y...&gt; wrote:</p><p>&gt; Turing machines already<br/>&gt; have access to the most random<br/>&gt; behaviors known.</p><p>They do? Can you elaborate? I thought quantum phenomena, like<br/>radioactive decay, were the most random behaviors known. I thought<br/>there were no algorithms that generate this level of randomness,<br/>unless you count Chaitin&apos;s.</p></div><h3>Gene Ward Smith &#x3C;gwsmith@...&#x3E;</h3><span>7/10/2004 10:48:22 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>--- In <a href="mailto:metatuning@yahoogroups.com">metatuning@yahoogroups.com</a>, &quot;Paul Erlich&quot; &lt;PERLICH@A...&gt; wrote:<br/>&gt; --- In <a href="mailto:metatuning@yahoogroups.com">metatuning@yahoogroups.com</a>, &quot;Carl Lumma&quot; &lt;clumma@y...&gt; wrote:<br/>&gt;<br/>&gt; &gt; Turing machines already<br/>&gt; &gt; have access to the most random<br/>&gt; &gt; behaviors known.<br/>&gt;<br/>&gt; They do? Can you elaborate? I thought quantum phenomena, like<br/>&gt; radioactive decay, were the most random behaviors known. I thought<br/>&gt; there were no algorithms that generate this level of randomness,<br/>&gt; unless you count Chaitin&apos;s.</p><p>&quot;Anyone who considers arithmetical methods of producing random digits<br/>is, of course, in a state of sin.&quot;<br/>-- John Von Neumann, 1951</p></div><h3>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>7/11/2004 12:19:35 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; &gt; Turing machines already have access to the most random<br/>&gt; &gt; behaviors known.<br/>&gt;<br/>&gt; They do? Can you elaborate? I thought quantum phenomena, like<br/>&gt; radioactive decay, were the most random behaviors known. I<br/>&gt; thought there were no algorithms that generate this level of<br/>&gt; randomness, unless you count Chaitin&apos;s.</p><p>Chaitin&apos;s stuff is the most random stuff there *isn&apos;t*.  He<br/>defines things so random, they&apos;re uncomputable.  In fact the<br/>act of computing them would make them known, and therefore<br/>less random in some sense.  There&apos;s an astoundingly beautiful<br/>result that&apos;s like Godel&apos;s, but based on the Berry paradox<br/>instead of the Russell paradox.  He defines a number that&apos;s<br/>too short to speak of!</p><p>-Carl</p></div><h3>Carl Lumma &#x3C;clumma@...&#x3E;</h3><span>7/11/2004 1:19:04 AM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>&gt; &gt; Turing machines already have access to the most random<br/>&gt; &gt; behaviors known.<br/>&gt;<br/>&gt; They do? Can you elaborate? I thought quantum phenomena,<br/>&gt; like radioactive decay, were the most random behaviors<br/>&gt; known. I thought there were no algorithms that generate<br/>&gt; this level of randomness, unless you count Chaitin&apos;s.</p><p>Not according to Wolfram.  He compares various empirical<br/>sources of randomness to Rule 30 (as well as some more<br/>well-known algorithmic methods that are embarassingly<br/>poor!).  Including:</p><p>() Electronic noise<br/> () thermal (Johnson) noise<br/> () shot noise<br/> () flicker (1/f) noise<br/>() Mechanical randomness<br/> () dice<br/> () roulette wheels<br/>() Quantum randomness<br/> &quot;It is usually assumed that even if all else fails a<br/>quantum process such as radioactive decay will yield<br/>perfect randomness.  But in practice the most accurate<br/>measurements show phenomena such as 1/f noise,<br/>presumably as a result of features of the detector and<br/>perhaps of electromagnetic fields associated with decay<br/>products.  Acceptable randomness has however been<br/>obtained at rates of tens of bits per second.  Recent<br/>attempts have also been made to produce quantum<br/>randomness at megahertz rates by detecting paths of<br/>single photons.&quot;<br/>He&apos;s referring here to Bell-inequality-violating<br/>experiments...<br/>&quot;In ordinary quantum theory, a straightforward calculation<br/>implies that the expected value of the product of the two<br/>measured spin values will be -Cos[theta].  But now imagine<br/>instead that when each photen is produced it is assigned<br/>a &quot;hidden variable&quot; Phi that in effect explicitly specifies<br/>the angle of its polarization.  Then assume that a polarizer<br/>oriented at 0deg. will measure the spin of such a photon to<br/>have value f[Phi] for some fixed function f.  Now the<br/>expected value of the product of the two measured spin<br/>values is found just by averaging over Phi as<br/> Integrate[f[Phi]f[theta-Phi], {Phi, 0, 2Pi}]/(2Pi)<br/>A version of Bell&apos;s inequalities is then that this integral<br/>can decrease with theta no faster than theta/(2Pi)-1 -- as<br/>achieved when f = Sign (in 3-D Phi must be extended to a<br/>sphere, but the same final result holds).  Yet as mentioned<br/>on pg. 1058, acutal experiments show that in fact the<br/>decrease with theta is mor rapid -- and is instead consistent<br/>with the quantum theory result -Cos[theta].  So what this<br/>means is that there is in a sense more correlation between<br/>measurements made on separated photons than can apparently<br/>be explained by the individual photons carrying some kind<br/>of hidden property.  (In the standard formalism of quantum<br/>theory this is normally explained by saying that the two<br/>photons can only meaningfully be considered as part of a<br/>single &quot;entangled&quot; state.  Note that because of the<br/>probabilistic nature of the correlations it turns out to<br/>be impossible to use them to do anything that would<br/>normally be considered communicating information faster<br/>than the speed of light.)<br/>A basic assumption in deriving Bell&apos;s inequalities is<br/>that the choice of polarizer angle for measuring one<br/>photon is not affected by the choice of&quot;. . .</p><p>Hey, I forgot, the book is now online!</p><p><a href="http://www.wolframscience.com/nksonline/page-1065">http://www.wolframscience.com/nksonline/page-1065</a></p><p>You&apos;ll need to register, though.</p><p>Of course, he seldom gives references to back up his<br/>claims.  And he uses an annoying number of self-<br/>references -- wormholes in the book.  He obviously<br/>tagged sections with variables that were later replaced<br/>with page numbers once the book was complete.  I think<br/>programs like Lynx let you do this, but Wolfram<br/>apparently used Mathematica.</p><p>In short, Wolfram says that there&apos;s ultimately only one<br/>source for randomness, and that&apos;s &quot;intrinsic randomness<br/>generation&quot; (which I attempted to characterize in a<br/>previous post).  He accuses randomness in chaotic systems<br/>of having been injected in the initial conditions.  And<br/>where there really is randomness being observed, he<br/>thinks its source is intrinsic randomness generation.</p><p>One prediction of such a position is that where one does<br/>observe randomness in nature, one might occasionally<br/>expect to see the same random sequence occurring again.<br/>In fact Wolfram suggests the morphology of turbulent<br/>flows (among other things) provides an example of this.</p><p>However, he says empirical sources of randomness are<br/>generally poor in quality because whatever intrinsic<br/>random generation is going on underneath is degraded<br/>by correlations stemming from things like conservation<br/>laws.  For example, after a spark crosses between two<br/>plates, effects to the medium between the plates make<br/>it less (or more) likely that a spark will travel that<br/>path at subsequent times.</p><p>Just don&apos;t go trying to *prove* that certain numbers<br/>are random -- you get into all kinds of trouble.  Mainly,<br/>you need about as many bits of axioms as it takes to<br/>write the number you&apos;re trying to prove is random.</p><p>-Carl</p></div>