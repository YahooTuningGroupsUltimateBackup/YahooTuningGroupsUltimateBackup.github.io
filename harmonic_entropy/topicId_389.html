<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup harmonic_entropy Re: Eureka part one (actually, complexity measures)</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/harmonic_entropy">back to list</a><h1>Re: Eureka part one (actually, complexity measures)</h1><h3><a id=389 href="#389">ðŸ”—</a>Robert C Valentine &#x3C;BVAL@...&#x3E;</h3><span>5/9/2001 12:56:27 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>I only included &quot;Eureka part I&quot; because I&apos;m waiting for Paul<br/>and other mathematically inclined list members to decode that<br/>paper for me.</p><p>As members of the tuning list know, I&apos;ve been working on<br/>a program which</p><p>   1) inputs a scale described as a sequence of step-sizes<br/>         (for instance BBaBBBa which would be the familar<br/>          12tet Ionian when B=200 and a=50 cents)(currently<br/>          limited to diatonics but later will be extended<br/>          to more notes...)<br/>   2) constructs some sort of psuedo-harmonic-entropy<br/>          table (more later)<br/>   3) for all values of B and a (the scale must add up to<br/>          1200c and be monotonically increasing)<br/>   3b)  for all modes (rotations) of the scale<br/>   3c)    calculate complexity, accuracy, maximum error<br/>             and other good stuff against the table of<br/>             RI and complexity generated in step 2<br/>   4) take output into excel and ooo and ahhh when sensible<br/>          results appear (like 204c being the &apos;best&apos; B for<br/>          the Ionian, followed by 194c), or (more likely)<br/>          say &quot;now why did that happen?&quot; when the local<br/>          minimum is occupied by a scale with some<br/>          extremely spicy RI intervals or (more puzzling),<br/>          overly out-of-tune simple intervals. (&quot;now why<br/>          did that happen&quot; is much more common than<br/>          &quot;eureka&quot; even though the results may be the<br/>          same).<br/>   5) see if interesting candidates can be used musically<br/>          (this stage takes a the rest of ones life)</p><p>Okay, so one thing that is interesting for input from this<br/>list is &apos;step 2&apos;. Paul has produced his lovely graphs, and<br/>from the documentation I down;oaded, I couldn&apos;t figure out<br/>a hack that produced similar ones.</p><p>Thats okay, I&apos;m an engineer, not a mathematician. If I can<br/>hack a solution that produces &apos;good enough&apos; results (like<br/>the 204c and 194c mentioned above) then I have something I<br/>can feel good about investigating.</p><p>SO the current mechanism to populate the graph is to<br/>perform a complexity calculation for all RI intervals<br/>in the known universe. If it is less complex than the<br/>current entry in the table, it takes over the RI that<br/>is in that spot. A linear factor is applied to the<br/>complexity two build the two sides of the bucket from this<br/>point (actually an inverted cone). As long as it is less<br/>than the value in the table, the RI value that lived there<br/>with a certain complexity is REPLACED, with its complexity,<br/>by the new RI value. So for instance, when adding 3/2 it<br/>would look like</p><p>bucket    bucket<br/>from      from<br/>1/1       3/2<br/>      / \<br/>     /   \<br/>    /     \      /<br/>   /       \    /<br/>  /         \  /<br/> /           \/<br/>/<br/>------------------------------<br/>The result of this is a very bumpy graph, but one I&apos;ve<br/>coerced into what I considered acceptable behvior. (The<br/>main tuning was to get the 3/2 constrained to +-18c which<br/>I&apos;d seen as proposed limits on the tuning list. Once I got<br/>it so that this became a local maximum between 3/2 and its<br/>neighbor RI, then I was satisfied).</p><p>So, firstly, I believe that to produce something more like<br/>Pauls HE graph I would sum at each point, rather than taking<br/>minimum, while still using the existing technique to identify<br/>the identity of the RI at that point on the graph?</p><p>Regarding the complexity calculation. I am currently just<br/>using the product, with a pinch of fudging to favor otonal<br/>relationships</p><p>   complexity = numerator * denominator<br/>   if ( is_power_of_2( denominator )<br/>     complexity = complexity / 2</p><p>This moves 5/4 below 4/3 and 5/3. In point of fact, leaving<br/>out the otonal &apos;correction&apos; does not have much affect on the<br/>final results once all rotations are considered. It may have<br/>a more result on the modal minimums, which are also<br/>interesting, but which I&apos;m not looking at for now until I<br/>feel &apos;better&apos; about the basic algorithm.</p><p>Oh, an IMPORTANT point (probably THE most important) is the<br/>data culling. Originally, I would sum the complexity read<br/>out of the graph and look for local minimum there. Although<br/>this sort of worked, it was apparent that sometimes, there<br/>were nearby neighbors which actually appeared to be<br/>preferable (by having less average error from the same RI<br/>intervals for instance). What I currently do is just use the<br/>psuedo-harmonic-entropy-graph to determine what the RI pockets<br/>are. Then I take the complexity based on the RI intervals<br/>played &apos;perfectly&apos;, then the error of this scale from the RI<br/>scale, and also the standard deviation of the error. (maximum<br/>error is important and will eventually be used in some sort<br/>of consistency sense to weed out scales which &apos;are not doing<br/>what they say they are doing&apos;).</p><p>The point here is that harmonic entropy mixes complexity of<br/>the intervals being heard and the accuracy that they are being<br/>produced at. Until I feel that I am mixing them in a sensible<br/>manner, I&apos;ll get more trustworthy results by seperating them.</p><p>SOmething that came up on the other list, and is also something<br/>to consider here, is ways to make my algorithm produce results<br/>which are more &apos;lattice-like&apos;. This may be an interesting are<br/>for harmonic entropy anyhow, as I believe that the 9/8 pocket<br/>SHOULD be deeper than the 8/7 or 10/9, although if this opens<br/>a debate that can be settled by creating this structure with a<br/>different name, I&apos;m all for it.</p><p>SO (engineer, not scientist) a complexity measure that I<br/>posed in the other list was to consider both the prime factors<br/>and the distance on the lattice (exponents). For instance,<br/>just the product of these would be</p><p>81/64 = 3^4/2^6 =&gt; 3*4*2*6 = 144</p><p>The case I had which this seemed to solve was that 19/15 at<br/>409c swallowed (for better or worse) the 81/64 at 408. Although<br/>pythagorean major scales came out as a minimum in the program,<br/>the fact that they report the third as 19/15 suggests a useage<br/>model that may be misleading.</p><p>There may be other good means here.</p><p>3*2* (4*6)^(1/2) uses a more accurate distance metric (2 comes<br/>from the number of dimensions one is travelling) and</p><p>3*2* (4+6) uses more of a manhatten distance.</p><p>I haven&apos;t addresses octave equivalence here, and thats<br/>important. A later thing to investigate may be multi-octave<br/>scales, which will need some notion of multi-octave.</p><p>Any tips and advice? Questions? etc????</p><p>Bob Valentine</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            