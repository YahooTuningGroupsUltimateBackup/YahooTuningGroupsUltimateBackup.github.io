<!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
                <meta name="viewport"
            content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
                <meta http-equiv="x-ua-compatible" content="ie=edge">
                <title>Yahoo Tuning Groups Ultimate Backup harmonic_entropy PSLQ in Yacas and MuPAD</title>
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            </head>
            <body>
            </body>
            </html>
        <a href="/harmonic_entropy">back to list</a><h1>PSLQ in Yacas and MuPAD</h1><h3><a id=384 href="#384">ðŸ”—</a>Pierre Lamothe &#x3C;plamothe@...&#x3E;</h3><span>5/1/2001 1:03:02 AM</span><button style="float: right; margin-right: 20px">toggle monospace</button><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'><p>-------------<br/>PSLQ in Yacas<br/>-------------</p><p>Reference : pslq<br/>            <a href="http://proteus-yacas-windows-21feb2001.zip">proteus-yacas-windows-21feb2001.zip</a><br/>            &lt;<a href="http://www.xs4all.nl/~apinkus/backups/">http://www.xs4all.nl/~apinkus/backups/</a>&gt;</p><p>See &lt;<a href="http://www.xs4all.nl/~apinkus/infoindex.html">http://www.xs4all.nl/~apinkus/infoindex.html</a>&gt;</p><p>-- See attached forward <a href="http://pslq.mu">pslq.mu</a><br/>      (pslq algorithm source written out in MuPAD code) --</p><p>/**************************************************************************#<br/>#                       The PSLQ Integer Relation Algorithm                #<br/>#                                                                          #<br/># Aut.: Helaman R.P. Ferguson and David Bailey &quot;A Polynomial               #<br/>#       Time, Numerically Stable Integer Relation Algorithm&quot;               #<br/>#       (RNR Technical Report RNR-92-032)    helaman@...             #<br/># Ref.: David Bailey and Simon Plouffe &quot;Recognizing Numerical Constants&quot;   #<br/>#       dbailey@...                                               #<br/># Cod.: Raymond Manzoni  raymman@...                          #<br/>#**************************************************************************#<br/># Creation:97/11                    #<br/># New termination criteria:97/12/15 #<br/># this code is free...              #</p><p>Ported to Yacas 2000 Ayal Pinkus.</p><p>Given a list of constants x find coefficients sol[i] such that<br/>      sum(sol[i]*x[i], i=1..n) = 0    (where n=Length(x))</p><p>    x is the list of real expressions<br/>          N(x[i]) must evaluate to floating point numbers!<br/>    precision is the number of digits needed for completion;<br/>          must be greater or equal to log10(max(sol[i]))*n<br/>    returns the list of solutions with initial precision<br/>          and the confidence (the lower the better)</p><p>    Example:</p><p>    In&gt; Pslq({2*Pi-4*Exp(1),Pi,Exp(1)},20)<br/>    Out&gt; {1,-2,4};</p><p>*/</p><p>Pslq(x, precision) :=<br/>[<br/>  Local (ndigits, gam, A, B, H, n, i, j, k, s, y, tmp, t, m, maxi, gami,<br/>&#x9; t0, t1, t2, t3, t4, mini, Confidence, norme,result);<br/>  n:=Length(x);<br/>  ndigits:=GetPrecision();<br/>  Precision(precision+2);<br/>  Confidence:=10^(-MathFloor(N(Eval(precision/3))));<br/>  gam:=N(Sqrt(4/3));<br/>  For (i:=1, i&lt;=n,i++) x[i]:=N(x[i]);</p><p>  A:=Identity(n); /*A and B are of Integer type*/<br/>  B:=Identity(n); /*but this doesn&apos;t speed up*/<br/>  s:=ZeroVector(n);<br/>  y:=ZeroVector(n);</p><p>  For(k:=1,k&lt;=n,k++)<br/>  [<br/>    tmp:=0;<br/>    For (j:=k,j&lt;=n,j++) tmp:=tmp + x[j]^2;<br/>    s[k]:=N(Eval(Sqrt(tmp)));<br/>  ];<br/>  tmp:=s[1];<br/>  For (k:= 1,k&lt;= n,k++)<br/>  [<br/>    y[k]:=N(Eval(x[k]/tmp));<br/>    s[k]:=N(Eval(s[k]/tmp));<br/>  ];<br/>  H:=ZeroMatrix(n, n-1);</p><p>  For (i:=1,i&lt;= n,i++)<br/>  [</p><p>    if (i &lt;= n-1)  [ H[i][i]:=s[i + 1]/s[i]; ];<br/>    For (j:= 1,j&lt;=i-1,j++)<br/>    [<br/>      H[i][j]:= -(y[i]*y[j])/(s[j]*s[j + 1]);<br/>    ];<br/>  ];</p><p>  For (i:=2,i&lt;=n,i++)<br/>  [<br/>    For (j:=i-1,j&gt;= 1,j--)<br/>    [<br/>      t:=Round(H[i][j]/H[j][j]);<br/>      y[j]:=y[j] + t*y[i];<br/>      For (k:=1,k&lt;=j,k++) [ H[i][k]:=H[i][k]-t*H[j][k]; ];<br/>      For (k:=1,k&lt;=n,k++)<br/>      [<br/>        A[i][k]:=A[i][k]-t*A[j][k];<br/>        B[k][j]:=B[k][j] + t*B[k][i];<br/>      ];<br/>    ];<br/>  ];<br/>  Local(found);<br/>  found:=False;</p><p>  While (Not(found))<br/>  [<br/>    m:=1;<br/>    maxi:=N(gam*Abs(H[1][1]));<br/>    gami:=gam;<br/>    For (i:= 2,i&lt;= n-1,i++)<br/>    [<br/>      gami:=gami*gam;<br/>      tmp:=N(gami*Abs(H[i][i]));<br/>      if (maxi &lt; tmp)<br/>      [<br/>        maxi:=tmp;<br/>        m:=i;<br/>      ];<br/>    ];<br/>    tmp:=y[m + 1];<br/>    y[m + 1]:=y[m];<br/>    y[m]:=tmp;<br/>    For (i:= 1,i&lt;=n,i++)<br/>    [<br/>      tmp:=A[m + 1][ i];<br/>      A[m + 1][ i]:=A[m][ i];<br/>      A[m][ i]:=tmp;<br/>      tmp:=B[i][ m + 1];<br/>      B[i][ m + 1]:=B[i][ m];<br/>      B[i][ m]:=tmp;<br/>    ];<br/>    For (i:=1,i&lt;=n-1,i++)<br/>    [<br/>      tmp:=H[m + 1][ i];<br/>      H[m + 1][ i]:=H[m][ i];<br/>      H[m][ i]:=tmp;<br/>    ];<br/>    if (m &lt; n-1)<br/>    [<br/>      t0:=N(Eval(Sqrt(H[m][ m]^2 + H[m][ m + 1]^2)));<br/>      t1:=H[m][ m]/t0;<br/>      t2:=H[m][ m + 1]/t0;<br/>      For (i:=m,i&lt;=n,i++)<br/>      [<br/>        t3:=H[i][ m];<br/>        t4:=H[i][ m + 1];<br/>        H[i][ m]:=t1*t3 + t2*t4;<br/>        H[i][ m + 1]:= -t2*t3 + t1*t4;<br/>      ];<br/>    ];<br/>    For (i:= 1,i&lt;= n,i++)<br/>    [<br/>      For (j := Min(i-1, m + 1),j&gt;= 1,j--)<br/>      [<br/>        t:=Round(H[i][ j]/H[j][ j]);<br/>        y[j]:=y[j] + t*y[i];<br/>        For (k:=1,k&lt;=j,k++) H[i][ k]:=H[i][ k]-t*H[j][ k];<br/>        For (k:= 1,k&lt;=n,k++)<br/>        [<br/>          A[i][ k]:=A[i][ k]-t*A[j][ k];<br/>          B[k][ j]:=B[k][ j] + t*B[k][ i];<br/>        ];<br/>      ];<br/>    ];<br/>    /* Precision(10);*/ /*low precision*/<br/>    maxi := (H[1] .  H[1]);<br/>    For (j:=2,j&lt;=n,j++)<br/>    [<br/>      tmp:=(H[j] . H[j]);<br/>      if (maxi &lt; tmp) [ maxi:=tmp; ];<br/>    ];<br/>    norme:=N(Eval(1/Sqrt(maxi)));<br/>    m:=1;<br/>    mini:=N(Eval(Abs(y[1])));<br/>    maxi:=mini;<br/>    For (j:=2,j&lt;=n,j++)<br/>    [<br/>      tmp:=N(Eval(Abs(y[j])));<br/>      if (tmp &lt; mini)<br/>      [<br/>        mini:=tmp;<br/>        m:=j;<br/>      ];<br/>      if (tmp &gt; maxi) [ maxi:=tmp; ];<br/>    ];<br/>    /* following line may be commented */<br/>/*    Echo({&quot;Norm bound:&quot;,norme,&quot; Min=&quot;,mini,&quot; Conf=&quot;,mini/maxi}); */<br/>    if ((mini/maxi) &lt; Confidence) /*prefered to : if mini &lt; 10^(-<br/>precision) then*/<br/>    [<br/>    /* following line may be commented */<br/>/*      Echo({&quot;Found with Confidence &quot;,mini/maxi}); */<br/>      Precision(ndigits);<br/>      result:=Transpose(B)[m];<br/>      found:=True;<br/>    ]<br/>    else<br/>    [<br/>      maxi:=Abs(A[1][ 1]);<br/>      For (i:=1,i&lt;=n,i++)<br/>      [<br/>        For (j:=1,j&lt;=n,j++)<br/>        [<br/>          tmp:=Abs(A[i][ j]);<br/>          if (maxi &lt; tmp) [ maxi:=tmp;];<br/>        ];<br/>      ];<br/>      if (maxi &gt; 10^(precision))<br/>      [<br/>        Precision(ndigits);<br/>        result:=Fail;<br/>        found:=True;<br/>      ];<br/>      Precision(precision+2);<br/>    ];<br/>  ];<br/>  result;<br/>];</p><p>/* end of file */</p><p>-------------<br/>PSLQ in MuPAD<br/>-------------</p><p>Ayal Pinkus wrote (private e-mail)</p><p>&lt;&lt; I found this piece of code in the MuPAD scripts. Please<br/>   find attached the relevant file, <a href="http://pslq.mu">pslq.mu</a>, which is the<br/>   pslq algorithm written out in MuPAD code. It states<br/>   explicitly that it is free &gt;&gt;</p><p>file <a href="http://pslq.mu">pslq.mu</a></p><p>//***************************************************************************<br/>//                       The PSLQ Integer Relation Algorithm</p><p>//</p><p>// Aut.: Helaman R.P. Ferguson and David Bailey &quot;A Polynomial Time,<br/>//       Numerically Stable<br/>//       Integer Relation Algorithm&quot; (RNR Technical Report RNR-92-032)<br/>//       helaman@...<br/>// Ref.: David Bailey and Simon Plouffe &quot;Recognizing Numerical Constants&quot;<br/>//       dbailey@...<br/>// Cod.: Raymond Manzoni  raymman@...</p><p>//****************************************************************************<br/>// Creation:97/11<br/>// New termination criteria:97/12/15<br/>// this code is free...</p><p>/*++ Given a list of constants x find coefficients sol[i] such that<br/>      sum(sol[i]*x[i], i=1..n) = 0    (where n=nops(x))</p><p>    x is the list of real expressions<br/>          float(x[i]) must evaluate to numeric type!<br/>    precision is the number of digits needed for completion;<br/>          must be greater or equal to log10(max(sol[i]))*n<br/>    returns the list of solutions with initial precision<br/>          and the confidence (the lower the better)</p><p>    Example:</p><p>    &gt;&gt; pslq([2*PI+E,PI,E],20);</p><p>            Found with Confidence , 1.4780013e-28<br/>                        +-         -+<br/>                        | 1, -2, -1 |<br/>                        +-         -+<br/>++*/</p><p>misc::pslq:=<br/>proc(x:DOM_LIST, precision:Type::PosInt)<br/>  local ndigits, gam, A, B, H, n, i, j, k, s, y, tmp, t, m, maxi, gami,<br/>&#x9; t0, t1, t2, t3, t4, mini, Confidence, norme, MExpr;<br/>  save DIGITS;<br/>begin<br/>  MExpr:=Dom::Matrix();<br/>  n:=nops(x);<br/>  ndigits:=DIGITS;<br/>  DIGITS:=precision+2;<br/>  Confidence:=10^(-floor(precision/3));<br/>  gam:=float(sqrt(4/3));<br/>  for i from 1 to n do<br/>    x[i]:=float(x[i]);<br/>    if not testtype(x[i], Type::Real)=TRUE then<br/>      error(&quot;List must consist of real numbers&quot;)<br/>    end_if<br/>  end_for;<br/>  A:=MExpr(n, n, 1, Diagonal); //A and B are of Integer type<br/>  B:=MExpr(n, n, 1, Diagonal); //but this doesn&apos;t speed up<br/>  s:=MExpr(n, 1);<br/>  y:=MExpr(n, 1);<br/>  for k from 1 to n do<br/>    tmp:=0;<br/>    for j from k to n do<br/>      tmp:=tmp + x[j]^2<br/>    end_for;<br/>    s[k]:=sqrt(tmp)<br/>  end_for;<br/>  tmp:=s[1];<br/>  for k from 1 to n do<br/>    y[k]:=x[k]/tmp;<br/>    s[k]:=s[k]/tmp<br/>  end_for;<br/>  H:=MExpr(n, n-1);<br/>  for i from 1 to n do<br/>    if i &lt;= n-1 then<br/>      H[i, i]:=s[i + 1]/s[i]<br/>    end_if;<br/>    for j from 1 to i-1 do<br/>      H[i, j]:=-(y[i]*y[j])/(s[j]*s[j + 1])<br/>    end_for<br/>  end_for;<br/>  for i from 2 to n do<br/>    for j from i-1 downto 1 do<br/>      t:=round(H[i, j]/H[j, j]);<br/>      y[j]:=y[j] + t*y[i];<br/>      for k from 1 to j do<br/>        H[i, k]:=H[i, k]-t*H[j, k]<br/>      end_for;<br/>      for k from 1 to n do<br/>        A[i, k]:=A[i, k]-t*A[j, k];<br/>        B[k, j]:=B[k, j] + t*B[k, i]<br/>      end_for<br/>    end_for<br/>  end_for;<br/>  while TRUE do<br/>    m:=1;<br/>    maxi:=float(gam*abs(H[1, 1]));<br/>    gami:=gam;<br/>    for i from 2 to n-1 do<br/>      gami:=gami*gam;<br/>      tmp:=float(gami*abs(H[i, i]));<br/>      if maxi &lt; tmp then<br/>        maxi:=tmp;<br/>        m:=i<br/>      end_if<br/>    end_for;<br/>    tmp:=y[m + 1];<br/>    y[m + 1]:=y[m];<br/>    y[m]:=tmp;<br/>    for i from 1 to n do<br/>      tmp:=A[m + 1, i];<br/>      A[m + 1, i]:=A[m, i];<br/>      A[m, i]:=tmp;<br/>      tmp:=B[i, m + 1];<br/>      B[i, m + 1]:=B[i, m];<br/>      B[i, m]:=tmp<br/>    end_for;<br/>    for i from 1 to n-1 do<br/>      tmp:=H[m + 1, i];<br/>      H[m + 1, i]:=H[m, i];<br/>      H[m, i]:=tmp<br/>    end_for;<br/>    if m &lt; n-1 then<br/>      t0:=sqrt(H[m, m]^2 + H[m, m + 1]^2);<br/>      t1:=H[m, m]/t0;<br/>      t2:=H[m, m + 1]/t0;<br/>      for i from m to n do<br/>        t3:=H[i, m];<br/>        t4:=H[i, m + 1];<br/>        H[i, m]:=t1*t3 + t2*t4;<br/>        H[i, m + 1]:=-t2*t3 + t1*t4<br/>      end_for<br/>    end_if;<br/>    for i from 1 to n do<br/>      for j from min(i-1, m + 1) downto 1 do<br/>        t:=round(H[i, j]/H[j, j]);<br/>        y[j]:=y[j] + t*y[i];<br/>        for k from 1 to j do<br/>          H[i, k]:=H[i, k]-t*H[j, k]<br/>        end_for;<br/>        for k from 1 to n do<br/>          A[i, k]:=A[i, k]-t*A[j, k];<br/>          B[k, j]:=B[k, j] + t*B[k, i]<br/>        end_for<br/>      end_for<br/>    end_for;<br/>    DIGITS:=8; //low precision<br/>    maxi := linalg::scalarProduct(linalg::row(H, 1), linalg::row(H, 1));<br/>    for j from 2 to n do<br/>      tmp:=linalg::scalarProduct(linalg::row(H, j), linalg::row(H, j));<br/>      if maxi &lt; tmp then<br/>        maxi:=tmp<br/>      end_if<br/>    end_for;<br/>    norme:=1/sqrt(maxi);<br/>    m:=1;<br/>    mini:=float(abs(y[1]));<br/>    maxi:=mini;<br/>    for j from 2 to n do<br/>      tmp:=float(abs(y[j]));<br/>      if tmp &lt; mini then<br/>        mini:=tmp;<br/>        m:=j<br/>      end_if;<br/>      if tmp &gt; maxi then<br/>        maxi:=tmp;<br/>      end_if<br/>    end_for;<br/>    // following line may be commented<br/>    userinfo(5,&quot;Norm bound:&quot;.expr2text(norme).&quot; Min=&quot;.expr2text(mini).<br/>&#x9;&#x9;&quot; Conf=&quot;.expr2text(mini/maxi));<br/>    if (mini/maxi) &lt; Confidence then   //prefered to : if mini &lt; 10^(-<br/>precision) then<br/>      userinfo(5,&quot;Found with Confidence &quot;.expr2text(mini/maxi));<br/>      DIGITS:=ndigits;<br/>      linalg::transpose(linalg::col(B, m));<br/>      break<br/>    end_if;<br/>    maxi:=abs(A[1, 1]);<br/>    for i from 1 to n do<br/>      for j from 1 to n do<br/>        tmp:=abs(A[i, j]);<br/>        if maxi &lt; tmp then<br/>          maxi:=tmp<br/>        end_if<br/>      end_for<br/>    end_for;<br/>    if maxi &gt; 10^(precision) then<br/>      DIGITS:=ndigits;<br/>      return(FAIL)<br/>    end_if;<br/>    DIGITS:=precision+2;<br/>  end_while;<br/>end_proc:</p><p>// end of file</p></div>
                <script>
                    let monospace = false
                    $('button').on('click', function () {
                      if (monospace) {
                        $('p').css("font-family", "")
                      } else {
                        $('p').css("font-family", "monospace")
                      }
                      monospace = !monospace
                    })
                </script>
            