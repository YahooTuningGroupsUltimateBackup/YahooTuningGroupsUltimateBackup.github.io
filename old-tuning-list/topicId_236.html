<a href="/old-tuning-list">back to list</a><h1>TUNING digest 590</h1><h3><a id=2401 href="#2401">ðŸ”—</a>Jeff Welty &#x3C;jwelty@wdni.com&#x3E;</h3><span>12/20/1995 6:13:43 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'>> Sure. Maybe you can tell us how your program works, what is the<br>> expression you are optimising. Is it linear or nonlinear?<br>> What are the 12 note weights you mentioned?<br>> <br>> Manuel Op de Coul    coul@ezh.nl<br><br>The objective function I minimize the sum of squared errors of<br>actual interval values minus desired interval values.<br><br>	errsum = 0 ;<br>	for n = 0 to 11 {<br>	    v1 = note_cents[n] ;<br>	    w1 = note_weight[n] ;<br>	    for i = 0 to 6 {<br>		int n2 = n+i+1 ;<br>		if (n2 < 12) {<br>		    v2 = note_cents[n2] ;<br>		    w2 = note_weight[n2] ;<br>		} else {<br>		    v2 = note_cents[n2-12]+1200. ;<br>		    w2 = note_weight[n2-12] ;<br>		}<br>		err = interval_weight[i]*w1*w2*((v2-v1) - desired_interval[i]) ;<br>		errsum = errsum + err*err ;<br>	    }<br>	}<br><br><br>The "parameters" to be fit for this function are in the note_cents array<br>which contains the cents values for the 12 notes in the scale (i.e. 0,100,<br>200,...,1100) for equal spaced half steps.<br><br>The optimization routine doesn't really know if the function is linear or<br>nonlinear, and, frankly, I don't either (haven't had time to think it<br>through entirely.)  The optimization will converge, and seems to produce<br>reasonable values.<br><br>The weights are entirely arbitrary.  For example use a weight of 1 for all<br>12 notes and 7 intervals and you'd get the equivalent of an unweighted fit.<br><br>On the other hand you could give C,D,E,F,G,A and B weights of 100 and leave<br>C#,D#,F#,G#,A# with weights of 1 and you'd get an optimized set of note values<br>for the C tonic scale.<br><br>Similarly you can weight the intervals so the fifths are nearly perfect, but<br>the minor 3rds get pretty bad, or whatever.<br><br>I gotta go do a christmas party (best excuse I've had all year to cut a<br>mail message short).<br><br>More on this later.  I'll attempt to get the code and sample data out to<br>anyone who requests.<br><br>Jeff<br><br><br><br>Received: from eartha.mills.edu [144.91.3.20] by vbv40.ezh.nl<br>           with SMTP-OpenVMS via TCP/IP; Thu, 21 Dec 1995 11:31 +0100<br>Received: from  by eartha.mills.edu via SMTP (940816.SGI.8.6.9/930416.SGI)<br>	for <coul@ezh.nl> id CAA06564; Thu, 21 Dec 1995 02:31:24 -0800<br>Date: Thu, 21 Dec 1995 02:31:24 -0800<br>Message-Id: <199512211030.CAA06456@eartha.mills.edu><br>Errors-To: madole@ella.mills.edu<br>Reply-To: tuning@eartha.mills.edu<br>Originator: tuning@eartha.mills.edu<br>Sender: tuning@eartha.mills.edu</div><a href="/old-tuning-list">back to list</a><h1>TUNING digest 590</h1><h3><a id=2401 href="#2401">ðŸ”—</a>Jeff Welty &#x3C;jwelty@wdni.com&#x3E;</h3><span>12/20/1995 6:13:43 PM</span><div style='margin: 0px 20px 20px; padding: 20px; background-color: #eee'>> Sure. Maybe you can tell us how your program works, what is the<br>> expression you are optimising. Is it linear or nonlinear?<br>> What are the 12 note weights you mentioned?<br>> <br>> Manuel Op de Coul    coul@ezh.nl<br><br>The objective function I minimize the sum of squared errors of<br>actual interval values minus desired interval values.<br><br>	errsum = 0 ;<br>	for n = 0 to 11 {<br>	    v1 = note_cents[n] ;<br>	    w1 = note_weight[n] ;<br>	    for i = 0 to 6 {<br>		int n2 = n+i+1 ;<br>		if (n2 < 12) {<br>		    v2 = note_cents[n2] ;<br>		    w2 = note_weight[n2] ;<br>		} else {<br>		    v2 = note_cents[n2-12]+1200. ;<br>		    w2 = note_weight[n2-12] ;<br>		}<br>		err = interval_weight[i]*w1*w2*((v2-v1) - desired_interval[i]) ;<br>		errsum = errsum + err*err ;<br>	    }<br>	}<br><br><br>The "parameters" to be fit for this function are in the note_cents array<br>which contains the cents values for the 12 notes in the scale (i.e. 0,100,<br>200,...,1100) for equal spaced half steps.<br><br>The optimization routine doesn't really know if the function is linear or<br>nonlinear, and, frankly, I don't either (haven't had time to think it<br>through entirely.)  The optimization will converge, and seems to produce<br>reasonable values.<br><br>The weights are entirely arbitrary.  For example use a weight of 1 for all<br>12 notes and 7 intervals and you'd get the equivalent of an unweighted fit.<br><br>On the other hand you could give C,D,E,F,G,A and B weights of 100 and leave<br>C#,D#,F#,G#,A# with weights of 1 and you'd get an optimized set of note values<br>for the C tonic scale.<br><br>Similarly you can weight the intervals so the fifths are nearly perfect, but<br>the minor 3rds get pretty bad, or whatever.<br><br>I gotta go do a christmas party (best excuse I've had all year to cut a<br>mail message short).<br><br>More on this later.  I'll attempt to get the code and sample data out to<br>anyone who requests.<br><br>Jeff<br><br><br><br>Received: from eartha.mills.edu [144.91.3.20] by vbv40.ezh.nl<br>           with SMTP-OpenVMS via TCP/IP; Thu, 21 Dec 1995 11:31 +0100<br>Received: from  by eartha.mills.edu via SMTP (940816.SGI.8.6.9/930416.SGI)<br>	for <coul@ezh.nl> id CAA06564; Thu, 21 Dec 1995 02:31:24 -0800<br>Date: Thu, 21 Dec 1995 02:31:24 -0800<br>Message-Id: <199512211030.CAA06456@eartha.mills.edu><br>Errors-To: madole@ella.mills.edu<br>Reply-To: tuning@eartha.mills.edu<br>Originator: tuning@eartha.mills.edu<br>Sender: tuning@eartha.mills.edu</div>